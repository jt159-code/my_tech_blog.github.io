<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Redis(一)</title>
      <link href="/my_tech_blog.github.io/2025/11/09/Redis_1/"/>
      <url>/my_tech_blog.github.io/2025/11/09/Redis_1/</url>
      
        <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库（一）</title>
      <link href="/my_tech_blog.github.io/2025/11/09/%E6%95%B0%E6%8D%AE%E5%BA%93_1/"/>
      <url>/my_tech_blog.github.io/2025/11/09/%E6%95%B0%E6%8D%AE%E5%BA%93_1/</url>
      
        <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统（一）</title>
      <link href="/my_tech_blog.github.io/2025/11/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_1/"/>
      <url>/my_tech_blog.github.io/2025/11/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_1/</url>
      
        <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络（一）：OSI七层模型</title>
      <link href="/my_tech_blog.github.io/2025/11/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_1/"/>
      <url>/my_tech_blog.github.io/2025/11/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_1/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网络（一）：OSI七层模型"><a href="#计算机网络（一）：OSI七层模型" class="headerlink" title="计算机网络（一）：OSI七层模型"></a>计算机网络（一）：OSI七层模型</h1><h2 id="一、OSI七层网络参考模型"><a href="#一、OSI七层网络参考模型" class="headerlink" title="一、OSI七层网络参考模型"></a>一、OSI七层网络参考模型</h2><p>OSI（Open Systems Interconnection）参考模型是国际标准化组织提出的网络通信概念模型，将网络通信的工作分为7个层次。</p><h3 id="（1）应用层（Application-Layer）-第7层"><a href="#（1）应用层（Application-Layer）-第7层" class="headerlink" title="（1）应用层（Application Layer） - 第7层"></a>（1）应用层（Application Layer） - 第7层</h3><p><strong>作用</strong>：为应用程序提供网络服务接口，直接面向用户。</p><p><strong>主要功能</strong>：</p><ul><li>提供用户接口，支持各种网络服务</li><li>识别通信伙伴的身份和可用性</li><li>同步通信过程</li><li>错误恢复的约定</li></ul><p><strong>典型协议和服务</strong>：</p><ul><li>HTTP&#x2F;HTTPS：网页浏览</li><li>FTP：文件传输</li><li>SMTP&#x2F;POP3&#x2F;IMAP：电子邮件</li><li>DNS：域名解析</li><li>SSH：安全远程登录</li></ul><p><strong>数据单位</strong>：报文（Message）</p><h3 id="（2）表示层（Presentation-Layer）-第6层"><a href="#（2）表示层（Presentation-Layer）-第6层" class="headerlink" title="（2）表示层（Presentation Layer） - 第6层"></a>（2）表示层（Presentation Layer） - 第6层</h3><p><strong>作用</strong>：处理两个通信系统中交换信息的表示方式，确保不同系统能够理解彼此的数据。</p><p><strong>主要功能</strong>：</p><ul><li>数据格式转换（编码、解码）</li><li>数据加密和解密</li><li>数据压缩和解压缩</li><li>字符集转换</li></ul><p><strong>实际应用</strong>：</p><ul><li>JPEG、MPEG等多媒体格式处理</li><li>SSL&#x2F;TLS加密</li><li>ASCII与Unicode转换</li></ul><p><strong>数据单位</strong>：报文（Message）</p><h3 id="（3）会话层（Session-Layer）-第5层"><a href="#（3）会话层（Session-Layer）-第5层" class="headerlink" title="（3）会话层（Session Layer） - 第5层"></a>（3）会话层（Session Layer） - 第5层</h3><p><strong>作用</strong>：建立、管理和终止应用程序之间的会话连接。</p><p><strong>主要功能</strong>：</p><ul><li>建立、维护和终止会话</li><li>会话同步控制</li><li>对话控制（全双工、半双工）</li><li>故障恢复点设置</li></ul><p><strong>实际应用</strong>：</p><ul><li>RPC（远程过程调用）</li><li>NetBIOS会话管理</li><li>断点续传的会话管理</li></ul><p><strong>数据单位</strong>：报文（Message）</p><h3 id="（4）传输层（Transport-Layer）-第4层"><a href="#（4）传输层（Transport-Layer）-第4层" class="headerlink" title="（4）传输层（Transport Layer） - 第4层"></a>（4）传输层（Transport Layer） - 第4层</h3><p><strong>作用</strong>：为端到端通信提供可靠或不可靠的数据传输服务。</p><p><strong>主要功能</strong>：</p><ul><li>端到端的连接管理</li><li>流量控制</li><li>差错控制</li><li>数据分段和重组</li><li>多路复用和解复用</li></ul><p><strong>核心协议</strong>：</p><ul><li><strong>TCP</strong>：面向连接、可靠传输</li><li><strong>UDP</strong>：无连接、高效传输</li></ul><p><strong>数据单位</strong>：段（Segment）</p><h3 id="（5）网络层（Network-Layer）-第3层"><a href="#（5）网络层（Network-Layer）-第3层" class="headerlink" title="（5）网络层（Network Layer） - 第3层"></a>（5）网络层（Network Layer） - 第3层</h3><p><strong>作用</strong>：实现不同网络之间的数据包路由和转发。</p><p><strong>主要功能</strong>：</p><ul><li>逻辑寻址（IP地址）</li><li>路由选择</li><li>拥塞控制</li><li>分组转发</li></ul><p><strong>核心协议</strong>：</p><ul><li>IP（IPv4&#x2F;IPv6）</li><li>ICMP（网络控制消息）</li><li>OSPF、BGP（路由协议）</li></ul><p><strong>网络设备</strong>：路由器（Router）</p><p><strong>数据单位</strong>：包（Packet）</p><h3 id="（6）数据链路层（Data-Link-Layer）-第2层"><a href="#（6）数据链路层（Data-Link-Layer）-第2层" class="headerlink" title="（6）数据链路层（Data Link Layer） - 第2层"></a>（6）数据链路层（Data Link Layer） - 第2层</h3><p><strong>作用</strong>：在相邻节点之间提供可靠的数据帧传输。</p><p><strong>主要功能</strong>：</p><ul><li>物理寻址（MAC地址）</li><li>帧的封装和拆装</li><li>差错检测（CRC校验）</li><li>流量控制</li><li>介质访问控制</li></ul><p><strong>子层划分</strong>：</p><ul><li><strong>LLC</strong>：逻辑链路控制</li><li><strong>MAC</strong>：介质访问控制</li></ul><p><strong>网络设备</strong>：交换机（Switch）、网桥（Bridge）</p><p><strong>数据单位</strong>：帧（Frame）</p><h3 id="（7）物理层（Physical-Layer）-第1层"><a href="#（7）物理层（Physical-Layer）-第1层" class="headerlink" title="（7）物理层（Physical Layer） - 第1层"></a>（7）物理层（Physical Layer） - 第1层</h3><p><strong>作用</strong>：在物理介质上传输原始比特流。</p><p><strong>主要功能</strong>：</p><ul><li>定义机械、电气特性</li><li>比特同步</li><li>线路配置</li><li>数据传输模式</li></ul><p><strong>涉及内容</strong>：</p><ul><li>网线、光纤、无线信号</li><li>接口类型（RJ45、USB）</li><li>信号编码（曼彻斯特编码）</li><li>传输速率</li></ul><p><strong>数据单位</strong>：比特（Bit）</p><h2 id="二、数据封装过程"><a href="#二、数据封装过程" class="headerlink" title="二、数据封装过程"></a>二、数据封装过程</h2><p>数据在网络中传输时的封装过程：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">应用层数据 → 表示层加密/压缩 → 会话层建立会话</span><br><span class="line">    ↓</span><br><span class="line">传输层添加TCP/UDP头部 → 网络层添加IP头部</span><br><span class="line">    ↓</span><br><span class="line">数据链路层添加帧头帧尾 → 物理层转换为比特流</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OSI模型 </tag>
            
            <tag> 网络协议 </tag>
            
            <tag> 网络体系结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++数据结构(八)：设计模式</title>
      <link href="/my_tech_blog.github.io/2025/11/09/C++%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_8/"/>
      <url>/my_tech_blog.github.io/2025/11/09/C++%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_8/</url>
      
        <content type="html"><![CDATA[<h1 id="C-数据结构（八）：设计模式"><a href="#C-数据结构（八）：设计模式" class="headerlink" title="C++数据结构（八）：设计模式"></a>C++数据结构（八）：设计模式</h1><p>设计模式是解决软件设计问题的经典解决方案。它们是在多年实践中总结出来的最佳实践，可以帮助开发者编写可维护、可扩展和可重用的代码。常见的设计模式分为三大类：</p><h2 id="一、创建型模式（CreatI-Onal-Patterns）"><a href="#一、创建型模式（CreatI-Onal-Patterns）" class="headerlink" title="一、创建型模式（CreatI&#x2F;Onal Patterns）"></a>一、创建型模式（CreatI&#x2F;Onal Patterns）</h2><h3 id="（一）单例模式（Singleton）"><a href="#（一）单例模式（Singleton）" class="headerlink" title="（一）单例模式（Singleton）"></a>（一）<strong>单例模式（Singleton）</strong></h3><p>确保一个类只有一个实例，并提供全局访问点。</p><p>将构造函数私有，删除拷贝构造和赋值，静态成员函数创建对象（静态实例指针&#x2F;对象（全局唯一实例存储）+静态获取方法（提供全局访问点）），确保线程安全（懒汉式或者饿汉式）</p><h4 id="1、懒汉式"><a href="#1、懒汉式" class="headerlink" title="1、懒汉式"></a>1、懒汉式</h4><p>是指在第一次调用时才创建实例。使用双重检查锁定（互斥锁：竞态条件（多线程同时调用可能重复创建实例，确保原子操作））</p><p>C++11 保证了局部静态变量的初始化是线程安全的（明确规定局部静态变量的初始化在多线程环境下只会执行一次，由编译器插入底层同步机制（类似隐式锁）），因此可以利用这一特性实现简单的线程安全单例模式。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span> </span>&#123;<span class="comment">//C++11之前</span></span><br><span class="line">    <span class="keyword">if</span> (!instance) &#123;  <span class="comment">// 第一次检查（避免每次加锁）</span></span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (!instance) &#123;  <span class="comment">// 第二次检查（确保唯一性）</span></span><br><span class="line">            instance = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2、饿汉式"><a href="#2、饿汉式" class="headerlink" title="2、饿汉式"></a>2、饿汉式</h4><p>是指在程序启动时就创建实例。由于实例在程序启动时就已经创建，因此不存在多线程竞争问题。</p><p><code>std::call_once</code>，可以确保某个函数只被调用一次，适合用于实现线程安全的单例模式。</p><h4 id="3、应用"><a href="#3、应用" class="headerlink" title="3、应用"></a>3、应用</h4><h5 id="（1）数据库连接池"><a href="#（1）数据库连接池" class="headerlink" title="（1）数据库连接池"></a>（1）数据库连接池</h5><p>管理和复用数据库连接（Web应用，微服务框架，高并发系统，云数据库访问）</p><p>单例模式确保全局唯一连接池实例（双重检查锁定）+对象池模式（类似享元模式，但复用昂贵对象，主动回收、分配）管理数据库连接的创建获取与回收+代理模式（可选）</p><p>类似线程池</p><h3 id="（二）工厂方法模式（Factory-Method）"><a href="#（二）工厂方法模式（Factory-Method）" class="headerlink" title="（二）工厂方法模式（Factory Method）"></a>（二）<strong>工厂方法模式（Factory Method）</strong></h3><p>定义一个创建对象的接口，但由子类决定实例化哪个类。</p><h4 id="1、应用"><a href="#1、应用" class="headerlink" title="1、应用"></a>1、应用</h4><h5 id="（1）线程池"><a href="#（1）线程池" class="headerlink" title="（1）线程池"></a>（1）线程池</h5><p>线程池本质是对象池：线程池是对象池模式的具体应用，但因为其任务调度机制更复杂，通常用 生产者-消费者模式描述。</p><p>工厂模式统一创建线程+命令模式将任务封装为对象+生产者-消费者模式通过任务队列解耦任务提交和执行</p><h6 id="线程池的种类"><a href="#线程池的种类" class="headerlink" title="线程池的种类"></a>线程池的种类</h6><p>固定大小线程池：线程数量确定，适合稳定负载</p><p>动态扩容线程池：根据任务需求动态调整线程数</p><h6 id="关键参数"><a href="#关键参数" class="headerlink" title="关键参数"></a>关键参数</h6><p>线程数量：默认CPU核心数量</p><p>队列任务容量</p><p>线程空闲超时</p><h3 id="（三）抽象工厂模式（Abstract-Factory）"><a href="#（三）抽象工厂模式（Abstract-Factory）" class="headerlink" title="（三）抽象工厂模式（Abstract Factory）"></a>（三）<strong>抽象工厂模式（Abstract Factory）</strong></h3><p>提供一个接口，用于创建相关或依赖对象的家族，而不需要指定具体类。</p><h4 id="1、如何阻止一个类被实例化"><a href="#1、如何阻止一个类被实例化" class="headerlink" title="1、如何阻止一个类被实例化"></a>1、如何阻止一个类被实例化</h4><p>工具类、接口类、单例模式</p><p>抽象基类；构造函数private（静态成员函数创建对象：单例模式）；不允许在类外部创建类对象，只能在类内部创建对象；删除构造函数（&#x3D;delete）</p><h3 id="（四）建造者模式（Builder）"><a href="#（四）建造者模式（Builder）" class="headerlink" title="（四）建造者模式（Builder）"></a>（四）<strong>建造者模式（Builder）</strong></h3><p>将一个复杂对象的构建与其表示分离，使得同样的构建过程可以创建不同的表示。</p><h3 id="（五）原型模式（Prototype）"><a href="#（五）原型模式（Prototype）" class="headerlink" title="（五）原型模式（Prototype）"></a>（五）<strong>原型模式（Prototype）</strong></h3><p>通过复制现有对象来创建新对象。</p><h2 id="二、结构型模式（Structural-Patterns）"><a href="#二、结构型模式（Structural-Patterns）" class="headerlink" title="二、结构型模式（Structural Patterns）"></a>二、结构型模式（Structural Patterns）</h2><h3 id="（一）适配器模式（Adapter）"><a href="#（一）适配器模式（Adapter）" class="headerlink" title="（一）适配器模式（Adapter）"></a>（一）<strong>适配器模式（Adapter）</strong></h3><p>将一个类的接口转换成客户端期望的另一个接口。</p><h3 id="（二）装饰器模式（Decorator）"><a href="#（二）装饰器模式（Decorator）" class="headerlink" title="（二）装饰器模式（Decorator）"></a>（二）<strong>装饰器模式（Decorator）</strong></h3><p>动态地给对象添加额外的职责。</p><h3 id="（三）代理模式（Proxy）"><a href="#（三）代理模式（Proxy）" class="headerlink" title="（三）代理模式（Proxy）"></a>（三）<strong>代理模式（Proxy）</strong></h3><p>为其他对象提供一个代理以控制对这个对象的访问。</p><h4 id="1、代理模式类关系图"><a href="#1、代理模式类关系图" class="headerlink" title="1、代理模式类关系图"></a>1、代理模式类关系图</h4><p>Subject：抽象接口，定义request方法</p><p>RealSubject：真实对象，执行实际逻辑</p><p>Proxy：代理类，控制对真实对象的访问</p><h4 id="2、私有方法能代理吗"><a href="#2、私有方法能代理吗" class="headerlink" title="2、私有方法能代理吗"></a>2、私有方法能代理吗</h4><p>静态语言：代理类不可以访问私有方法（C++使用友元，Java使用反射）</p><p>动态语言可以直接访问</p><h3 id="（四）外观模式（Facade）"><a href="#（四）外观模式（Facade）" class="headerlink" title="（四）外观模式（Facade）"></a>（四）<strong>外观模式（Facade）</strong></h3><p>提供一个统一的接口，用来访问子系统中的一群接口。</p><h3 id="（五）桥接模式（Bridge）"><a href="#（五）桥接模式（Bridge）" class="headerlink" title="（五）桥接模式（Bridge）"></a>（五）<strong>桥接模式（Bridge）</strong></h3><p>将抽象部分与实现部分分离，使它们可以独立变化。</p><h3 id="（六）组合模式（Composite）"><a href="#（六）组合模式（Composite）" class="headerlink" title="（六）组合模式（Composite）"></a>（六）<strong>组合模式（Composite）</strong></h3><p>将对象组合成树形结构以表示“部分-整体”的层次结构。</p><h3 id="（七）享元模式（Flyweight）"><a href="#（七）享元模式（Flyweight）" class="headerlink" title="（七）享元模式（Flyweight）"></a>（七）<strong>享元模式（Flyweight）</strong></h3><p>通过共享技术有效地支持大量细粒度的对象。</p><h4 id="1、对象复用"><a href="#1、对象复用" class="headerlink" title="1、对象复用"></a>1、对象复用</h4><p>将对象存储到“对象池”中实现对象的重复利用，可以避免多次创建重复对象的开销，节约系统资源（缓存、单例模式）</p><h2 id="三、行为型模式（BehavI-Oral-Patterns）"><a href="#三、行为型模式（BehavI-Oral-Patterns）" class="headerlink" title="三、行为型模式（BehavI&#x2F;Oral Patterns）"></a>三、行为型模式（BehavI&#x2F;Oral Patterns）</h2><h3 id="（一）策略模式（Strategy）"><a href="#（一）策略模式（Strategy）" class="headerlink" title="（一）策略模式（Strategy）"></a>（一）<strong>策略模式（Strategy）</strong></h3><p>定义一系列算法，将它们封装起来，并使它们可以互相替换。</p><h3 id="（二）观察者模式（Observer）"><a href="#（二）观察者模式（Observer）" class="headerlink" title="（二）观察者模式（Observer）"></a>（二）<strong>观察者模式（Observer）</strong></h3><p>定义对象间的一对多依赖关系，当一个对象改变状态时，其所有依赖者都会收到通知并自动更新。e.g.<strong>事件驱动</strong></p><h4 id="1、特点"><a href="#1、特点" class="headerlink" title="1、特点"></a>1、特点</h4><p>松耦合：Subject和观察者之间没有直接依赖</p><p>动态订阅：观察者可以随时注册、注销</p><p>事件驱动：适用于异步通知</p><h4 id="2、解决问题"><a href="#2、解决问题" class="headerlink" title="2、解决问题"></a>2、解决问题</h4><p> 实时数据更新</p><p>事件监听</p><p>日志系统</p><h3 id="（三）命令模式（Command）"><a href="#（三）命令模式（Command）" class="headerlink" title="（三）命令模式（Command）"></a>（三）<strong>命令模式（Command）</strong></h3><p>将请求封装为对象，从而使你可以用不同的请求对客户进行参数化。</p><h3 id="（四）状态模式（State）"><a href="#（四）状态模式（State）" class="headerlink" title="（四）状态模式（State）"></a>（四）<strong>状态模式（State）</strong></h3><p>允许对象在其内部状态改变时改变其行为。</p><h3 id="（五）责任链模式（Chain-of-Responsibility）"><a href="#（五）责任链模式（Chain-of-Responsibility）" class="headerlink" title="（五）责任链模式（Chain of Responsibility）"></a>（五）<strong>责任链模式（Chain of Responsibility）</strong></h3><p>将请求的发送者和接收者解耦，使多个对象都有机会处理请求。</p><h3 id="（六）模板方法模式（Template-Method）"><a href="#（六）模板方法模式（Template-Method）" class="headerlink" title="（六）模板方法模式（Template Method）"></a>（六）<strong>模板方法模式（Template Method）</strong></h3><p>定义一个算法的骨架，而将一些步骤延迟到子类中。</p><h3 id="（七）迭代器模式（Iterator）"><a href="#（七）迭代器模式（Iterator）" class="headerlink" title="（七）迭代器模式（Iterator）"></a>（七）迭代器模式（Iterator）</h3><p>提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部表示。</p><h3 id="（八）中介者模式（Mediator）"><a href="#（八）中介者模式（Mediator）" class="headerlink" title="（八）中介者模式（Mediator）"></a>（八）中介者模式（Mediator）</h3><p>定义一个中介对象来封装一系列对象之间的交互。</p><h3 id="（九）备忘录模式（Memento）"><a href="#（九）备忘录模式（Memento）" class="headerlink" title="（九）备忘录模式（Memento）"></a>（九）备忘录模式（Memento）</h3><p>在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。</p><h3 id="（十）访问者模式（Visitor）"><a href="#（十）访问者模式（Visitor）" class="headerlink" title="（十）访问者模式（Visitor）"></a>（十）访问者模式（Visitor）</h3><p>表示一个作用于某对象结构中的各元素的操作。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++数据结构(七)：STL</title>
      <link href="/my_tech_blog.github.io/2025/11/09/C++%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_7/"/>
      <url>/my_tech_blog.github.io/2025/11/09/C++%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_7/</url>
      
        <content type="html"><![CDATA[<h1 id="C-数据结构（七）：STL"><a href="#C-数据结构（七）：STL" class="headerlink" title="C++数据结构（七）：STL"></a>C++数据结构（七）：STL</h1><h2 id="一、C-中标准库是什么"><a href="#一、C-中标准库是什么" class="headerlink" title="一、C++中标准库是什么"></a>一、C++中标准库是什么</h2><h3 id="（一）标准函数库"><a href="#（一）标准函数库" class="headerlink" title="（一）标准函数库"></a>（一）标准函数库</h3><p>独立的通用的，不属于任何类的函数，继承自C语言，过程式，不设计面向对象</p><p>如输入输出、数学函数、字符串处理、内存关联、时间和日期、随机数</p><h3 id="二）标准模板库STL"><a href="#二）标准模板库STL" class="headerlink" title="(二）标准模板库STL"></a>(二）标准模板库STL</h3><p>基于模板的，有高可用性和可扩展性</p><p>容器（序列、关联、无序关联、容器适配器）；迭代器；算法；函数对象（仿函数）；适配器（容器适配器、函数适配器）；采用面向对象；组件通过迭代器解耦，使得算法可以独立于容器使用</p><h2 id="二、STL"><a href="#二、STL" class="headerlink" title="二、STL"></a>二、STL</h2><h3 id="（一）什么是STL"><a href="#（一）什么是STL" class="headerlink" title="（一）什么是STL"></a>（一）什么是STL</h3><p>算法、容器（序列式容器、关联式容器、适配器）、迭代器</p><p>容器线程不安全，需要mutex（C++标准库提供的互斥锁，用于保护共享资源，防止多线程并发访问导致数据竞争）</p><h3 id="（二）迭代器"><a href="#（二）迭代器" class="headerlink" title="（二）迭代器"></a>（二）迭代器</h3><h4 id="1、迭代器如何实现"><a href="#1、迭代器如何实现" class="headerlink" title="1、迭代器如何实现"></a>1、迭代器如何实现</h4><p>与容器相关联的指针，提供遍历容器所有元素的借接口</p><h4 id="2、-it和it"><a href="#2、-it和it" class="headerlink" title="2、++it和it++"></a>2、++it和it++</h4><p>前者返回一个引用（没有临时对象），后者返回一个对象（会产生临时对象）</p><p>整数的后置++也需要临时对象存储，返回旧副本值</p><p>通常不是原子的，需多步骤完成</p><h3 id="（三）容器"><a href="#（三）容器" class="headerlink" title="（三）容器"></a>（三）容器</h3><h4 id="1、顺序容器"><a href="#1、顺序容器" class="headerlink" title="1、顺序容器"></a>1、顺序容器</h4><p>vector和deque和list和slist</p><h5 id="（1）vector"><a href="#（1）vector" class="headerlink" title="（1）vector"></a>（1）vector</h5><p>和数组类似，分配一块连续内存空间，当内存不够会重新分配一块内存并拷贝，支持高效率访问和在尾部插入、删除，不需要考虑容量问题；迭代器使用后失效，重新分配空间则所有迭代器失效（随机访问迭代器）</p><p>单向开口，在尾部进行操作</p><h6 id="①扩容"><a href="#①扩容" class="headerlink" title="①扩容"></a>①扩容</h6><p>2倍扩容（或1.5倍）：分配一块更大的内存，将原来的数据复制过来，将多次插入操作的扩容开销分摊（保证常数时间复杂度）</p><h6 id="②删除"><a href="#②删除" class="headerlink" title="②删除"></a>②删除</h6><p>除了list大部分顺序容器（vector、deque）删除元素使得所指向的迭代器和其之后的迭代器均失效（一旦空间重新配置，迭代器失效），但是返回下一个有效迭代器</p><p>remove&#x2F;pop_back&#x2F;erase都可以删除，但是remove不会改变size大小（都不会改变capacity）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="built_in">remove</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), <span class="number">2</span>); </span><br><span class="line"><span class="comment">// vec内容变为 &#123;1, 3, 4, 4&#125;，size仍为4！</span></span><br></pre></td></tr></table></figure><h6 id="③释放空间"><a href="#③释放空间" class="headerlink" title="③释放空间"></a>③释放空间</h6><p>只增不减，clear只清空元素，内存不回收，可以用swap释放多余内存或清空</p><h5 id="（2）deque"><a href="#（2）deque" class="headerlink" title="（2）deque"></a>（2）deque</h5><p>双端队列，随机访问迭代器（不是普通指针，复杂度比vector高，当前元素、缓冲区第一个元素、缓冲区最后一个元素、map的node（map是一小块连续空间，每个元素称为一个节点，每个node是一个指针，指向另一个比较大的连续空间，称为缓冲区，数据就存在缓冲区中））</p><p>删除同时释放内存使用deque，deque是双向开口（可以在常数时间内对头部进行操作）的连续线性空间，没有容量概念（动态分段连续空间）、空间保留功能</p><p>最大任务是维护整体的连续性</p><h5 id="（3）list"><a href="#（3）list" class="headerlink" title="（3）list"></a>（3）list</h5><p>环形（链表的头节点（哨兵节点）的 prev指向尾节点，尾节点的next指向头节点）双向链表，内存空间不连续，可以高效插入、删除，随机访问效率低；迭代器使用后还可以使用；可以使用反向迭代器</p><h6 id="①迭代器"><a href="#①迭代器" class="headerlink" title="①迭代器"></a>①迭代器</h6><p>插入操作：迭代器不会失效（新节点不影响现有节点指针）</p><p>删除操作：仅被删除元素的迭代器失效，其他迭代器仍有效。</p><h6 id="②使用场景"><a href="#②使用场景" class="headerlink" title="②使用场景"></a>②使用场景</h6><p>频繁插入删除，无需随机访问，如LRU缓存</p><h5 id="（4）slist"><a href="#（4）slist" class="headerlink" title="（4）slist"></a>（4）slist</h5><p>单向链表，操作可能不如list灵活，但是占用空间小、操作快</p><p>只能在链表头插入元素，其它位置插入只能插入到指定位置之前</p><p>不支持反向遍历、插入&#x2F;删除时间复杂度为O(n)-&gt;寻找前驱</p><h4 id="2、关联容器（无序）"><a href="#2、关联容器（无序）" class="headerlink" title="2、关联容器（无序）"></a>2、关联容器（无序）</h4><p>unordered_set和unordered_map的底层是哈希表</p><p>unoredered_set仅存储键值，unordered_map每一个元素是一个键值(key-value)对</p><h5 id="（1）哈希表（散列表）的基本原理"><a href="#（1）哈希表（散列表）的基本原理" class="headerlink" title="（1）哈希表（散列表）的基本原理"></a>（1）哈希表（散列表）的基本原理</h5><p>通过哈希函数将键映射到一个固定大小的数据（桶数组）中的某个位置</p><p>哈希函数：将键转换为一个整数，理想情况下应该均匀分布键，减少冲突（不同键映射到同一个桶）</p><p>桶数组：哈希表维护一个桶数组，每个桶可以</p><p>迭代器只提供前进操作，不提供后退操作</p><h6 id="①哈希冲突"><a href="#①哈希冲突" class="headerlink" title="①哈希冲突"></a>①哈希冲突</h6><p>链地址法&#x2F;开链法（hashmap&#x2F;unordered_map是这个，底层是哈希表，前向迭代器）</p><p>开放地址法（线性探测（依次向后）、二次探测（步长1^2,2^2,3^2）、伪随机探测（步长随机））</p><p>再散列（冲突时使用另一种哈希再计算，直到不冲突）</p><p>公共溢出区（计算结果相同就放入公共溢出区）</p><h6 id="②实现细节（组件：哈希函数、桶数组、冲突解决策略）"><a href="#②实现细节（组件：哈希函数、桶数组、冲突解决策略）" class="headerlink" title="②实现细节（组件：哈希函数、桶数组、冲突解决策略）"></a>②实现细节（组件：哈希函数、桶数组、冲突解决策略）</h6><p>A.数据结构</p><p>桶数组（vector<list>）</p><p>哈希函数</p><p>负载（装载）因子（元素&#x2F;桶，如果超过阈值要扩容）</p><p>B.主要操作</p><p>插入删除查找（更适合查询，因为插入可能会扩容，修改可能需要重新哈希，删除需要处理冲突）</p><p>扩容：更大的桶数组（O(n)）</p><h6 id="③哈希表遍历效率低"><a href="#③哈希表遍历效率低" class="headerlink" title="③哈希表遍历效率低"></a>③哈希表遍历效率低</h6><p>稀疏存储、内存不连续、冲突处理</p><p>维护所有元素双链表O(n)遍历但是额外内存</p><p>密集存储使用连续内存，删除时复杂</p><p>分块哈希，将哈希表分为多个块，位图操作快速跳过空块，实现复杂</p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20250414112908162.png" alt="image-20250414112908162" style="zoom:67%;" /><h4 id="3、关联容器（有序）"><a href="#3、关联容器（有序）" class="headerlink" title="3、关联容器（有序）"></a>3、关联容器（有序）</h4><h5 id="（1）组件"><a href="#（1）组件" class="headerlink" title="（1）组件"></a>（1）组件</h5><p>红黑树（有序）或哈希表（无序）</p><p>迭代器（双向迭代器：有序；前向迭代器：无序）</p><p>比较器（默认less）</p><h5 id="（2）set"><a href="#（2）set" class="headerlink" title="（2）set"></a>（2）set</h5><p>使用红黑树（根据元素值自动排序）实现，参数模板，set是value，双向迭代器（删除节点后不会影响其他节点迭代器）</p><h6 id="①红黑树特性"><a href="#①红黑树特性" class="headerlink" title="①红黑树特性"></a>①红黑树特性</h6><p>二叉排序树：左子树不空，则左子树上所有节点的值均小于或等于它根节点的值。右子树大于等于，查找时间O（logn）</p><p>每个节点不是黑色就是红色</p><p>根节点为黑色</p><p>如果节点为红色，子节点为黑色</p><p>任意节点到NULL的任何路径，黑色节点数相同</p><h6 id="②使用场景-1"><a href="#②使用场景-1" class="headerlink" title="②使用场景"></a>②使用场景</h6><p>去重+排序，如黑名单</p><h5 id="（2）map"><a href="#（2）map" class="headerlink" title="（2）map"></a>（2）map</h5><p>使用红黑树（根据键值自动排序）实现，参数模板，map是key+value，双向迭代器（删除节点后不会影响其他节点迭代器），迭代器不是constant也不是mutable（部分可变：key不能改，value可以改）</p><h6 id="①map插入"><a href="#①map插入" class="headerlink" title="①map插入"></a>①map插入</h6><p>[]&#x3D;；insert（pair&#x2F;value&#x2F;make_pair）</p><p>红黑树的独一无二插入（multimap和map只有插入时调用的函数不同“可重复插入”）</p><h6 id="②map查找"><a href="#②map查找" class="headerlink" title="②map查找"></a>②map查找</h6><p>[]将关键码作为下标查找，返回对应值，不存在则插入</p><p>find用关键码执行查找，返回迭代器，不存在则返回尾迭代器</p><h6 id="③使用场景"><a href="#③使用场景" class="headerlink" title="③使用场景"></a>③使用场景</h6><p>需要有序键值对，如字典</p><h5 id="（3）set和map区别"><a href="#（3）set和map区别" class="headerlink" title="（3）set和map区别"></a>（3）set和map区别</h5><h4 id="4、容器适配器"><a href="#4、容器适配器" class="headerlink" title="4、容器适配器"></a>4、容器适配器</h4><p>修改某种接口，形成另一种风貌</p><p>无迭代器</p><h5 id="（1）stack-queue"><a href="#（1）stack-queue" class="headerlink" title="（1）stack&#x2F;queue"></a>（1）stack&#x2F;queue</h5><p>stack&#x2F;queue底层一般用list或者deque实现，封闭一端</p><h5 id="（2）priority-queue"><a href="#（2）priority-queue" class="headerlink" title="（2）priority_queue"></a>（2）priority_queue</h5><p>priority_queue底层用heap（vector）</p><h5 id="（3）堆"><a href="#（3）堆" class="headerlink" title="（3）堆"></a>（3）堆</h5><p>不是容器，是priority_queue的底层实现机制，使用数组vector和一组heap算法实现堆（完全二叉树）</p><h6 id="①pop-heap"><a href="#①pop-heap" class="headerlink" title="①pop_heap"></a>①pop_heap</h6><p>将堆顶元素移动到序列末尾（下溯），不会删除，需要pop_back()</p><h6 id="②push-heap"><a href="#②push-heap" class="headerlink" title="②push_heap"></a>②push_heap</h6><p>需要先将元素插入到序列末尾push_back，然后调用push_heap进行上溯</p><h6 id="③sort"><a href="#③sort" class="headerlink" title="③sort"></a>③sort</h6><p>不断pop_head，将堆变为有序，不会清空树，需要make_heap才能使用堆操作</p><h6 id="④make-heap"><a href="#④make-heap" class="headerlink" title="④make_heap"></a>④make_heap</h6><p>将现有结构调整为堆结构（Floyd算法采用自底向上的调整方式，从最后一个非叶子节点开始，逐步向前进行下溯（sift down操作）</p><h3 id="（三）STL的两级空间配置器"><a href="#（三）STL的两级空间配置器" class="headerlink" title="（三）STL的两级空间配置器"></a>（三）STL的两级空间配置器</h3><h4 id="1、为什么需要二级空间配置器"><a href="#1、为什么需要二级空间配置器" class="headerlink" title="1、为什么需要二级空间配置器"></a>1、为什么需要二级空间配置器</h4><p>动态开辟内存时，会在堆上申请，频繁在堆上开辟释放内存，会在堆上造成很多外部碎片，当找不到合适内存时就进行空间合并。当开辟内存时如果小于128bytes，就使用二级空间配置器（默认）</p><h4 id="2、一级空间配置器"><a href="#2、一级空间配置器" class="headerlink" title="2、一级空间配置器"></a>2、一级空间配置器</h4><p>函数：allocate、deallocate、reallocate；以malloc&#x2F;free&#x2F;realloc等C涵执行实际的内存分配（free后，内存由glibc（ptmalloc）管理（可能放入bin中），但STL一级配置器对此毫不知情）不维护链表</p><h4 id="3、二级空间配置器"><a href="#3、二级空间配置器" class="headerlink" title="3、二级空间配置器"></a>3、二级空间配置器</h4><p>维护16条链表（8~128字节），看相应尺寸的链表是否为空，不为空就从free_list中拔出，指针向后移动；为空先看内存池是否为空，不为空则分配20个节点大小，不够20个就看是否满足一个，如果一个也不满足，将内存池挂到对应free_list；二级空间配置器使用malloc从堆上申请内存，申请40块，一半用，一半内存池；malloc失败找更大的free_list；最终失败则回调一级空间配置器</p><h4 id="4、二级缺点"><a href="#4、二级缺点" class="headerlink" title="4、二级缺点"></a>4、二级缺点</h4><p>内部碎片</p><p>内存挂在自由链表，不会还给操作系统</p><h4 id="5、内存池"><a href="#5、内存池" class="headerlink" title="5、内存池"></a>5、内存池</h4><p>预分配的大块内存，由程序自行管理分配&#x2F;释放，避免频繁调用系统API。初始内存来自堆，但管理权属于STL，逻辑上独立</p><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><h4 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h4><p>选择排序：O(n^2)，不稳定</p><p>快速排序：O(nlogn)，不稳定</p><p>空间复杂度：<em>O</em>(log<em>n</em>)，即递归使用栈空间的空间代价的期望为 <em>O</em>(log<em>n</em>)</p><p>希尔排序：O(nlog^2n)，不稳定</p><p>堆排序：O(nlogn)，不稳定</p><p>空间复杂度：<em>O</em>(log<em>n</em>)，即递归使用栈空间的空间代价。</p><p>归并排序：O(nlogn)，稳定</p><p>冒泡排序：O(n^2)，稳定</p><p>插入排序：O(n^2)，稳定</p><p>基数排序：O(nk)，稳定</p><p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20250401102328208.png" alt="image-20250401102328208"></p><h5 id="（1）递归快排"><a href="#（1）递归快排" class="headerlink" title="（1）递归快排"></a>（1）递归快排</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">function2</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> start, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (start &gt;= end) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> idx = start;</span><br><span class="line"><span class="type">int</span> l = start + <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> r = end;</span><br><span class="line"><span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line"><span class="keyword">while</span> (l &lt;= r &amp;&amp; nums[l] &lt;= nums[idx]) &#123;</span><br><span class="line">l++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (l &lt;= r &amp;&amp; nums[r] &gt;= nums[idx]) &#123;</span><br><span class="line">r--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (l &lt; r) &#123;</span><br><span class="line"><span class="built_in">swap</span>(nums[l], nums[r]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">swap</span>(nums[idx], nums[r]);</span><br><span class="line"><span class="built_in">function2</span>(nums, start, r<span class="number">-1</span>);</span><br><span class="line"><span class="built_in">function2</span>(nums, r + <span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;nums= &#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">7</span>&#125;;</span><br><span class="line"><span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line"><span class="built_in">function2</span>(nums,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; i : nums) &#123;</span><br><span class="line">cout &lt;&lt; i&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-非递归排序"><a href="#2-非递归排序" class="headerlink" title="(2)非递归排序"></a>(2)非递归排序</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fun1</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;nums,<span class="type">int</span> l,<span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> idx = l;</span><br><span class="line"><span class="type">int</span> start = l<span class="number">+1</span>;</span><br><span class="line"><span class="type">int</span> end = r;</span><br><span class="line"><span class="keyword">while</span> (start &lt;= end) &#123;</span><br><span class="line"><span class="keyword">while</span> (start &lt;= end &amp;&amp; nums[start] &lt;= nums[idx]) &#123;</span><br><span class="line">start++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (start &lt;= end &amp;&amp; nums[end] &gt;= nums[idx]) &#123;</span><br><span class="line">end--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (start &lt; end) &#123;</span><br><span class="line"><span class="built_in">swap</span>(nums[start], nums[end]);</span><br><span class="line">start++;</span><br><span class="line">end--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">swap</span>(nums[idx], nums[end]);</span><br><span class="line"><span class="keyword">return</span> end;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun2</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">queue &lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;q;</span><br><span class="line"><span class="type">int</span> l = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">q.<span class="built_in">push</span>(&#123; l,r &#125;);</span><br><span class="line"><span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line"><span class="keyword">auto</span> f = q.<span class="built_in">front</span>();</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="type">int</span> p=<span class="built_in">fun1</span>(nums, f.first, f.second);</span><br><span class="line"><span class="keyword">if</span> (f.first &lt; p - <span class="number">1</span>) &#123;</span><br><span class="line">q.<span class="built_in">push</span>(&#123; f.first,p - <span class="number">1</span> &#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (p + <span class="number">1</span> &lt; f.second) &#123;</span><br><span class="line">q.<span class="built_in">push</span>(&#123; p + <span class="number">1</span>,f.second &#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;nums = &#123; <span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">7</span> &#125;;</span><br><span class="line"><span class="built_in">fun2</span>(nums);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; i : nums) &#123;</span><br><span class="line">cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++数据结构(六)：变量类型</title>
      <link href="/my_tech_blog.github.io/2025/11/09/C++%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_6/"/>
      <url>/my_tech_blog.github.io/2025/11/09/C++%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_6/</url>
      
        <content type="html"><![CDATA[<h1 id="C-数据结构（六）：变量类型"><a href="#C-数据结构（六）：变量类型" class="headerlink" title="C++数据结构（六）：变量类型"></a>C++数据结构（六）：变量类型</h1><h2 id="一、分类1"><a href="#一、分类1" class="headerlink" title="一、分类1"></a>一、分类1</h2><h3 id="（一）结构体"><a href="#（一）结构体" class="headerlink" title="（一）结构体"></a>（一）结构体</h3><h4 id="1、对齐问题"><a href="#1、对齐问题" class="headerlink" title="1、对齐问题"></a>1、对齐问题</h4><p>第一个成员的地址和结构体地址相同，按照size最大的成员进行对齐，可以使用alignof&#x2F;əˈlaɪn&#x2F;算出对齐方式，可以使用alignas指定对齐方式（若小于自然对齐的最小单位，则失效，指定对齐单位为1则失效，使用#pragma pack（push,1)&#x2F;ˈpræɡmə pæk pʊʃ wʌn&#x2F;）</p><p>按照声明的顺序进行内存分配；每个变量相对于起始位置的偏移量必须是该变量类型大小的整数倍，不是整数倍空出内存，直到是整数倍为止；整个结构体的大小必须是结构体中size最大的成员的整数倍</p><p>#pragma pack（push,1)：偏移量是n和当前变量大小中较小值的整数倍；整体大小是n和最大变量中较小值的整数倍；n必须为1，2，4，8……其他值就按照默认分配</p><h4 id="2、和class的区别"><a href="#2、和class的区别" class="headerlink" title="2、和class的区别"></a>2、和class的区别</h4><p>struct默认成员共有，也默认共有继承</p><h4 id="3、和C中struct的区别"><a href="#3、和C中struct的区别" class="headerlink" title="3、和C中struct的区别"></a>3、和C中struct的区别</h4><p>C中struct是自定义数据类型，没有权限设置，只能封装不能隐藏，没有成员函数，需要typedef才能不使用struct定义对象；C++中是抽象数据类型，有成员函数</p><h4 id="4、如何获得结构成员相对于结构开头的字节偏移量"><a href="#4、如何获得结构成员相对于结构开头的字节偏移量" class="headerlink" title="4、如何获得结构成员相对于结构开头的字节偏移量"></a>4、如何获得结构成员相对于结构开头的字节偏移量</h4><p>使用&lt;stddef.h&gt;中的offsetof</p><h4 id="5、结构体变量比较是否相等"><a href="#5、结构体变量比较是否相等" class="headerlink" title="5、结构体变量比较是否相等"></a>5、结构体变量比较是否相等</h4><p>重载“&#x3D;&#x3D;”：元素一个一个比</p><h3 id="（二）类"><a href="#（二）类" class="headerlink" title="（二）类"></a>（二）类</h3><h4 id="1、构造函数与析构函数"><a href="#1、构造函数与析构函数" class="headerlink" title="1、构造函数与析构函数"></a>1、构造函数与析构函数</h4><h5 id="（1）析构函数、构造函数可否抛出异常"><a href="#（1）析构函数、构造函数可否抛出异常" class="headerlink" title="（1）析构函数、构造函数可否抛出异常"></a>（1）析构函数、构造函数可否抛出异常</h5><p>构造函数可以，失败时通过异常中断构造</p><p>析构函数不可以，必须保证不泄露</p><h5 id="（2）什么时候调用构造、析构（虚构）函数"><a href="#（2）什么时候调用构造、析构（虚构）函数" class="headerlink" title="（2）什么时候调用构造、析构（虚构）函数"></a>（2）什么时候调用构造、析构（虚构）函数</h5><p>对象不存在，没有用别的对象初始化，在创建一个新对象时使用构造函数</p><p>对象生命周期结束，被销毁时；delete指向对象的指针；对象i是对象o的成员，o析构，i也析构</p><p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20250414112004448.png" alt="image-20250414112004448"></p><h5 id="（3）什么时候会自动生成默认构造函数"><a href="#（3）什么时候会自动生成默认构造函数" class="headerlink" title="（3）什么时候会自动生成默认构造函数"></a>（3）什么时候会自动生成默认构造函数</h5><p>无显式构造函数 + 所有成员可默认构造（成员对象有默认构造函数，不能有const（C++11 及以后：允许在声明时直接初始化（类内初始化），但仍需保证所有构造函数不会覆盖该初始化）、引用（必本质是别名，必须在初始化列表初始化））</p><h5 id="（4）什么情况下合成构造函数"><a href="#（4）什么情况下合成构造函数" class="headerlink" title="（4）什么情况下合成构造函数"></a>（4）什么情况下合成构造函数</h5><p>没有构造函数、有成员对象、成员对象有默认构造函数</p><p>没有构造函数、有一个有默认构造函数的基类</p><p>带有虚函数的类：虚表指针是在构造函数中初始化</p><p>带有虚基类的类</p><h5 id="（5）什么时候合成拷贝构造函数"><a href="#（5）什么时候合成拷贝构造函数" class="headerlink" title="（5）什么时候合成拷贝构造函数"></a>（5）什么时候合成拷贝构造函数</h5><p>没有拷贝构造函数、有类类型成员变量、该类有拷贝构造函数</p><p>没有拷贝构造函数、基类有拷贝构造函数</p><p>没有拷贝构造函数、声明或继承了虚函数</p><p>没有拷贝构造函数，有虚基类</p><p>有三种情况会以一个对象的内容作为另一个对象的初值：X xx&#x3D;x（初始化）；对象作为函数形参；函数传回一个类对象</p><h5 id="（6）什么是trival-destructor"><a href="#（6）什么是trival-destructor" class="headerlink" title="（6）什么是trival destructor"></a>（6）什么是trival destructor</h5><p>没有自定义析构函数，系统自动生成</p><h4 id="2、如果有一个空类，它会默认添加哪些函数"><a href="#2、如果有一个空类，它会默认添加哪些函数" class="headerlink" title="2、如果有一个空类，它会默认添加哪些函数"></a>2、如果有一个空类，它会默认添加哪些函数</h4><p>缺省构造函数；拷贝构造函数；析构函数；赋值运算符</p><h5 id="（1）如何禁止程序自动生成拷贝构造函数"><a href="#（1）如何禁止程序自动生成拷贝构造函数" class="headerlink" title="（1）如何禁止程序自动生成拷贝构造函数"></a>（1）如何禁止程序自动生成拷贝构造函数</h5><p>手动重写写为private-&gt;类的成员函数和friend函数还是可以调用private函数，如果这个函数只生命不定义会产生连接错误-&gt;可以定义一个基类，将基类的拷贝构造函数和拷贝赋值函数定义为private</p><h5 id="（2）为什么拷贝构造函数必须传引用不能传值"><a href="#（2）为什么拷贝构造函数必须传引用不能传值" class="headerlink" title="（2）为什么拷贝构造函数必须传引用不能传值"></a>（2）为什么拷贝构造函数必须传引用不能传值</h5><p>值传递：对于类类型传递时，要先调用该类的拷贝构造函数初始化形参-&gt;会一直递归</p><p>引用传递：不会调用拷贝构造函数</p><h4 id="3、初始化"><a href="#3、初始化" class="headerlink" title="3、初始化"></a>3、初始化</h4><p>explicit防止编译器进行隐式类型转换或复制初始化。它的主要作用是避免意外的隐式转换.</p><h5 id="（1）直接初始化"><a href="#（1）直接初始化" class="headerlink" title="（1）直接初始化"></a>（1）直接初始化</h5><p>直接调用与实参相符的构造函数（可能是构造函数也可能是拷贝构造函数）（（））</p><p>赋值初始化：函数体内（所有数据成员分配内存后）（赋值右侧是一个表达式（例如函数返回值或类型转换），则可能会产生临时对象，降低效率），对与类对象会比初始化列表多调用一次默认构造函数</p><p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20250315190507844.png" alt="image-20250315190507844"></p><p>列表初始化：初始化列表（分配内存时，函数体未执行），只进行一次赋值</p><h6 id="①必须成员列表初始化"><a href="#①必须成员列表初始化" class="headerlink" title="①必须成员列表初始化"></a>①必须成员列表初始化</h6><p>引用、常量、调用基类构造函数，而他有参数、调用成员类构造函数，而他有参数。</p><h6 id="②成员初始化列表做了什么"><a href="#②成员初始化列表做了什么" class="headerlink" title="②成员初始化列表做了什么"></a>②成员初始化列表做了什么</h6><p>编译器会一一操作初始化列表（在类中成员的声明顺序），在任何显式用户代码之前执行。</p><h5 id="（2）拷贝初始化"><a href="#（2）拷贝初始化" class="headerlink" title="（2）拷贝初始化"></a>（2）拷贝初始化</h5><p>先创建一个临时对象（可以跳过），再调用拷贝构造函数进行初始化（&#x3D;）</p><h5 id="（3）和赋值的区别"><a href="#（3）和赋值的区别" class="headerlink" title="（3）和赋值的区别"></a>（3）和赋值的区别</h5><p> 在复杂的变量类型中，赋值是调用重载的&#x3D;号</p><h5 id="（4）构造函数"><a href="#（4）构造函数" class="headerlink" title="（4）构造函数"></a>（4）构造函数</h5><p><u>①默认</u></p><p><u>②初始化（有参数和参数列表）</u></p><p><u>③拷贝</u></p><p>什么时候会调用拷贝函数？</p><p>用一个实例去初始化另一个（&#x3D;）；函数的参数是类的对象（非引用传递）；返回值是类对象（A&amp;fun() ；没有形参-&gt;值；有形参-&gt;引用）</p><p>深层复制</p><p>参数是左值引用</p><p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20250313165628205.png" alt="image-20250313165628205"></p><p><u>④移动（move和右值引用）</u></p><p>将原来指针置空，防止析构函数回收空间</p><p>对于指针使用浅层复制</p><p>参数是右值引用或将亡值引用，move语句将左值变为将亡值</p><p><u>⑤转换</u></p><p>只有一个形参且该形参不是该类对象</p><h5 id="（5）构造函数、拷贝构造函数、赋值操作符的区别"><a href="#（5）构造函数、拷贝构造函数、赋值操作符的区别" class="headerlink" title="（5）构造函数、拷贝构造函数、赋值操作符的区别"></a>（5）构造函数、拷贝构造函数、赋值操作符的区别</h5><p>构造函数：对象不存在，没有用别的对象初始化，在创建一个新对象时使用构造函数</p><p>拷贝构造函数：对象不存在，用别的对象初始化，会生成新的类对象</p><p>赋值操作符：对象存在，用别的对象给它赋值，属于重载“&#x3D;”，两侧都是已经存在的对象。果原来有内存分配需要先释放，需要检查对象是否相同，分配新资源，返回引用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">student s1=s;<span class="comment">//拷贝</span></span><br><span class="line"></span><br><span class="line">s1=s;<span class="comment">//赋值</span></span><br></pre></td></tr></table></figure><h5 id="（6）代码"><a href="#（6）代码" class="headerlink" title="（6）代码"></a>（6）代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span>* data;<span class="comment">//深拷贝和浅拷贝不同</span></span><br><span class="line"><span class="type">int</span> size = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="type">int</span> b;</span><br><span class="line"><span class="built_in">MyClass</span>():<span class="built_in">a</span>(<span class="number">0</span>),<span class="built_in">b</span>(<span class="number">0</span>),<span class="built_in">data</span>(<span class="literal">nullptr</span>),<span class="built_in">size</span>(<span class="number">0</span>)&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;默认构造&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">MyClass</span>(<span class="type">int</span> _a,<span class="type">int</span> _b,<span class="type">int</span> _size):<span class="built_in">a</span>(_a),<span class="built_in">b</span>(_b),<span class="built_in">size</span>(_size)&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;带参数的构造函数&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">data = <span class="keyword">new</span> <span class="type">int</span>[size];<span class="comment">//为什么不是(size),vector是使用()吗</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; size;i++) &#123;</span><br><span class="line">data[i] = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">data = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//深拷贝和浅拷贝，需要new吗</span></span><br><span class="line"><span class="comment">/*MyClass(const MyClass&amp; other) :a(other.a), b(other.b),size(other.size),data(other.data) &#123;</span></span><br><span class="line"><span class="comment">cout &lt;&lt; &quot;浅拷贝构造函数&quot;&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="built_in">MyClass</span>(<span class="type">const</span> MyClass&amp; other) :<span class="built_in">a</span>(other.a), <span class="built_in">b</span>(other.b), <span class="built_in">size</span>(other.size) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;深拷贝构造函数&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">if</span> (other.data != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">data = <span class="keyword">new</span> <span class="type">int</span>[size];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; size;++i) &#123;</span><br><span class="line">data[i] = other.data[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">data = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//赋值不是构造</span></span><br><span class="line">MyClass&amp; <span class="keyword">operator</span>=(<span class="type">const</span> MyClass&amp; other) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123;</span><br><span class="line"><span class="keyword">delete</span>[]data;</span><br><span class="line">a = other.a;</span><br><span class="line">b = other.b;</span><br><span class="line">size = other.size;</span><br><span class="line"><span class="keyword">if</span> (other.data != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">data = <span class="keyword">new</span> <span class="type">int</span>[size];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; size;++i) &#123;</span><br><span class="line">data[i] = other.data[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">data = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;赋值&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//移动</span></span><br><span class="line"><span class="comment">//noexcept告诉编译器这个函数不会抛出异常，有助于优化</span></span><br><span class="line"><span class="built_in">MyClass</span>(MyClass&amp;&amp;other)<span class="keyword">noexcept</span>:<span class="built_in">a</span>(other.a),<span class="built_in">b</span>(other.b),<span class="built_in">data</span>(other.data),<span class="built_in">size</span>(other.size)&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;移动构造函数&quot;</span>&lt;&lt;endl;</span><br><span class="line">other.data = <span class="literal">nullptr</span>;</span><br><span class="line">other.size = <span class="number">0</span>;</span><br><span class="line">other.a = <span class="number">0</span>;</span><br><span class="line">other.b = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">MyClass&amp; <span class="keyword">operator</span>=(MyClass&amp;&amp; other)<span class="keyword">noexcept</span> &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;移动赋值函数&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123;</span><br><span class="line"><span class="keyword">delete</span>[]data;</span><br><span class="line">a = other.a;</span><br><span class="line">b = other.b;</span><br><span class="line">data = other.data;</span><br><span class="line">size = other.size;</span><br><span class="line">other.data = <span class="literal">nullptr</span>;</span><br><span class="line">other.size = <span class="number">0</span>;</span><br><span class="line">a = <span class="number">0</span>;</span><br><span class="line">b = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//显示</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a=&quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;b=&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;size=&quot;</span> &lt;&lt; size &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;data:&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; size;++i) &#123;</span><br><span class="line">cout &lt;&lt; data[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//析构</span></span><br><span class="line">~<span class="built_in">MyClass</span>() &#123;</span><br><span class="line"><span class="keyword">delete</span>[]data;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;析构函数&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">MyClass <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">MyClass</span>(<span class="number">100</span>, <span class="number">200</span>, <span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun1</span><span class="params">(MyClass a)</span> </span>&#123;</span><br><span class="line">a.<span class="built_in">display</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun2</span><span class="params">(MyClass&amp;a)</span> </span>&#123;</span><br><span class="line">a.<span class="built_in">display</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//默认构造</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;=========================================obj1:&quot;</span> &lt;&lt; endl;</span><br><span class="line">MyClass obj1;</span><br><span class="line">obj<span class="number">1.</span><span class="built_in">display</span>();</span><br><span class="line"><span class="comment">//带参构造</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;=========================================obj2:&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="function">MyClass <span class="title">obj2</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span></span>;</span><br><span class="line">obj<span class="number">2.</span><span class="built_in">display</span>();</span><br><span class="line"><span class="comment">//浅拷贝构造</span></span><br><span class="line"><span class="comment">//深拷贝构造</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;=========================================obj3:&quot;</span> &lt;&lt; endl;</span><br><span class="line">MyClass obj3 = obj3;</span><br><span class="line">obj<span class="number">3.</span><span class="built_in">display</span>();</span><br><span class="line"><span class="comment">//移动构造</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;=========================================obj4:&quot;</span> &lt;&lt; endl;</span><br><span class="line">MyClass obj4 = <span class="built_in">create</span>();</span><br><span class="line">obj<span class="number">4.</span><span class="built_in">display</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;=========================================obj4_2:&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="function">MyClass <span class="title">obj4_2</span><span class="params">(std::move(obj4))</span></span>;</span><br><span class="line">obj4_<span class="number">2.</span><span class="built_in">display</span>();</span><br><span class="line"><span class="comment">//赋值</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;=========================================obj5:&quot;</span> &lt;&lt; endl;</span><br><span class="line">MyClass obj5;</span><br><span class="line">obj5 = obj4_2;</span><br><span class="line">obj<span class="number">5.</span><span class="built_in">display</span>();</span><br><span class="line"><span class="comment">//移动赋值</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;=========================================obj6:&quot;</span> &lt;&lt; endl;</span><br><span class="line">MyClass obj6;</span><br><span class="line">obj6 = std::<span class="built_in">move</span>(obj5);</span><br><span class="line">obj<span class="number">6.</span><span class="built_in">display</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;=========================================fun1:&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="built_in">fun1</span>(obj1);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;=========================================fun2:&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="built_in">fun2</span>(obj1);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;析构&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h4 id="4、C-的抽象类"><a href="#4、C-的抽象类" class="headerlink" title="4、C++的抽象类"></a>4、C++的抽象类</h4><p>含有没有定义的纯虚函数，所以不能实例化</p><h5 id="（1）纯虚函数与虚函数的区别"><a href="#（1）纯虚函数与虚函数的区别" class="headerlink" title="（1）纯虚函数与虚函数的区别"></a>（1）纯虚函数与虚函数的区别</h5><p>没有函数体，函数指针会被存在虚函数表中，值为0（虚函数是函数的具体地址）</p><h5 id="（2）作用"><a href="#（2）作用" class="headerlink" title="（2）作用"></a>（2）作用</h5><p>避免直接实例化无意义的基类</p><p>实现多态，提供代码的共享实现</p><p>解耦设计（耦（Coupling）：指模块&#x2F;组件间的依赖关系和关联程度；）</p><p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20250411150841700.png" alt="image-20250411150841700"></p><p>模板方法模式：定义算法框架</p><p>定义接口规范</p><h3 id="（四）指针和引用"><a href="#（四）指针和引用" class="headerlink" title="（四）指针和引用"></a>（四）指针和引用</h3><p>指针是一个变量，存储的是地址，引用是一个变量的别名，没有分配空间（看编译器）；指针可以先定义后初始化，且可以为NULL、可以改变，引用不可以；在作为参数传递，改变指针的指向不会改变实参，通过解引用可以改变实参；指针可以多级，引用不可以</p><h4 id="1、-在传递参数时，什么时候使用指针，什么时候使用引用"><a href="#1、-在传递参数时，什么时候使用指针，什么时候使用引用" class="headerlink" title="1、 在传递参数时，什么时候使用指针，什么时候使用引用"></a>1、 在传递参数时，什么时候使用指针，什么时候使用引用</h4><p>当需要返回函数内部变量时使用指针；当是类对象时使用引用，这是C++对象传递的标准方式；当对栈空间敏感时使用引用（例如递归），因为引用不需要创建临时变量，所以开销更小；当需要改变实参时使用引用</p><h5 id="（1）值传递、指针传递、引用传递"><a href="#（1）值传递、指针传递、引用传递" class="headerlink" title="（1）值传递、指针传递、引用传递"></a>（1）值传递、指针传递、引用传递</h5><p>值传递：传值（大型数据消耗大）；有一个形参向函数栈拷贝数据的过程</p><p>指针传递：传值，地址值（需要通过指针间接访问数据）；有一个形参向函数栈拷贝数据的过程</p><p>引用传递：传地址（间接寻址）；存在数据拷贝过程，但是是针对地址的，为该数据的地址起了别名</p><p>指针传递、引用传递效率比值传递高；从编译角度上来讲，符号表记录变量名称和地址，指针变量在符号表中的值是指针地址，而引用在符号表中的值是引用对象的地址，符号表不可更改</p><h6 id="①引用传递好处"><a href="#①引用传递好处" class="headerlink" title="①引用传递好处"></a>①引用传递好处</h6><p>可以对实参进行修改；提高了函数调用和运行的效率（没有了传值和生成副本的时间和消耗）；</p><p>引用传递返回值：在内存中不产生被返回值的副本</p><p>引用传递返回的限制：不能返回局部变量的引用；不能返回函数内部new分配的内存的引用；可以返回类成员的引用，但是最好是const</p><h4 id="2、指针"><a href="#2、指针" class="headerlink" title="2、指针"></a>2、指针</h4><h5 id="（1）区别指针"><a href="#（1）区别指针" class="headerlink" title="（1）区别指针"></a>（1）区别指针</h5><p>用括号括起来的是单个指针</p><p>int *p[10]指针数组：数组内每个元素都是指针（sizeof(p)&#x3D;10 *sizeof(int *)&#x3D;10 *4&#x2F;8）</p><p>int （*p)[10]数组指针：指向一个数组的一个指针（sizeof(int *)）</p><p>int *p（int)函数：返回值是指针</p><p>int （*p)（int)函数指针：指向一个带有int参数、返回值为int的函数</p><p>指针的字节大小和机器位数有关，32位则4字节， 64位8字节</p><h6 id="①函数指针"><a href="#①函数指针" class="headerlink" title="①函数指针"></a>①函数指针</h6><p>函数的类型由返回值和它的参数决定，与它的名称无关，必须有括号(*p)</p><p>一个函数名就是一个指针，指向函数的代码。函数调用可以通过函数名，也可以通过指向函数的指针来调用。函数指针还允许将函数作为变元传递给其他函数</p><p>两种赋值方式：指针名&#x3D;函数名；指针名&#x3D;&amp;函数名</p><h6 id="②为什么有函数指针"><a href="#②为什么有函数指针" class="headerlink" title="②为什么有函数指针"></a>②为什么有函数指针</h6><p>函数与数据类似，也有自己的地址，我们行为在同一个函数中通过使用相同的形参在不同的时间产生不同的效果。</p><h5 id="（2）指针所占的字节数"><a href="#（2）指针所占的字节数" class="headerlink" title="（2）指针所占的字节数"></a>（2）指针所占的字节数</h5><p>32位编译器则4字节，64位编译器则8字节</p><h5 id="（3）指针常量和常量指针"><a href="#（3）指针常量和常量指针" class="headerlink" title="（3）指针常量和常量指针"></a>（3）指针常量和常量指针</h5><p>指针常量int *const p本身是常量</p><p>常量指针const int *p（int const *p)指向常量</p><h5 id="（4）a和-a的区别"><a href="#（4）a和-a的区别" class="headerlink" title="（4）a和&amp;a的区别"></a>（4）a和&amp;a的区别</h5><p>int a[10]和int （*p)[10]&#x3D;&amp;a（数组名和指针（指向数组首元素的指针），sizeof(a)&#x3D;10 *sizeof(int)，sizeof(int)与机器位数无关&#x3D;4）</p><p>a的数组名，是数组首元素地址，a+1则是在地址上加一个int（4字节)，*（a+1)&#x3D;a[1]</p><p>&amp;a是数组指针，+1是加整个数组长度（4*10个字节)，指向数组之后的第一个元素</p><h6 id="①数组名和指针（指向数组首元素的指针）"><a href="#①数组名和指针（指向数组首元素的指针）" class="headerlink" title="①数组名和指针（指向数组首元素的指针）"></a>①数组名和指针（指向数组首元素的指针）</h6><p>二者均可以通过偏移量进行元素访问；但是数组名是常量指针，不能进行自加、自减；当数组名作为形参传递给函数时，就变成指针了，可以自加，但是不能通过sizeof计算数组大小了</p><h6 id="②指针加减"><a href="#②指针加减" class="headerlink" title="②指针加减"></a>②指针加减</h6><p>指针每移动一位，实际跨越的内存间隔是指针类型的长度</p><p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20250315215049323.png" alt="image-20250315215049323"></p><h5 id="（5）悬空指针和野指针"><a href="#（5）悬空指针和野指针" class="headerlink" title="（5）悬空指针和野指针"></a>（5）悬空指针和野指针</h5><p>悬空指针：指向的内存被释放（引入智能指针）</p><p>野指针：没有及时初始化</p><h5 id="（6）智能指针"><a href="#（6）智能指针" class="headerlink" title="（6）智能指针"></a>（6）智能指针</h5><p>share_ptr：引用计数</p><p>unique_ptr：对象的独占所有权</p><p>weak_ptr：观察share_ptr管理的资源，但是不会增加引用计数</p><p>问题</p><p>shared_ptr会相互引用，导致引用计数无法归零，内存无法释放；使用weak_ptr打破循环引用</p><p>需要维护引用计数，存在额外的性能开销；不需要共享所有权时优先使用unique_ptr</p><p>share_ptr的引用计数是线程安全的，但指向的对象不是；使用互斥锁保护共享资源</p><h6 id="①线程安全"><a href="#①线程安全" class="headerlink" title="①线程安全"></a>①线程安全</h6><p>正确安全地进行多线程访问，无序额外的同步机制</p><p>互斥锁；原子操作；线程局部存储；使用不可变对象；实现线程安全的数据结构</p><h4 id="3、引用"><a href="#3、引用" class="headerlink" title="3、引用"></a>3、引用</h4><h5 id="（1）从汇编层解释引用"><a href="#（1）从汇编层解释引用" class="headerlink" title="（1）从汇编层解释引用"></a>（1）从汇编层解释引用</h5><p>本质是常量指针，通过内存地址访问数据。引用是将x的值加载到寄存器，而指针是将x的地址脚趾到寄存器</p><h4 id="4、深拷贝和浅拷贝"><a href="#4、深拷贝和浅拷贝" class="headerlink" title="4、深拷贝和浅拷贝"></a>4、深拷贝和浅拷贝</h4><p>指针变量本身是需要分配内存的，但指针所指向的内存（即指针存储的地址对应的内存）是否需要分配，取决于具体的用法和上下文。</p><h5 id="（1）深拷贝"><a href="#（1）深拷贝" class="headerlink" title="（1）深拷贝"></a>（1）深拷贝</h5><p>不仅拷贝值，还开辟一块新的空间存放新的值</p><h5 id="（2）浅拷贝"><a href="#（2）浅拷贝" class="headerlink" title="（2）浅拷贝"></a>（2）浅拷贝</h5><p>只是拷贝了一个指针，没有开辟新的地址，与原来指针指向同一个地址；原来内存释放会导致悬空指针</p><h2 id="二、分类2"><a href="#二、分类2" class="headerlink" title="二、分类2"></a>二、分类2</h2><h3 id="全局变量和局部变量的区别"><a href="#全局变量和局部变量的区别" class="headerlink" title="全局变量和局部变量的区别"></a>全局变量和局部变量的区别</h3><p>生命周期不同</p><p>使用方式不同：各个部分都可以使用；局部使用</p><p>存储位置不同（操作系统和编译器如何区分两者）：全局数据段，在程序开始时被加载；堆栈</p><h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><h3 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h3><h3 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h3>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 变量类型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++数据结构(五)：关键字</title>
      <link href="/my_tech_blog.github.io/2025/11/09/C++%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_5/"/>
      <url>/my_tech_blog.github.io/2025/11/09/C++%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_5/</url>
      
        <content type="html"><![CDATA[<h1 id="C-数据结构（五）：关键字"><a href="#C-数据结构（五）：关键字" class="headerlink" title="C++数据结构（五）：关键字"></a>C++数据结构（五）：关键字</h1><p>static和const；override和final；extern；public&#x2F;private&#x2F;protect；volatile&#x2F;mutable&#x2F;explicit</p><h2 id="一、static"><a href="#一、static" class="headerlink" title="一、static"></a>一、static</h2><p>所有对象共有的；可以直接使用类名调用；在对象构建之前，与类（类变量，普通称为实例变量）一起构建，仅在类加载时执行；生命周期与类相同（普通成员变量与对象相同）；地址在方法区的静态区（普通在堆内存的对象中，是对象的特有数据）；（静态方法只能访问静态变量，静态函数中没有this，main函数是静态的）</p><p>不考虑类：隐藏，不加的全局变量具有全局可见性，但是加了之后就只能在当前文件中使用；初始化为0；保持变量持久，生命周期和程序相同，函数中的静态变量始终存在且只进行一次初始化，但是退出函数后就不能使用了</p><p>考虑类：</p><p>成员变量：只与类关联，不于对象关联，只有一份拷贝；先于对象存在，必须在类外初始化，初始化可以不加static关键字；可以被非static成员函数访问</p><p>成员函数：没有this指针；只能访问静态成员；不能被声明为const、虚函数、volatile(不能被编译器优化，可以被编译器未知因素更改，确保每次访问都从内存中读取最新的值)；可以被非静态成员访问</p><h3 id="1、与全局变量区别"><a href="#1、与全局变量区别" class="headerlink" title="1、与全局变量区别"></a>1、与全局变量区别</h3><p>存储方式相同，都是静态存储；</p><p>作用域是整个源程序</p><h3 id="2、与普通函数区别"><a href="#2、与普通函数区别" class="headerlink" title="2、与普通函数区别"></a>2、与普通函数区别</h3><p>作用域不同，在内存中只有一份</p><h3 id="3、与普通成员区别"><a href="#3、与普通成员区别" class="headerlink" title="3、与普通成员区别"></a>3、与普通成员区别</h3><p>生命周期；共享方式；定义位置（普通位于堆栈，static在静态全局区）初始化位置；默认实参（可以使用静态成员作为默认实参）</p><h2 id="二、const"><a href="#二、const" class="headerlink" title="二、const"></a>二、const</h2><h3 id="1、关键字的特点"><a href="#1、关键字的特点" class="headerlink" title="1、关键字的特点"></a>1、关键字的特点</h3><p>不考虑类：隐藏；必须在定义时初始化，之后不可更改；const形参可以接收const或非const的实参；当指针传递、引用传递，可以使用const保护实参</p><p>考虑类：</p><p>成员变量：必须在构造函数初始化列表进行初始化；</p><p>成员函数：const对象不可以调用非const成员函数；可以被非const对象调用；不不可以改变被mutable修饰之外的变量；有时候返回值需为const类型，以使其返回值不为左值（放止对返回值修改）</p><h3 id="2、底层const与顶层const"><a href="#2、底层const与顶层const" class="headerlink" title="2、底层const与顶层const"></a>2、底层const与顶层const</h3><p>顶层const：本身是常量（指针常量）</p><p>底层const：指向常量（常量指针）</p><p>（底层const不能赋值给非底层const，const_cast只能修改(移除)底层const）</p><h2 id="三、override"><a href="#三、override" class="headerlink" title="三、override"></a>三、override</h2><p>该函数重写的父类虚函数</p><h2 id="四、final"><a href="#四、final" class="headerlink" title="四、final"></a>四、final</h2><p>不希望某个类被继承或者不希望某个虚函数被重写</p><h2 id="五、extern"><a href="#五、extern" class="headerlink" title="五、extern"></a>五、extern</h2><p>声明，表示定义在其它文件中</p><p>在C++中调用C的语言代码，extern”C”{}</p><h3 id="1、定义和声明"><a href="#1、定义和声明" class="headerlink" title="1、定义和声明"></a>1、定义和声明</h3><h4 id="（1）变量定义和声明"><a href="#（1）变量定义和声明" class="headerlink" title="（1）变量定义和声明"></a>（1）变量定义和声明</h4><p>extern是显式声明，只是告诉编译器变量声明的位置和类型，并不分配内存空间，可以多次声明；</p><p>不加extern（如int x;）是定义，分配内存，仅能定义一次</p><h4 id="（2）函数的定义和声明"><a href="#（2）函数的定义和声明" class="headerlink" title="（2）函数的定义和声明"></a>（2）函数的定义和声明</h4><p>声明：一般在头文件里，向编译器说明函数存在</p><p>定义：源文件，函数体</p><h2 id="六、public-private-protect"><a href="#六、public-private-protect" class="headerlink" title="六、public&#x2F;private&#x2F;protect"></a>六、public&#x2F;private&#x2F;protect</h2><p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20250313154926360.png" alt="image-20250313154926360"></p><p>内部访问：派生类中成员函数对基类进行访问</p><p>外部访问：派生类外（private继承，派生类的派生类无法访问基类的任何成员）</p><h2 id="七、volatile"><a href="#七、volatile" class="headerlink" title="七、volatile"></a>七、volatile</h2><p>允许变量被某些编译器未知的因素更改，不能被编译器优化，每次都从内存（寄存器×）中读取最新的结果</p><p>易变的变量，多线程中共同使用的变量；中断程序中对修改供其它程序检测的变量；存储器映射的硬件寄存器（每次对它的读写可能都有不同意义）</p><p>如果一个类对象被修饰，只能调用其中被修饰的成员函数；如果一个类对象被声明为 ，则它的成员变量也会被视为；可以用const_cast移除</p><h2 id="八、mutable"><a href="#八、mutable" class="headerlink" title="八、mutable"></a>八、mutable</h2><p>在const中可以修改的</p><h2 id="九、explic"><a href="#九、explic" class="headerlink" title="九、explic"></a>九、explic</h2><p>不能隐式类型转换</p><h2 id="十、宏定义"><a href="#十、宏定义" class="headerlink" title="十、宏定义"></a>十、宏定义</h2><p>定义常量及书写复杂的内容，不分配内存，但是直接替换会生成多个备份</p><h3 id="1、和函数有什么区别"><a href="#1、和函数有什么区别" class="headerlink" title="1、和函数有什么区别"></a>1、和函数有什么区别</h3><p>宏定义是在预处理阶段进行处理（文本替换），结尾没有分号，没有返回值、类型；函数在编译阶段被编译为汇编代码，再通过汇编阶段转换为机器指令，运行时需要跳转到具体函数，函数声明需要加分号。占用代码段空间，可以通过undef取消定义然后进行重定义，只要是之前预定义的宏，在以后的程序中都可以使用</p><h3 id="2、和typedef有什么区别"><a href="#2、和typedef有什么区别" class="headerlink" title="2、和typedef有什么区别"></a>2、和typedef有什么区别</h3><p>（typedef可以修饰struct，C中创建对象就不需要写struct了，C++本来就不用）</p><p>typedef对类型进行重命名，需要进行类型检查，是语句末尾要加分号，在编译的一部分，在编译时有效，有作用域</p><h3 id="3、和const的区别"><a href="#3、和const的区别" class="headerlink" title="3、和const的区别"></a>3、和const的区别</h3><p>const进行类型计算，在编译和运行时起作用，需要分配内存，可以进行常量折叠，占用数据段空间，不能重定义</p><h3 id="4、online内联函数区别"><a href="#4、online内联函数区别" class="headerlink" title="4、online内联函数区别"></a>4、online内联函数区别</h3><p>在编译时进行参数类型检查（直接将函数代码嵌入到目标代码），有返回值，可以重载，没有歧义</p><p>作为类的接口函数读写私有成员和保护成员可以提高效率（内联函数的主要目的是减少函数调用的开销）</p><h4 id="（1）为什么不把所有函数写成内联函数"><a href="#（1）为什么不把所有函数写成内联函数" class="headerlink" title="（1）为什么不把所有函数写成内联函数"></a>（1）为什么不把所有函数写成内联函数</h4><p>函数体内代码长，内存消耗大；体内有循环，函数执行时间比函数调用大</p><h4 id="（2）构造函数、析构函数、虚函数是否可以声明为内联函数"><a href="#（2）构造函数、析构函数、虚函数是否可以声明为内联函数" class="headerlink" title="（2）构造函数、析构函数、虚函数是否可以声明为内联函数"></a>（2）构造函数、析构函数、虚函数是否可以声明为内联函数</h4><p>理论上可以</p><p>构造函数和析构函数声明为内联函数是没有意义的（包含隐式操作编译器会忽略）</p><p>当指向派生类的指针调用内联虚函数不会展开（动态绑定），对象本身调用虚函数可能会内联展开（无动态需求）</p><h3 id="5、ifdef和endif"><a href="#5、ifdef和endif" class="headerlink" title="5、ifdef和endif"></a>5、ifdef和endif</h3><p>条件编译；防止多次包含头文件的“重定义”问题</p><h2 id="十一、构造函数的几种关键字"><a href="#十一、构造函数的几种关键字" class="headerlink" title="十一、构造函数的几种关键字"></a>十一、构造函数的几种关键字</h2><p>default：显式要求编译器生成合成构造函数，防止在调用时相关构造函数类型没有定义</p><p>delete：可以删除构造函数、赋值运算符等</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 关键字 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++数据结构(四)：从代码到程序</title>
      <link href="/my_tech_blog.github.io/2025/11/09/C++%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_4/"/>
      <url>/my_tech_blog.github.io/2025/11/09/C++%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_4/</url>
      
        <content type="html"><![CDATA[<h1 id="C-数据结构（四）：从代码到程序"><a href="#C-数据结构（四）：从代码到程序" class="headerlink" title="C++数据结构（四）：从代码到程序"></a>C++数据结构（四）：从代码到程序</h1><h2 id="一、C-从代码到可执行程序经历了什么"><a href="#一、C-从代码到可执行程序经历了什么" class="headerlink" title="一、C++从代码到可执行程序经历了什么"></a>一、C++从代码到可执行程序经历了什么</h2><h3 id="1、预处理-预编译"><a href="#1、预处理-预编译" class="headerlink" title="1、预处理&#x2F;预编译"></a>1、预处理&#x2F;预编译</h3><p>处理宏定义、预编译指令（头文件的包含是递归的）、保留编译器指令，添加行号和文件标识、删除所有注释</p><p>生成.i、.ii</p><h3 id="2、编译"><a href="#2、编译" class="headerlink" title="2、编译"></a>2、编译</h3><p>词法分析、语法分析、语义分析、优化、目标代码生成、目标代码分析</p><p>生成汇编代码文件.s</p><h3 id="3、汇编"><a href="#3、汇编" class="headerlink" title="3、汇编"></a>3、汇编</h3><p>变为机器码文件.o、.obj（可重定位目标文件，并不是可执行文件，可执行文件在链接后生成）</p><h6 id="可重定位目标文件"><a href="#可重定位目标文件" class="headerlink" title="可重定位目标文件"></a>可重定位目标文件</h6><p>可重定位目标文件是链接过程的输入</p><p>可与其它可重定位目标文件链接，创建一个可执行目标文件</p><h3 id="4、链接"><a href="#4、链接" class="headerlink" title="4、链接"></a>4、链接</h3><p>将不同源文件生成的目标文件进行链接，生成可以执行的程序</p><p>可以通过检查依赖项或者查看文件大小，静态无依赖且文件较大</p><h4 id="（1）静态链接（-a-lib）"><a href="#（1）静态链接（-a-lib）" class="headerlink" title="（1）静态链接（.a&#x2F;.lib）"></a>（1）静态链接（.a&#x2F;.lib）</h4><p>在形成进行可执行程序时链接，以目标文件为单位</p><p>在编译链接可执行文件时，将程序运行所需要的所有目标文件（如库直接插入到代码）链接</p><p>缺点：（空间浪费）内存消耗大，可能存在多个副本；（更新困难）当代码库文件修改了，需要重新编译链接形成可执行文件</p><p>优点：运行速度快</p><p>用途：完全独立运行</p><h4 id="（2）动态链接（-so-dll）"><a href="#（2）动态链接（-so-dll）" class="headerlink" title="（2）动态链接（.so&#x2F;.dll）"></a>（2）动态链接（.so&#x2F;.dll）</h4><p>在生成可执行程序时链接，在运行时由动态链接器加载所需动态库到内存</p><p>把程序按照模块进行拆分，在程序运行时才将它们进行链接</p><p>优点：共享库，不会存在多个副本；更新方便：只需要替换原来的目标文件</p><p>缺点：性能有损失；如果转发需要携带动态链接库，没有运行库无法运行</p><p>用途：灵活升级功能、依赖系统通用库、多个程序共享一库</p><p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20250318215856125.png" alt="image-20250318215856125"></p><h3 id="5、程序"><a href="#5、程序" class="headerlink" title="5、程序"></a>5、程序</h3><h4 id="（1）可执行目标文件"><a href="#（1）可执行目标文件" class="headerlink" title="（1）可执行目标文件"></a>（1）可执行目标文件</h4><p>可以直接在内存中执行</p><ul><li><strong>Windows</strong>：<strong>严重依赖文件后缀名</strong>来判断一个文件是否为可执行文件。(.exe)</li><li><strong>Linux</strong>：<strong>不依赖文件后缀名</strong>，而是通过文件的<strong>权限属性</strong>来判断。(<strong>ELF</strong>：这是现代 Linux 系统中最主流的可执行文件格式；可执行的Shell脚本)</li></ul><h4 id="（2）共享目标文件（动态链接库-so、-dll）"><a href="#（2）共享目标文件（动态链接库-so、-dll）" class="headerlink" title="（2）共享目标文件（动态链接库.so、.dll）"></a>（2）共享目标文件（动态链接库.so、.dll）</h4><p>特殊可重定位目标文件，客栈运行时被动态加载进内存并链接</p><h3 id="6、运行"><a href="#6、运行" class="headerlink" title="6、运行"></a>6、运行</h3><p>操作系统将可执行文件加载到内存并运行</p><h3 id="7、问题"><a href="#7、问题" class="headerlink" title="7、问题"></a>7、问题</h3><h4 id="（1）将字符串“hello-world”从开始到打印到屏幕的全过程"><a href="#（1）将字符串“hello-world”从开始到打印到屏幕的全过程" class="headerlink" title="（1）将字符串“hello world”从开始到打印到屏幕的全过程"></a>（1）将字符串“hello world”从开始到打印到屏幕的全过程</h4><p>用户告诉操作系统需要运行程序-&gt;操作系统：查看程序是否是可执行文件；读取程首部信息，得到程序的数据和代码在可执行文件中位置并计算出对应磁盘块地址-&gt;操作系统：新建进程，将可执行文件映射到进程-&gt;操作系统：设置cpu上下文环境，跳到程序开始-&gt;执行第一条指令，缺页异常-&gt;操作系统分配物理页，将代码从磁盘读到内存，继续执行-&gt;执行puts函数（系统调用），在显示器显示字符串-&gt;操作系统：找到要进行显示的设备，将字符串传给负责该设备的进程-&gt;操作系统：进程告诉设备的系统窗口，要显示字符串，系统窗口检查这是一个合法操作，将字符串转化为像素，将像素写入设备的存储映像区-&gt;视频硬件将像素转换成显示器可接受和一组数据控制数据信号-&gt;显示器解释信号，激发液晶屏-&gt;看到</p><h4 id="（2）什么在编译时得到，什么在运行时得到"><a href="#（2）什么在编译时得到，什么在运行时得到" class="headerlink" title="（2）什么在编译时得到，什么在运行时得到"></a>（2）什么在编译时得到，什么在运行时得到</h4><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20250313113640796.png" alt="image-20250313113640796" style="zoom:50%;" /><h2 id="二、main"><a href="#二、main" class="headerlink" title="二、main"></a>二、main</h2><h3 id="1、什么操作在main函数之前、之后进行"><a href="#1、什么操作在main函数之前、之后进行" class="headerlink" title="1、什么操作在main函数之前、之后进行"></a>1、什么操作在main函数之前、之后进行</h3><p>宏定义包含在预处理阶段（宏、头文件包含（#include）、条件编译（#ifdef）），不在程序运行的编译阶段</p><h4 id="（1）前"><a href="#（1）前" class="headerlink" title="（1）前"></a>（1）前</h4><p>栈指针、类、全局变量（全局变量、静态全局变量、全局对象的构造函数；加载初始值.data和初始化.bss）、main的参数（argv、argc）的传递会在main函数之前进行；静态变量分配内存</p><h4 id="（2）后"><a href="#（2）后" class="headerlink" title="（2）后"></a>（2）后</h4><p>全局对象的析构函数会在main函数之后进行</p><h4 id="（3）问题"><a href="#（3）问题" class="headerlink" title="（3）问题"></a>（3）问题</h4><h5 id="①在main函数中定义static变量，是先运行main函数还是先初始化static变量"><a href="#①在main函数中定义static变量，是先运行main函数还是先初始化static变量" class="headerlink" title="①在main函数中定义static变量，是先运行main函数还是先初始化static变量"></a>①在main函数中定义static变量，是先运行main函数还是先初始化static变量</h5><p>如果是类的static成员或在main函数前定义的（全局静态变量），是在main函数执行前完成；但是如果是在main函数中定义的static（局部静态变量）对象，会先进入main再进行初始化，但是在程序启动时（main函数执行之前，运行时）分配内存（静态存储区）。</p><h3 id="2、程序在执行int-main-int-argc-char-argv-时的内存结构"><a href="#2、程序在执行int-main-int-argc-char-argv-时的内存结构" class="headerlink" title="2、程序在执行int main(int argc,char*argv[])时的内存结构"></a>2、程序在执行int main(int argc,char*argv[])时的内存结构</h3><p>程序在命令下运行时，需要输入argc个参数，每个参数都是以char类型输入的，依次存储在数组argv[]中，第一个参数为程序的名称</p><h3 id="3、main函数的返回值"><a href="#3、main函数的返回值" class="headerlink" title="3、main函数的返回值"></a>3、main函数的返回值</h3><p>必须是int才能传递给程序激活值（如操作系统）表示程序正常退出</p><h4 id="（1）非main函数将临时变量作为返回值"><a href="#（1）非main函数将临时变量作为返回值" class="headerlink" title="（1）非main函数将临时变量作为返回值"></a>（1）非main函数将临时变量作为返回值</h4><p>当函数退出，临时变量出栈被销毁，但是返回值被临时存储到寄存器中与临时变量的生命周期没有关系</p><h2 id="三、压栈"><a href="#三、压栈" class="headerlink" title="三、压栈"></a>三、压栈</h2><h3 id="1、C-函数调用的压栈过程"><a href="#1、C-函数调用的压栈过程" class="headerlink" title="1、C++函数调用的压栈过程"></a>1、C++函数调用的压栈过程</h3><h4 id="（1）根据程序main调用fun运行print-f-f"><a href="#（1）根据程序main调用fun运行print-f-f" class="headerlink" title="（1）根据程序main调用fun运行print(f(),f())"></a>（1）根据程序main调用fun运行print(f(),f())</h4><p>从main开始执行-&gt;编译器将操作系统的运行状态、main函数的返回地址、main函数的参数、main函数的变量（先定义先入栈）进行依次压栈；</p><p>调用fun函数-&gt;fun的参数（从右往左）、fun的返回地址、main的栈底地址和栈顶地址（栈顶地址（SP）是由硬件自动管理的，通常不需要显式保存）、fun函数的变量依次压栈</p><p>调用f函数-&gt;f函数的参数（从右往左）、f函数的返回地址、f函数的变量依次压栈（printf中调用两次，如果是常数从右往左压栈，但是如果是表达式则求值顺序不确定，这里是从左往右）</p><ul><li><strong>运行状态</strong>：通常由调用约定决定是否需要显式保存寄存器状态，而不是直接压栈。</li></ul><h4 id="（2）文字描述"><a href="#（2）文字描述" class="headerlink" title="（2）文字描述"></a>（2）文字描述</h4><p>栈空间分配存储空间</p><p>从实参的存储空间复制到形参空间</p><p>进行运算</p><h2 id="四、内存"><a href="#四、内存" class="headerlink" title="四、内存"></a>四、内存</h2><h3 id="1、内存分区-内存管理"><a href="#1、内存分区-内存管理" class="headerlink" title="1、内存分区&#x2F;内存管理"></a>1、内存分区&#x2F;内存管理</h3><p>栈</p><p>堆</p><p>全局&#x2F;静态数据区：全局变量和静态变量（包括初始化和未初始化）</p><p>常量区</p><p>代码区</p><h4 id="（1）栈和堆的区别"><a href="#（1）栈和堆的区别" class="headerlink" title="（1）栈和堆的区别"></a>（1）栈和堆的区别</h4><p>栈存在静态分配（编译器分配）和动态分配（alloc），编译器自动释放，空间是连续的，向栈底扩展（从内存的高地址向低地址生长），系统提供，速度快；</p><p>堆是程序员自己申请的，需要自己释放，只有动态分配，空间是不连续的，会生成碎片，向高地址扩展，是C&#x2F;C++函数库，效率低</p><h5 id="①哪个快一点"><a href="#①哪个快一点" class="headerlink" title="①哪个快一点"></a>①哪个快一点</h5><p>栈更快。栈是操作系统在底层提供支持，有专门的寄存器和执行指令；堆是C&#x2F;C++函数库提供的，且需要访问两次内存（一次访问指针，一次找到指针所指的地址）</p><h5 id="②哪个建立对象更快"><a href="#②哪个建立对象更快" class="headerlink" title="②哪个建立对象更快"></a>②哪个建立对象更快</h5><p>堆需要调用函数</p><p>访问堆的一个单元要经历两次访存，栈只进行一次</p><h3 id="2、类的对象存储空间"><a href="#2、类的对象存储空间" class="headerlink" title="2、类的对象存储空间"></a>2、类的对象存储空间</h3><p>非静态成员数据类型大小之和（包括基类）+编译器额外加入的成员变量（如指向虚函数表的指针）+为了边缘对齐优化加入的padding（成员函数不占用对象内存（放在代码区包括静态函数））</p><h4 id="（1）空类"><a href="#（1）空类" class="headerlink" title="（1）空类"></a>（1）空类</h4><p>空类（无非静态数据成员）的对象size&#x3D;1，当作为基类size&#x3D;0，有虚函数大小根据虚函数指针确定</p><p>空类同样可以实例化，类对象大小和类大小相同，但是地址不同，类指针大小等于指针大小（4字节）</p><h3 id="3、内存池"><a href="#3、内存池" class="headerlink" title="3、内存池"></a>3、内存池</h3><p>内存分配方式，避免new、malloc由于内存分配大小不确定导致的内存碎片，封装malloc、free在真正使用内存前先分配一定数量的、大小相等的内存块</p><h3 id="4、动态内存申请（malloc-calloc-new）"><a href="#4、动态内存申请（malloc-calloc-new）" class="headerlink" title="4、动态内存申请（malloc, calloc, new）"></a>4、动态内存申请（malloc, calloc, new）</h3><p>都是在堆</p><h4 id="（1）分配虚拟内存空间和物理内存空间"><a href="#（1）分配虚拟内存空间和物理内存空间" class="headerlink" title="（1）分配虚拟内存空间和物理内存空间"></a>（1）分配虚拟内存空间和物理内存空间</h4><h5 id="①malloc"><a href="#①malloc" class="headerlink" title="①malloc"></a>①malloc</h5><p>手动计算内存大小</p><p>malloc&#x2F;ˈmælɒk&#x2F;动态申请内存时（没有进行初始化），操作系统会分配虚拟内存（虚拟内存通过页表映射到物理内存），但是并没有分配物理内存，当程序访问虚拟内存时，会触发“缺页”异常，于是才会进行物理内存的分配，这种分配方式称为“按需分页”</p><p>brk、mmap、munmap系统调用</p><p>brk将堆顶指针向高地址移动，扩大程序在运行时的堆大小（小于128k），mmap在进程的虚拟内存地址空间中找一块空闲的虚拟内存，获得一块可以操作的堆内存（大于128k）。</p><p>在第一次访问已分配的虚拟地址空间时，发生缺页中断，操作系统负责分配物理内存，建立虚拟内存和物理内存之间的映射关系</p><h5 id="②new"><a href="#②new" class="headerlink" title="②new"></a>②new</h5><p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20250315181709938.png" alt="image-20250315181709938"></p><h5 id="③calloc"><a href="#③calloc" class="headerlink" title="③calloc"></a>③calloc</h5><p>Calloc&#x2F;ˈkælɒk&#x2F;动态申请内存时，会直接进行初始化为0，所以会直接分配虚拟内存和物理内存，这也导致分配过程较慢</p><p>省去了人为计算空间</p><h5 id="④realloc"><a href="#④realloc" class="headerlink" title="④realloc"></a>④realloc</h5><p>给动态分配的空间分配额外的空间，用于扩充</p><h4 id="（2）malloc-free和new-delete的区别"><a href="#（2）malloc-free和new-delete的区别" class="headerlink" title="（2）malloc&#x2F;free和new&#x2F;delete的区别"></a>（2）malloc&#x2F;free和new&#x2F;delete的区别</h4><p>Malloc是C语言标准库函数，支持覆盖，需要库文件，不调用构造函数，不是类型安全的，返回的是void类型的指针，需要强制类型转换，需要计算内存分配大小，动态申请和释放，无法强制要求构造和析构</p><p>new是C++操作符（关键字），支持重载，自动调用构造函数，是类型安全的，返回具体类型的指针，自动分配内存大小（无需指出所需内存大小），new封装了malloc可以使用free但是仅仅是析构，没有释放内存</p><h4 id="（3）new、delete是如何实现的"><a href="#（3）new、delete是如何实现的" class="headerlink" title="（3）new、delete是如何实现的"></a>（3）new、delete是如何实现的</h4><p>复杂结构，New通过调用标准库函数分配内存，在分配的内存上调用对象的构造函数进行初始化，最后返回指向这个新创建对象的指针；</p><p>简单类型，new[]计算好大小后调用operate new</p><p>复杂类型：Delete调用析构函数，然后调用标准库函数释放内存</p><p>简单类型：delete默认调用free</p><h4 id="（4）为什么要有new-delete"><a href="#（4）为什么要有new-delete" class="headerlink" title="（4）为什么要有new&#x2F;delete"></a>（4）为什么要有new&#x2F;delete</h4><p>对非基本类型使用时，需要调用构造函数和析构函数，但是malloc是库函数，是已经编译的，不能把构造函数和析构函数强加（它在编译好的二进制库中（如 libc.so 或 msvcrt.dll），无法在运行时动态插入 C++ 的构造&#x2F;析构逻辑）</p><h4 id="（5）被free掉的空间是直接返还给内存吗"><a href="#（5）被free掉的空间是直接返还给内存吗" class="headerlink" title="（5）被free掉的空间是直接返还给内存吗"></a>（5）被free掉的空间是直接返还给内存吗</h4><p>不是，是先用双链表（尝试对小内存进行合并，避免碎片）存储，下一次需要分配空间时，会先从这些空间里查询是否有符合条件的空间</p><h4 id="（6）C-中有几种方式的new"><a href="#（6）C-中有几种方式的new" class="headerlink" title="（6）C++中有几种方式的new"></a>（6）C++中有几种方式的new</h4><h5 id="①explain"><a href="#①explain" class="headerlink" title="①explain"></a>①explain</h5><p>默认，失败返回bad_alloc异常</p><h5 id="②nothrow"><a href="#②nothrow" class="headerlink" title="②nothrow"></a>②nothrow</h5><p>失败返回NULL</p><h5 id="③placement"><a href="#③placement" class="headerlink" title="③placement"></a>③placement</h5><p>允许在一块已经成功分配的内存上重新构造对象或对象数组（反复使用一块较大的动态分配的内存），不分配内存</p><p>要显示调用析构函数，不要delete</p><h4 id="（7）delete-p、delete-p、allocator都有什么作用"><a href="#（7）delete-p、delete-p、allocator都有什么作用" class="headerlink" title="（7）delete p、delete[]p、allocator都有什么作用"></a>（7）delete p、delete[]p、allocator都有什么作用</h4><p>动态数组中[]里必须是整数，但可以不是常量，普通数组中必须是常数整数</p><p>new动态数组返回的并不是数组类型，而是一个元素类型的指针</p><p>delete[]按数组逆序的顺序进行销毁，调用数组中每个元素的析构函数；new时分配了4字节大小存储数组大小delete[]调出</p><p>allocator申请一部分内存，在需要时手动调用构造函数、析构函数</p><h4 id="（8）什么是内存泄露，如何检测与避免"><a href="#（8）什么是内存泄露，如何检测与避免" class="headerlink" title="（8）什么是内存泄露，如何检测与避免"></a>（8）什么是内存泄露，如何检测与避免</h4><p>堆内存泄露，使用后必须显式释放，否则这块内存就不能再被使用</p><p>后果：只发生一次小的内存泄露可能不被注意，但是当大量内存泄露，性能下降到内存逐渐用完，导致另一个程序失败</p><h5 id="①避免"><a href="#①避免" class="headerlink" title="①避免"></a>①避免</h5><p>计数：分配+1，释放-1-&gt;成对出现</p><p>基类析构函数声明为虚函数（否则静态绑定，使用基类指针删除派生类对象时，只会调用基类析构函数，不会调用派生类析构函数，可以是纯虚函数（变成抽象类，不能实例化））</p><p>数组要delete[]</p><p>遵循RAII原则，资源获取即初始化，资源释放即析构，通过对象的声明周期管理资源</p><p>智能指针，避免手动管理内存</p><h5 id="②检测工具"><a href="#②检测工具" class="headerlink" title="②检测工具"></a>②检测工具</h5><p>Linux用Valgrind&#x2F;ˈvælɡrɪnd&#x2F;；Windows用CRT库</p><h4 id="（9）类如何实现只能静态分配或动态分配"><a href="#（9）类如何实现只能静态分配或动态分配" class="headerlink" title="（9）类如何实现只能静态分配或动态分配"></a>（9）类如何实现只能静态分配或动态分配</h4><h5 id="①静态"><a href="#①静态" class="headerlink" title="①静态"></a>①静态</h5><p>把new、delete重载为private</p><h5 id="②动态"><a href="#②动态" class="headerlink" title="②动态"></a>②动态</h5><p>把构造、析构设为protected然后再用子类动态创建</p><h5 id="③建立类的对象有两种方式"><a href="#③建立类的对象有两种方式" class="headerlink" title="③建立类的对象有两种方式"></a>③建立类的对象有两种方式</h5><p>静态：编译器在栈上分配内存</p><p>动态：new（内存-&gt;构造函数）在堆</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 可执行程序 </tag>
            
            <tag> main </tag>
            
            <tag> 压栈 </tag>
            
            <tag> 内存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++数据结构(三)：面向对象三大特性</title>
      <link href="/my_tech_blog.github.io/2025/11/09/C++%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_3/"/>
      <url>/my_tech_blog.github.io/2025/11/09/C++%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_3/</url>
      
        <content type="html"><![CDATA[<h1 id="C-数据结构（三）：面向对象三大特性"><a href="#C-数据结构（三）：面向对象三大特性" class="headerlink" title="C++数据结构（三）：面向对象三大特性"></a>C++数据结构（三）：面向对象三大特性</h1><h2 id="一、继承"><a href="#一、继承" class="headerlink" title="一、继承"></a>一、继承</h2><h3 id="1、类之间的关系"><a href="#1、类之间的关系" class="headerlink" title="1、类之间的关系"></a>1、类之间的关系</h3><p>包含关系：成员属性</p><p>使用关系：成员函数，友元函数，传递参数</p><p>is-A：继承关系，具有传递性</p><h3 id="2、概念"><a href="#2、概念" class="headerlink" title="2、概念"></a>2、概念</h3><p>一个类继承了上一个类的属性和和方法，新的类包含上一个类的属性和方法，被称为子类或派生类，上一个类被称为父类或基类</p><h3 id="3、访问控制"><a href="#3、访问控制" class="headerlink" title="3、访问控制"></a>3、访问控制</h3><p>private、public、protected</p><h3 id="4、兼容性关系"><a href="#4、兼容性关系" class="headerlink" title="4、兼容性关系"></a>4、兼容性关系</h3><p>向上转型：派生类可以赋值给基类指针或引用，当使用基类指针或引用时，调用函数是基类的函数（静态绑定），虚函数则是派生类的函数（动态绑定）</p><h4 id="（1）静态类型、动态类型、静态绑定、动态绑定"><a href="#（1）静态类型、动态类型、静态绑定、动态绑定" class="headerlink" title="（1）静态类型、动态类型、静态绑定、动态绑定"></a>（1）静态类型、动态类型、静态绑定、动态绑定</h4><p>静态类型：对象在声明时采用的类型，在编译时已经确定</p><p>动态类型：指针或引用目前所指对象的类型，在运行期决定</p><p>静态绑定：绑定的是静态类型，所对应的函数或属性依赖与对象的静态类型，发生在编译期</p><p>动态绑定：动态类型，运行期（性能损失，但是多态性）</p><p>非虚函数一般是静态绑定，虚函数一般是动态绑定</p><p>引用可以使用动态绑定（虚函数）</p><h3 id="5、继承方式"><a href="#5、继承方式" class="headerlink" title="5、继承方式"></a>5、继承方式</h3><p>实现继承：派生类继承基类的实现，可以直接使用基类的功能</p><p>接口继承：只继承基类的接口（纯虚函数&#x3D;0），必须实现基类接口</p><p>可视继承：GUI框架，派生类继承基类的界面布局和控件</p><h3 id="6、继承种类"><a href="#6、继承种类" class="headerlink" title="6、继承种类"></a>6、继承种类</h3><h4 id="（1）多继承"><a href="#（1）多继承" class="headerlink" title="（1）多继承"></a>（1）多继承</h4><p>一个类作为派生类允许指定多个基类，称为多重继承</p><p>优点：可以调用多个基类接口</p><p>缺点：如果基类有共同基类，会导致二义性（菱形继承）</p><p>解决：全局符确定调用哪一份拷贝；虚拟继承，只有一份拷贝</p><h4 id="（2）菱形继承"><a href="#（2）菱形继承" class="headerlink" title="（2）菱形继承"></a>（2）菱形继承</h4><h4 id="（3）虚继承"><a href="#（3）虚继承" class="headerlink" title="（3）虚继承"></a>（3）虚继承</h4><p>用于解决菱形继承问题（Diamond Problem）的一种机制。当多个派生类继承自同一个基类，而这些派生类又被另一个类继承时，虚拟继承可以确保基类在最终派生类中只有一份实例，避免数据冗余和二义性。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">VirtualDerived1</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> Base &#123;&#125;;</span><br></pre></td></tr></table></figure><h3 id="7、组合与继承相比较"><a href="#7、组合与继承相比较" class="headerlink" title="7、组合与继承相比较"></a>7、组合与继承相比较</h3><p>组合一般优于继承，低耦合高内聚</p><h4 id="（1）继承"><a href="#（1）继承" class="headerlink" title="（1）继承"></a>（1）继承</h4><h5 id="①继承的优点"><a href="#①继承的优点" class="headerlink" title="①继承的优点"></a>①继承的优点</h5><p>子类可以重写父类的方法，实现对父类的扩展</p><h5 id="②继承的缺点"><a href="#②继承的缺点" class="headerlink" title="②继承的缺点"></a>②继承的缺点</h5><p>父类的内部细节对子类是可见的；子类从父类的继承方法在编译时就确定好了，无法在运行时更改；如果修改父类，子类必须做出对应修改，是一种高耦合，违背了面向对象的思想</p><h4 id="（2）组合（设计模式）"><a href="#（2）组合（设计模式）" class="headerlink" title="（2）组合（设计模式）"></a>（2）组合（设计模式）</h4><p>组合就是设计类时把要组合的类的对象加入到类中作为成员变量</p><h5 id="①组合的优点"><a href="#①组合的优点" class="headerlink" title="①组合的优点"></a>①组合的优点</h5><p>通过所包含的对象去调用其方法，所包含对象的细节对当前类是不可见的；可以在运行时动态的绑定所包含的对象，可以通过set方法给所包含的对象赋值；是低耦合关系，如果修改所包含对象类，不需要修改当前类的代码</p><h5 id="②组合的缺点"><a href="#②组合的缺点" class="headerlink" title="②组合的缺点"></a>②组合的缺点</h5><p>可能会产生过多对象；为了能够组合多个对象，必须仔细对接口进行定义</p><h3 id="8、问题"><a href="#8、问题" class="headerlink" title="8、问题"></a>8、问题</h3><h4 id="（1）基类为什么必须定义而非声明"><a href="#（1）基类为什么必须定义而非声明" class="headerlink" title="（1）基类为什么必须定义而非声明"></a>（1）基类为什么必须定义而非声明</h4><p>派生类包含并可以使用基类成员，为了使用必须知道是什么</p><h4 id="（2）构造函数和析构函数调用顺序"><a href="#（2）构造函数和析构函数调用顺序" class="headerlink" title="（2）构造函数和析构函数调用顺序"></a>（2）构造函数和析构函数调用顺序</h4><p>派生类对象创建时先调用基类的构造函数，再调用派生类的构造函数（虚基类-&gt;基类（继承顺序）-&gt;对象的vptr被初始化-&gt;类类型的成员对象构造函数（成员对象在类中的定义顺序）-&gt;派生类构造函数：成员初始化列表：声明顺序决定、代码）；</p><p>销毁时，先调用派生类的析构函数再调用基类的析构函数</p><h2 id="二、封装"><a href="#二、封装" class="headerlink" title="二、封装"></a>二、封装</h2><p>数据和代码捆绑在一起，避免外界干扰和不确定性访问。</p><p>把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行隐藏</p><h2 id="三、多态"><a href="#三、多态" class="headerlink" title="三、多态"></a>三、多态</h2><p>向不同的对象发送同样消息，不同对象在接收时会产生不同的行为</p><p>允许将种类型的指针赋值给父类类型的指针</p><h3 id="1、编译时多态：重载、模板"><a href="#1、编译时多态：重载、模板" class="headerlink" title="1、编译时多态：重载、模板"></a>1、编译时多态：重载、模板</h3><h4 id="（1）模板"><a href="#（1）模板" class="headerlink" title="（1）模板"></a>（1）模板</h4><p><code>templace &lt;typename type1,typename type2&gt;</code></p><p><code>type1 Max(type1 a,type2 a)&#123;</code></p><p><code>return a&gt;b?a:b;&#125;</code>&#x2F;&#x2F;有bug-&gt;能转型，否则重载&gt;</p><h5 id="①模板类和模板函数的区别是什么"><a href="#①模板类和模板函数的区别是什么" class="headerlink" title="①模板类和模板函数的区别是什么"></a>①模板类和模板函数的区别是什么</h5><p>类模板必须显式实例化（编译时生成具体类），程序员显式指定类型，必须<T>：类的结构（成员变量、内存布局）完全依赖类型参数，必须显式指定。</p><p>函数模板可以隐式或显示调用（实例化是编译器在处理函数调用时自动完成的（除非显式指定）），不必<T>：函数的参数和返回值类型可通过调用上下文推导，减少冗余代码。</p><h5 id="②为什么模板类一般都放在h文件中-模板和实现可不可以不写在一个文件里"><a href="#②为什么模板类一般都放在h文件中-模板和实现可不可以不写在一个文件里" class="headerlink" title="②为什么模板类一般都放在h文件中&#x2F;模板和实现可不可以不写在一个文件里"></a>②为什么模板类一般都放在h文件中&#x2F;模板和实现可不可以不写在一个文件里</h5><p>模板类很特殊，由template&lt;&gt;处理意味着在编译器不为它分配存储空间，一直处于等待状态一直等到被一个模板实例告知。模板类或函数的实现不能被编译成二进制代码，链接程序找不到地址。在编译器和连接器的某一处，有一处机制能去掉指定模板的重定义</p><p>在分离式编译的情况下，一个.cpp文件看不到其他.cpp文件，当发现未知符号，寄希望与连接器，为了能够让编译器看到完整的模板定义，放在h文件中</p><h3 id="2、运行时多态：覆盖（虚函数virtual）"><a href="#2、运行时多态：覆盖（虚函数virtual）" class="headerlink" title="2、运行时多态：覆盖（虚函数virtual）"></a>2、运行时多态：覆盖（虚函数virtual）</h3><h4 id="（1）虚表和虚基表指针"><a href="#（1）虚表和虚基表指针" class="headerlink" title="（1）虚表和虚基表指针"></a>（1）虚表和虚基表指针</h4><p>虚表（每个有虚函数的类（包括派生类）在编译期生成一个虚表，虚表是类级别的，所有同类对象共享同一虚表）：虚函数表的缩写，类中有virtual关键字修饰时，编译器会自动生成虚表（保存虚函数入口地址）；是全局共享，在编译时就构造完成，位于常量区，虚函数位于代码段</p><p>虚表指针（每个有虚函数的类的对象内部隐含一个 vptr（编译器自动插入），在对象的构造函数中，vptr 被赋值为当前类的虚表地址，是对象的一部分，随对象创建&#x2F;销毁而存在&#x2F;消失）：含有虚函数的类进行对象实例化时，对象地址的前四个字节存储的指向虚表的指针（对象内部的隐藏数据成员，构造函数初始化虚表指针，指向父类虚表或子类虚表）</p><p>通过this找到vptr-&gt;vptr找到vtable-&gt;从vtable找到函数地址-&gt;调用该地址函数</p><h4 id="（2）C-中类的虚函数数量对类的大小有什么影响？"><a href="#（2）C-中类的虚函数数量对类的大小有什么影响？" class="headerlink" title="（2）C++中类的虚函数数量对类的大小有什么影响？"></a>（2）C++中类的虚函数数量对类的大小有什么影响？</h4><p>类中虚函数会通过虚函数表实现，无论虚函数数量多少，类的大小只多一个虚函数表指针的大小。 </p><h4 id="（3）哪些函数不能是虚函数"><a href="#（3）哪些函数不能是虚函数" class="headerlink" title="（3）哪些函数不能是虚函数"></a>（3）哪些函数不能是虚函数</h4><p>构造函数、静态成员函数、内联函数、友元函数（不属于类的成员函数，不能被继承，没有虚函数的说法）、普通函数（不属于类的成员函数、不能被继承，没有虚函数的说法）</p><h5 id="③构造函数可以是虚函数吗"><a href="#③构造函数可以是虚函数吗" class="headerlink" title="③构造函数可以是虚函数吗"></a>③构造函数可以是虚函数吗</h5><p>不可以，若构造函数为虚函数，调用时它的虚表指针需要指向虚表，但此时对象尚未构造完成，虚指针未初始化</p><p>存储空间：构造函数是虚函数就需要通过虚表调用，查虚表需要vptr，但vptr需要构造函数初始化（构造函数调用第一件事就是初始化虚表指针）</p><h5 id="④构造函数和析构函数可以调用虚函数吗"><a href="#④构造函数和析构函数可以调用虚函数吗" class="headerlink" title="④构造函数和析构函数可以调用虚函数吗"></a>④构造函数和析构函数可以调用虚函数吗</h5><p>不提倡：在构造和析构期间不要调用虚函数，因为这类调用不会下降至派生类。</p><p>不使用动态联编。</p><p>构造函数：基类构造函数执行时，派生类尚未构造，此时虚表指针（vptr）指向基类的虚表，因此调用的永远是基类版本。</p><p>调用基类的虚函数时，析构函数已将子类数据成员销毁，此时vptr已指回基类虚表</p><h5 id="⑤静态函数和常函数可以定义为虚函数吗"><a href="#⑤静态函数和常函数可以定义为虚函数吗" class="headerlink" title="⑤静态函数和常函数可以定义为虚函数吗"></a>⑤静态函数和常函数可以定义为虚函数吗</h5><p>static不能：static成员不属于任何类对象和实例，定义为虚函数没有意义；静态成员函数没有this指针，无法访问vptr</p><h4 id="（4）虚函数的代价"><a href="#（4）虚函数的代价" class="headerlink" title="（4）虚函数的代价"></a>（4）虚函数的代价</h4><p>虚函数表、虚表指针-&gt;空间；不能内联（在编译阶段进行替代），虚函数运行阶段才能确定是哪种函数</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++数据结构(二)：C++11</title>
      <link href="/my_tech_blog.github.io/2025/11/09/C++%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_2/"/>
      <url>/my_tech_blog.github.io/2025/11/09/C++%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_2/</url>
      
        <content type="html"><![CDATA[<h1 id="C-数据结构（二）：C-11"><a href="#C-数据结构（二）：C-11" class="headerlink" title="C++数据结构（二）：C++11"></a>C++数据结构（二）：C++11</h1><h2 id="C-11"><a href="#C-11" class="headerlink" title="C++11"></a>C++11</h2><p>C++11是里程碑式更新，现代C++起点</p><h3 id="1、nullptr代替了NULL"><a href="#1、nullptr代替了NULL" class="headerlink" title="1、nullptr代替了NULL"></a>1、nullptr代替了NULL</h3><p>NULL来自C语言，一般由宏定义实现，而nullptr是C++11的新增关键字</p><p>NULL被定义位整数0，nullptr可以明确区分整型和指针类型，并且可以根据环境自动转换成相应的指针类型，但不会被转换为任何整型，使用不会造成参数传递错误</p><h3 id="2、引入了auto和decltype实现了类型推导"><a href="#2、引入了auto和decltype实现了类型推导" class="headerlink" title="2、引入了auto和decltype实现了类型推导"></a>2、引入了auto和decltype实现了类型推导</h3><h4 id="（1）auto"><a href="#（1）auto" class="headerlink" title="（1）auto"></a>（1）auto</h4><p>auto让编译器根据初值进行类型推演，获取变量类型，所以auto修饰的变量必须拥有初值</p><p>基于范围的for循环</p><h4 id="（2）decltype（表达式）"><a href="#（2）decltype（表达式）" class="headerlink" title="（2）decltype（表达式）"></a>（2）decltype（表达式）</h4><p>选择并返回操作数的类型，编译器只分析表达式的类型，并不实际计算表达式的值，可先不赋值</p><h4 id="（3）decltpye（auto）"><a href="#（3）decltpye（auto）" class="headerlink" title="（3）decltpye（auto）"></a>（3）decltpye（auto）</h4><p>可以用来声明变量以及指示函数返回类型，在使用时会用“&#x3D;”后的表达式代替auto，再根据decltype确定类型</p><h3 id="3、类和结构体中的初始化列表"><a href="#3、类和结构体中的初始化列表" class="headerlink" title="3、类和结构体中的初始化列表"></a>3、类和结构体中的初始化列表</h3><h3 id="4、lambda表达式（匿名函数）"><a href="#4、lambda表达式（匿名函数）" class="headerlink" title="4、lambda表达式（匿名函数）"></a>4、lambda表达式（匿名函数）</h3><p>编写内嵌的匿名函数（没有函数名），可以用来替换独立函数或函数对象。</p><p>每当定义一个lambda函数，编译器会自动生成一个闭包类型的对象。运行时会返回一个闭包类型，其实是一个右值（可以绑定到左值，auto x&#x3D; [] ()&#x2F;&#x2F;priority_queue就需要绑定到左值使用匿名函数）。闭包可以通过传值或引用的方法捕捉其封装作用域内的变量，[]用于捕获，可使用尾置指针（尾置返回类型）来返回指定类型，可以忽略参数和返回值（-&gt;返回类型，当类型复杂或存在多条返回类型时，需显示指定），但是必须包含捕获列表（可以为空但是必须存在）和函数体</p><p>mutable允许修改按值捕获的变量（int x,[x]，可以改变x的副本）</p><h3 id="5、新的容器类型"><a href="#5、新的容器类型" class="headerlink" title="5、新的容器类型"></a>5、新的容器类型</h3><h4 id="（1）forward-list（单向链表）"><a href="#（1）forward-list（单向链表）" class="headerlink" title="（1）forward_list（单向链表）"></a>（1）forward_list（单向链表）</h4><p>list(双向链表)</p><h3 id="6、右值引用和移动语义"><a href="#6、右值引用和移动语义" class="headerlink" title="6、右值引用和移动语义"></a>6、右值引用和移动语义</h3><p>移动语义允许将资源从一个对象“转移”到另一个对象，而非传统拷贝，避免了不必要的深拷贝，右值语义绑定到临时对象，表明可“窃取”其资源。move将左值强制转换为右值引用，表明资源可以被移动</p><h4 id="（1）左值、右值定义"><a href="#（1）左值、右值定义" class="headerlink" title="（1）左值、右值定义"></a>（1）左值、右值定义</h4><p>左值是可以出现在赋值语句左侧的表达式，通常标识一个内存地址，可以取地址</p><p>右值是只能出现在赋值语句右边的表达式，通常表示一个临时值（将亡值（通过盗取其他变量获得内存空间的变量）或纯右值（临时变量和不与对象关联的字面量值））</p><h4 id="（2）左值引用和右值引用"><a href="#（2）左值引用和右值引用" class="headerlink" title="（2）左值引用和右值引用"></a>（2）左值引用和右值引用</h4><p>引用必须立即进行初始化</p><p>左值引用：可以绑定在左值void func(int&amp; x);（左值常引用可以用右值初始化）左值引用是引用类型，但它是一个左值，因为它引用的是一个持久存在的对象。</p><p>右值引用：可以绑定在右值void func(int&amp;&amp; x);</p><h4 id="（3）函数参数"><a href="#（3）函数参数" class="headerlink" title="（3）函数参数"></a>（3）函数参数</h4><p>int com(int a,int&amp;b,int&amp;&amp;c);</p><p>其中a是按值传递，可以接受左值或右值；b是左值引用，只能绑定到左值（具名对象）；c是右值引用，明确接受右值</p><h3 id="7、智能指针"><a href="#7、智能指针" class="headerlink" title="7、智能指针"></a>7、智能指针</h3><p>RAII（资源获取及初始化：在构造函数中分配资源，在析构函数中释放资源）的典型应用，用于自动管理动态内存</p><p>智能指针是一个类，用来存储指向动态分配对象的指针，用类对象来管理动态分配的资源，当类对象声明周期结束后，自动调用析构函数释放资源</p><h4 id="（1）shared-ptr"><a href="#（1）shared-ptr" class="headerlink" title="（1）shared_ptr"></a>（1）shared_ptr</h4><p>使用引用计数器，允许多个智能指针指向同一个对象，每当多一个指针指向该对象时，引用技术加一，减少一个指针则减一，当计数为0会自动释放动态内存分配的资源</p><p>内部的引用计数是线程安全的，但调用对象需要单独加锁</p><p>不能将指针直接赋值给智能指针，一个是类，一个是指针，可以使用构造函数传入指针初始化，可以使用make_share初始化</p><ul><li>需要多个对象共享同一资源时（如缓存、观察者模式）。</li></ul><h4 id="（2）unique-ptr"><a href="#（2）unique-ptr" class="headerlink" title="（2）unique_ptr"></a>（2）unique_ptr</h4><p>独享所有语义权，一个非空总是拥有它所指向的资源，不支持普通的拷贝和复制（不能用在STL标准容器中），支持移动</p><ul><li>明确资源唯一所有权的场景（如工厂模式返回的对象）。</li></ul><h4 id="（3）weak-ptr"><a href="#（3）weak-ptr" class="headerlink" title="（3）weak_ptr"></a>（3）weak_ptr</h4><p>弱引用，引用计数shared_ptr会造成引用成环（指针之间相互指），导致计数无法清零，weaker_ptr是为了配合shared_ptr引入的，当它指向由shared_ptr管理的对象时，只引用不计数，当引用计数的shared_ptr都被销毁时，无论是否有weak_ptr资源都会被释放，所以weak_ptr不保证它指向的内存一定是有效的，在使用之前要检查是否为空（使用lock转化为share_ptr），与普通指针相比，可以检测到所管理的对象是否已经被释放</p><p>提供了一个对管理对象的访问手段</p><ul><li>打破 <code>shared_ptr</code> 的循环引用（如双向链表、观察者模式）。</li></ul><h4 id="（4）auto-ptr"><a href="#（4）auto-ptr" class="headerlink" title="（4）auto_ptr"></a>（4）auto_ptr</h4><p>已经废弃</p><p>解决有异常抛出时发生内存泄露的问题。有拷贝语义，但是拷贝后源对象变无效，可能会引发严重的问题，unique_ptr无拷贝语义，但是有移动语义，这样的错误不会再发生，因为必须使用move进行转移</p><h4 id="（5）手写智能指针类需要实现哪些函数"><a href="#（5）手写智能指针类需要实现哪些函数" class="headerlink" title="（5）手写智能指针类需要实现哪些函数"></a>（5）手写智能指针类需要实现哪些函数</h4><p>构造函数、拷贝构造函数（复制构造函数）、拷贝赋值运算符、析构函数、移动函数</p><h3 id="8、并发支持"><a href="#8、并发支持" class="headerlink" title="8、并发支持"></a>8、并发支持</h3><p>线程、原子操作</p><h3 id="9、变长模板"><a href="#9、变长模板" class="headerlink" title="9、变长模板"></a>9、变长模板</h3>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> C++11 </tag>
            
            <tag> 现代C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++数据结构(一)：与其他编程语言对比</title>
      <link href="/my_tech_blog.github.io/2025/11/09/C++%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_1/"/>
      <url>/my_tech_blog.github.io/2025/11/09/C++%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_1/</url>
      
        <content type="html"><![CDATA[<h1 id="C-数据结构-一-：与其他编程语言的对比"><a href="#C-数据结构-一-：与其他编程语言的对比" class="headerlink" title="C++数据结构(一)：与其他编程语言的对比"></a>C++数据结构(一)：与其他编程语言的对比</h1><h2 id="一、C-语言特性"><a href="#一、C-语言特性" class="headerlink" title="一、C++语言特性"></a>一、C++语言特性</h2><p>C++是一种强类型语言，支持泛型编程，兼具高性能和面向对象特性。</p><h2 id="二、C-与C语言的区别"><a href="#二、C-与C语言的区别" class="headerlink" title="二、C++与C语言的区别"></a>二、C++与C语言的区别</h2><h3 id="1、编程范式"><a href="#1、编程范式" class="headerlink" title="1、编程范式"></a>1、编程范式</h3><ul><li><p><strong>C语言</strong>：面向过程编程</p></li><li><p>**C++**：面向对象编程，支持类、继承、多态等特性</p><p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20250413154328788.png" alt="image-20250413154328788"></p></li></ul><h3 id="2、类型安全"><a href="#2、类型安全" class="headerlink" title="2、类型安全"></a>2、类型安全</h3><p>类型安全即内存安全，确保程序不会访问未授权的内存区域。</p><ul><li><strong>C语言</strong>：局部上下文类型安全；存在不安全操作如<code>printf</code>、<code>malloc</code>（返回<code>void*</code>）</li><li>**C++**：更强的类型安全；<code>new</code>（返回固定类型）、<code>dynamic_cast</code>、模板等特性</li></ul><h5 id="①-new-delete-与-malloc-free-的区别"><a href="#①-new-delete-与-malloc-free-的区别" class="headerlink" title="① new&#x2F;delete 与 malloc&#x2F;free 的区别"></a>① new&#x2F;delete 与 malloc&#x2F;free 的区别</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++方式</span></span><br><span class="line"><span class="type">int</span>* ptr = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">42</span>);</span><br><span class="line"><span class="keyword">delete</span> ptr;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C方式</span></span><br><span class="line"><span class="type">int</span>* ptr = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">*ptr = <span class="number">42</span>;</span><br><span class="line"><span class="built_in">free</span>(ptr);</span><br></pre></td></tr></table></figure><p><strong>区别</strong>：</p><ul><li><code>new/delete</code>是运算符，<code>malloc/free</code>是函数</li><li><code>new</code>自动计算大小，<code>malloc</code>需要手动计算</li><li><code>new</code>会调用构造函数，<code>delete</code>会调用析构函数</li></ul><h3 id="3、string替代char"><a href="#3、string替代char" class="headerlink" title="3、string替代char*"></a>3、string替代char*</h3><p><code>std::string</code>对<code>char*</code>进行了封装，包含字符数组、长度等信息，支持动态扩展。</p><p><strong>动态扩展机制</strong>：当空间不足时，申请原空间两倍的新空间，拷贝原内容并添加新内容。</p><p><strong>字符串函数对比</strong>：</p><ul><li><p><code>strcpy</code> vs<code>memcpy</code>vs<code>sprintf</code> </p><p>strcpy的两个操作对象均为字符串，不需要指定长度，到’\0’，容易溢出；(strncpy：复制前n个字符，不能重叠，且必须有n个字符的空间)</p><p>memcpy的两个对象就是两个任意可操作的内存地址（内存块间的拷贝），第三个参数决定复制长度</p><p>sprintf的源操作对象是多种数据类型，目的操作对象是字符串</p><p>执行效率：memecpy&gt;strcpy&gt;sprintf</p></li><li><p><code>strlen</code> vs <code>sizeof</code></p><p>strlen是函数，在运行时得到，只能对结尾是‘\0’的字符串使用；sizeof是运算符，在编译时得到，无法使用于动态内存分配，可以对任何类型进行使用</p></li><li><p><code>strncpy</code> vs <code>snprintf</code></p></li></ul><p>  <code>strncpy</code> </p><p>  目标&gt;指定&gt;源长：将源长全部拷贝+‘\0’</p><p>  指定&lt;源长：拷贝指定长，不+’\0’</p><p>  指定长&gt;目标：运行时错误</p><h3 id="4、异常处理"><a href="#4、异常处理" class="headerlink" title="4、异常处理"></a>4、异常处理</h3><p>C++提供完整的异常处理机制：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;错误信息&quot;</span>);</span><br><span class="line">&#125; <span class="built_in">catch</span> (<span class="type">const</span> std::exception&amp; e) &#123;</span><br><span class="line">    std::cout &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="（1）异常"><a href="#（1）异常" class="headerlink" title="（1）异常"></a>（1）异常</h4><p>数组下标越界；除数为0；动态分配空间时空间不足</p><h4 id="（2）try检查-throw抛出-catch捕获"><a href="#（2）try检查-throw抛出-catch捕获" class="headerlink" title="（2）try检查&#x2F;throw抛出&#x2F;catch捕获"></a>（2）try检查&#x2F;throw抛出&#x2F;catch捕获</h4><p>catch(…)捕获任何异常</p><h4 id="（3）函数异常声明列表"><a href="#（3）函数异常声明列表" class="headerlink" title="（3）函数异常声明列表"></a>（3）函数异常声明列表</h4><p>int fun throw(){};</p><h4 id="（4）标准异常类"><a href="#（4）标准异常类" class="headerlink" title="（4）标准异常类"></a>（4）标准异常类</h4><p>exceptI&#x2F;On派生：</p><p>bad_typeid；bad_alloc；bad_cast；out_of_range（数组下标越界）</p><h4 id="（5）问题"><a href="#（5）问题" class="headerlink" title="（5）问题"></a>（5）问题</h4><h5 id="①C-如何处理多个异常"><a href="#①C-如何处理多个异常" class="headerlink" title="①C++如何处理多个异常"></a>①C++如何处理多个异常</h5><p>多重catch块和异常层次结构</p><h5 id="②异常情况"><a href="#②异常情况" class="headerlink" title="②异常情况"></a>②异常情况</h5><p>语法（编译）错误：可以被编译器发现并定位。如：变量未定义、括号不匹配、关键字拼写错误</p><p>运行时错误：数组下标越界、系统内存不足</p><h5 id="③怎么快速定位错误出现的地方"><a href="#③怎么快速定位错误出现的地方" class="headerlink" title="③怎么快速定位错误出现的地方"></a>③怎么快速定位错误出现的地方</h5><p>简单错误双击错误列表的错误项；复杂错误使用生成输出窗口、调试窗口</p><h6 id="段错误"><a href="#段错误" class="headerlink" title="段错误"></a>段错误</h6><p>访问空指针；访问已经释放的内存（悬空指针）；数组越界（可能是栈溢出可能是堆溢出）；栈溢出；访问只读内存</p><h6 id="堆溢出"><a href="#堆溢出" class="headerlink" title="堆溢出"></a>堆溢出</h6><p>动态内存分配错误（写入数据超过分配、内存大小计算错误）</p><p>数组越界</p><p>字符串操作不当（strcpy&#x2F;strcat不安全）</p><p>内存管理错误（释放后使用、多次释放、内存泄露导致空间耗尽）</p><h6 id="属于段错误的堆溢出"><a href="#属于段错误的堆溢出" class="headerlink" title="属于段错误的堆溢出"></a>属于段错误的堆溢出</h6><p>访问未分配的堆内存、溢出破坏堆管理结构、溢出到收保护的页、溢出导致无效的指针解引用、对齐错误的访问</p><h6 id="不会立即导致段错误的堆溢出"><a href="#不会立即导致段错误的堆溢出" class="headerlink" title="不会立即导致段错误的堆溢出"></a>不会立即导致段错误的堆溢出</h6><p>溢出到已分配的内存块（未越界到受保护区域）、覆盖管理结构但未触发检查、溢出但未跨页内存页边界、覆盖函数指针或对象数据、整数溢出导致堆分配过小</p><h3 id="5、输入输出流"><a href="#5、输入输出流" class="headerlink" title="5、输入输出流"></a>5、输入输出流</h3><p>C++使用控制态的输入输出流：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">std::cin &gt;&gt; variable;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;输出内容&quot;</span> &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><h4 id="（1）printf函数的实现原理"><a href="#（1）printf函数的实现原理" class="headerlink" title="（1）printf函数的实现原理"></a>（1）printf函数的实现原理</h4><p>printf函数 在处理参数的时候是从右向左处理的，其参数从右向左依次压入栈（计算后（求值顺序不确定））中，存放在栈中从高到低的地址里面，然后再格式化输出，输出时从低地址到高地址输出。</p><h4 id="（2）cout和printf有什么区别"><a href="#（2）cout和printf有什么区别" class="headerlink" title="（2）cout和printf有什么区别"></a>（2）cout和printf有什么区别</h4><p>cout&lt;&lt;是std::ostream的全局对象，后面可以跟不同的数据类型是因为已经进行了重载，是行缓冲输出，flush立即强迫缓冲输出、可利用endl刷新缓冲区（不可以\n）</p><p>printf是行缓冲输出（可以利用\n），不是无缓冲输出</p><h3 id="6、函数重载和模板"><a href="#6、函数重载和模板" class="headerlink" title="6、函数重载和模板"></a>6、函数重载和模板</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数重载</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">double</span> x)</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">max</span><span class="params">(T a, T b)</span> </span>&#123; <span class="keyword">return</span> a &gt; b ? a : b; &#125;</span><br></pre></td></tr></table></figure><h4 id="（1）重载（编译时多态）"><a href="#（1）重载（编译时多态）" class="headerlink" title="（1）重载（编译时多态）"></a>（1）重载（编译时多态）</h4><p>水平关系，同一范围，函数名相同，形参类型、数量不同</p><h5 id="①重载运算符"><a href="#①重载运算符" class="headerlink" title="①重载运算符"></a>①重载运算符</h5><p>只能重载已经存在的运算符，优先级和结合律和原来相同，不能改变运算符操作数个数</p><p>两种重载方式：成员函数；非成员函数。成员函数比非成员函数少一个参数，一元运算符必须是成员函数（[]（最好同时定义常量版本和非常量版本，通常返回引用）、-&gt;、&amp;），成员函数this绑定到左侧运算符对象</p><p>当既是一元运算符又是二元运算符，凭借参数的个数判断到底是那种运算符</p><h5 id="②重载函数的匹配原则"><a href="#②重载函数的匹配原则" class="headerlink" title="②重载函数的匹配原则"></a>②重载函数的匹配原则</h5><p>名字查找；确定候选函数；最佳匹配</p><h4 id="（2）覆盖（运行时多态）"><a href="#（2）覆盖（运行时多态）" class="headerlink" title="（2）覆盖（运行时多态）"></a>（2）覆盖（运行时多态）</h4><p>垂直关系，派生类中与基类函数同名、同返回值、同参数，基类中必须是虚函数</p><h4 id="（3）隐藏"><a href="#（3）隐藏" class="headerlink" title="（3）隐藏"></a>（3）隐藏</h4><p>垂直关系，派生类中与基类函数同名、同返回值、同参数，基类中不是虚函数&#x2F;派生类中与基类函数名相同，形参类型、数量不同</p><h4 id="（4）traits（特性萃取）技法"><a href="#（4）traits（特性萃取）技法" class="headerlink" title="（4）traits（特性萃取）技法"></a>（4）traits（特性萃取）技法</h4><p>模板编程的重要技术，广泛使用traits来获取类型相关信息并实现泛型算法：类型信息获取、算法优化、接口统一</p><p>type_traits特性（默认构造函数、拷贝构造函数、赋值运算符、析构函数（如果有一个空类会自动生成））</p><h3 id="7、关键字"><a href="#7、关键字" class="headerlink" title="7、关键字"></a>7、关键字</h3><h4 id="（1）C-98引入的四种类型转换（强制类型转换中四种显式类型转换）"><a href="#（1）C-98引入的四种类型转换（强制类型转换中四种显式类型转换）" class="headerlink" title="（1）C++98引入的四种类型转换（强制类型转换中四种显式类型转换）"></a>（1）C++98引入的四种类型转换（强制类型转换中四种显式类型转换）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">const_cast</span>&lt;T&gt;()    <span class="comment">// 去除const/volatile属性</span></span><br><span class="line"><span class="built_in">dynamic_cast</span>&lt;T&gt;()  <span class="comment">// 用于多态类型的向下转换</span></span><br><span class="line"><span class="built_in">static_cast</span>&lt;T&gt;()   <span class="comment">// 编译时类型转换</span></span><br><span class="line"><span class="built_in">reinterpret_cast</span>&lt;T&gt;() <span class="comment">// 底层重新解释</span></span><br></pre></td></tr></table></figure><h5 id="①reinterpret-cast"><a href="#①reinterpret-cast" class="headerlink" title="①reinterpret_cast"></a>①reinterpret_cast</h5><p>无关类型；不类型检查</p><h5 id="②const-cast"><a href="#②const-cast" class="headerlink" title="②const_cast"></a>②const_cast</h5><p>const、volatile</p><h5 id="③static-cast"><a href="#③static-cast" class="headerlink" title="③static_cast"></a>③static_cast</h5><p>没有类型检查，上行转换安全，下行转换；基本类型转换；表达式转成void；空指针-&gt;目标类型空指针；不能const、volatile</p><h6 id="比C语言中的转换强在哪里"><a href="#比C语言中的转换强在哪里" class="headerlink" title="比C语言中的转换强在哪里"></a>比C语言中的转换强在哪里</h6><p>更加安全；更加明显，能一眼看出是什么类型转换为什么类型，容易找出错误；可以清楚的辨别代码中每个显示的强制转换；可读性更好，能体现程序员的意图</p><h5 id="④dynamic-cast"><a href="#④dynamic-cast" class="headerlink" title="④dynamic_cast"></a>④dynamic_cast</h5><p>有类型检查，上行同static_cast，下行更安全（需要基类有虚函数），不安全会返回空指针</p><h5 id="⑥隐式类型转换"><a href="#⑥隐式类型转换" class="headerlink" title="⑥隐式类型转换"></a>⑥隐式类型转换</h5><p>不需要用户干预，编译器私下进行的类型转换行为</p><p>基本数据类型：小-&gt;大；自定义对象：子-&gt;父；构造函数：只接收一个参数（通过explicit禁止）</p><h3 id="8、引用"><a href="#8、引用" class="headerlink" title="8、引用"></a>8、引用</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>&amp; ref = a;  <span class="comment">// 引用，ref是a的别名</span></span><br></pre></td></tr></table></figure><h3 id="9、变量定义"><a href="#9、变量定义" class="headerlink" title="9、变量定义"></a>9、变量定义</h3><ul><li>C语言：变量必须定义在作用域开头</li><li>C++：变量可以在任何位置定义</li></ul><h2 id="三、C-与Python的区别"><a href="#三、C-与Python的区别" class="headerlink" title="三、C++与Python的区别"></a>三、C++与Python的区别</h2><h3 id="1、语言特性对比"><a href="#1、语言特性对比" class="headerlink" title="1、语言特性对比"></a>1、语言特性对比</h3><table><thead><tr><th align="left">特性</th><th align="left">Python解释语言</th><th align="left">C++编译语言</th></tr></thead><tbody><tr><td align="left">执行方式</td><td align="left">解释执行</td><td align="left">编译执行</td></tr><tr><td align="left">跨平台性</td><td align="left">天然跨平台</td><td align="left">需要针对平台编译</td></tr><tr><td align="left">库函数</td><td align="left">丰富</td><td align="left">相对较少但高效</td></tr><tr><td align="left">效率</td><td align="left">较低</td><td align="left">很高</td></tr><tr><td align="left">代码结构</td><td align="left">缩进</td><td align="left">花括号</td></tr><tr><td align="left">类型系统</td><td align="left">动态类型</td><td align="left">静态强类型</td></tr></tbody></table><h2 id="四、C-与Java的区别"><a href="#四、C-与Java的区别" class="headerlink" title="四、C++与Java的区别"></a>四、C++与Java的区别</h2><h3 id="1、垃圾回收-GC"><a href="#1、垃圾回收-GC" class="headerlink" title="1、垃圾回收(GC)"></a>1、垃圾回收(GC)</h3><h5 id="①-什么是GC"><a href="#①-什么是GC" class="headerlink" title="① 什么是GC"></a>① 什么是GC</h5><p>垃圾回收器在程序运行时自动识别和清理不再使用的对象，避免内存泄漏。</p><h5 id="②-为什么C-没有垃圾回收"><a href="#②-为什么C-没有垃圾回收" class="headerlink" title="② 为什么C++没有垃圾回收"></a>② 为什么C++没有垃圾回收</h5><ul><li>垃圾回收带来额外的空间和时间开销</li><li>需要维护引用计数和标记信息</li><li>单独的GC线程在空闲时进行回收操作</li><li>垃圾回收会使C++不适合底层系统编程</li></ul><h5 id="③-C-的替代方案"><a href="#③-C-的替代方案" class="headerlink" title="③ C++的替代方案"></a>③ C++的替代方案</h5><ul><li>手动内存管理</li><li>智能指针（RAII机制）</li></ul><h3 id="2、Java并发三大特性"><a href="#2、Java并发三大特性" class="headerlink" title="2、Java并发三大特性"></a>2、Java并发三大特性</h3><ul><li><strong>原子性</strong>：操作不可中断</li><li><strong>可见性</strong>：一个线程的修改对其他线程可见</li><li><strong>有序性</strong>：程序执行顺序符合预期</li></ul><h3 id="3、元编程工具对比"><a href="#3、元编程工具对比" class="headerlink" title="3、元编程工具对比"></a>3、元编程工具对比</h3><p>代码操作代码，在编译或运行时动态生成、修改或分析代码逻辑</p><p>如：编译时元编程（C++的模板）；运行时元编程（Java反射）</p><ul><li><strong>Java</strong>：原生支持自定义注解</li><li>**C++**：依赖属性或宏模拟元编程</li><li><strong>Python</strong>：通过装饰器实现元编程</li></ul><p></p><h3 id="4、反射"><a href="#4、反射" class="headerlink" title="4、反射"></a>4、反射</h3><p>程序在运行时检查、修改自身结构或行为的能力</p><p>C++无原生反射：C++强调零成本抽象（不引入运行时开销）；静态类型系统和模板机制已足够强大，反射可能破坏编译期优化。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>C++在性能和控制力方面具有独特优势，适合系统编程、游戏开发、高性能计算等场景。理解C++与其他语言的区别有助于我们根据项目需求选择合适的编程语言。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 编程语言 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
