<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>计算机网络体系结构详解：OSI七层模型</title>
      <link href="/2025/11/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_1/"/>
      <url>/2025/11/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_1/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网络（一）：OSI七层模型"><a href="#计算机网络（一）：OSI七层模型" class="headerlink" title="计算机网络（一）：OSI七层模型"></a>计算机网络（一）：OSI七层模型</h1><h2 id="一、OSI七层网络参考模型"><a href="#一、OSI七层网络参考模型" class="headerlink" title="一、OSI七层网络参考模型"></a>一、OSI七层网络参考模型</h2><p>OSI（Open Systems Interconnection）参考模型是国际标准化组织提出的网络通信概念模型，将网络通信的工作分为7个层次。</p><h3 id="（1）应用层（Application-Layer）-第7层"><a href="#（1）应用层（Application-Layer）-第7层" class="headerlink" title="（1）应用层（Application Layer） - 第7层"></a>（1）应用层（Application Layer） - 第7层</h3><p><strong>作用</strong>：为应用程序提供网络服务接口，直接面向用户。</p><p><strong>主要功能</strong>：</p><ul><li>提供用户接口，支持各种网络服务</li><li>识别通信伙伴的身份和可用性</li><li>同步通信过程</li><li>错误恢复的约定</li></ul><p><strong>典型协议和服务</strong>：</p><ul><li>HTTP&#x2F;HTTPS：网页浏览</li><li>FTP：文件传输</li><li>SMTP&#x2F;POP3&#x2F;IMAP：电子邮件</li><li>DNS：域名解析</li><li>SSH：安全远程登录</li></ul><p><strong>数据单位</strong>：报文（Message）</p><h3 id="（2）表示层（Presentation-Layer）-第6层"><a href="#（2）表示层（Presentation-Layer）-第6层" class="headerlink" title="（2）表示层（Presentation Layer） - 第6层"></a>（2）表示层（Presentation Layer） - 第6层</h3><p><strong>作用</strong>：处理两个通信系统中交换信息的表示方式，确保不同系统能够理解彼此的数据。</p><p><strong>主要功能</strong>：</p><ul><li>数据格式转换（编码、解码）</li><li>数据加密和解密</li><li>数据压缩和解压缩</li><li>字符集转换</li></ul><p><strong>实际应用</strong>：</p><ul><li>JPEG、MPEG等多媒体格式处理</li><li>SSL&#x2F;TLS加密</li><li>ASCII与Unicode转换</li></ul><p><strong>数据单位</strong>：报文（Message）</p><h3 id="（3）会话层（Session-Layer）-第5层"><a href="#（3）会话层（Session-Layer）-第5层" class="headerlink" title="（3）会话层（Session Layer） - 第5层"></a>（3）会话层（Session Layer） - 第5层</h3><p><strong>作用</strong>：建立、管理和终止应用程序之间的会话连接。</p><p><strong>主要功能</strong>：</p><ul><li>建立、维护和终止会话</li><li>会话同步控制</li><li>对话控制（全双工、半双工）</li><li>故障恢复点设置</li></ul><p><strong>实际应用</strong>：</p><ul><li>RPC（远程过程调用）</li><li>NetBIOS会话管理</li><li>断点续传的会话管理</li></ul><p><strong>数据单位</strong>：报文（Message）</p><h3 id="（4）传输层（Transport-Layer）-第4层"><a href="#（4）传输层（Transport-Layer）-第4层" class="headerlink" title="（4）传输层（Transport Layer） - 第4层"></a>（4）传输层（Transport Layer） - 第4层</h3><p><strong>作用</strong>：为端到端通信提供可靠或不可靠的数据传输服务。</p><p><strong>主要功能</strong>：</p><ul><li>端到端的连接管理</li><li>流量控制</li><li>差错控制</li><li>数据分段和重组</li><li>多路复用和解复用</li></ul><p><strong>核心协议</strong>：</p><ul><li><strong>TCP</strong>：面向连接、可靠传输</li><li><strong>UDP</strong>：无连接、高效传输</li></ul><p><strong>数据单位</strong>：段（Segment）</p><h3 id="（5）网络层（Network-Layer）-第3层"><a href="#（5）网络层（Network-Layer）-第3层" class="headerlink" title="（5）网络层（Network Layer） - 第3层"></a>（5）网络层（Network Layer） - 第3层</h3><p><strong>作用</strong>：实现不同网络之间的数据包路由和转发。</p><p><strong>主要功能</strong>：</p><ul><li>逻辑寻址（IP地址）</li><li>路由选择</li><li>拥塞控制</li><li>分组转发</li></ul><p><strong>核心协议</strong>：</p><ul><li>IP（IPv4&#x2F;IPv6）</li><li>ICMP（网络控制消息）</li><li>OSPF、BGP（路由协议）</li></ul><p><strong>网络设备</strong>：路由器（Router）</p><p><strong>数据单位</strong>：包（Packet）</p><h3 id="（6）数据链路层（Data-Link-Layer）-第2层"><a href="#（6）数据链路层（Data-Link-Layer）-第2层" class="headerlink" title="（6）数据链路层（Data Link Layer） - 第2层"></a>（6）数据链路层（Data Link Layer） - 第2层</h3><p><strong>作用</strong>：在相邻节点之间提供可靠的数据帧传输。</p><p><strong>主要功能</strong>：</p><ul><li>物理寻址（MAC地址）</li><li>帧的封装和拆装</li><li>差错检测（CRC校验）</li><li>流量控制</li><li>介质访问控制</li></ul><p><strong>子层划分</strong>：</p><ul><li><strong>LLC</strong>：逻辑链路控制</li><li><strong>MAC</strong>：介质访问控制</li></ul><p><strong>网络设备</strong>：交换机（Switch）、网桥（Bridge）</p><p><strong>数据单位</strong>：帧（Frame）</p><h3 id="（7）物理层（Physical-Layer）-第1层"><a href="#（7）物理层（Physical-Layer）-第1层" class="headerlink" title="（7）物理层（Physical Layer） - 第1层"></a>（7）物理层（Physical Layer） - 第1层</h3><p><strong>作用</strong>：在物理介质上传输原始比特流。</p><p><strong>主要功能</strong>：</p><ul><li>定义机械、电气特性</li><li>比特同步</li><li>线路配置</li><li>数据传输模式</li></ul><p><strong>涉及内容</strong>：</p><ul><li>网线、光纤、无线信号</li><li>接口类型（RJ45、USB）</li><li>信号编码（曼彻斯特编码）</li><li>传输速率</li></ul><p><strong>数据单位</strong>：比特（Bit）</p><h2 id="二、数据封装过程"><a href="#二、数据封装过程" class="headerlink" title="二、数据封装过程"></a>二、数据封装过程</h2><p>数据在网络中传输时的封装过程：</p><pre><code class="text">应用层数据 → 表示层加密/压缩 → 会话层建立会话    ↓传输层添加TCP/UDP头部 → 网络层添加IP头部    ↓数据链路层添加帧头帧尾 → 物理层转换为比特流</code></pre>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OSI模型 </tag>
            
            <tag> 网络协议 </tag>
            
            <tag> 网络体系结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++数据结构(二)：C++11</title>
      <link href="/2025/11/09/C++%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_2/"/>
      <url>/2025/11/09/C++%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_2/</url>
      
        <content type="html"><![CDATA[<h1 id="C-数据结构（二）：C-11"><a href="#C-数据结构（二）：C-11" class="headerlink" title="C++数据结构（二）：C++11"></a>C++数据结构（二）：C++11</h1><h2 id="C-11"><a href="#C-11" class="headerlink" title="C++11"></a>C++11</h2><p>C++11是里程碑式更新，现代C++起点</p><h3 id="1、nullptr代替了NULL"><a href="#1、nullptr代替了NULL" class="headerlink" title="1、nullptr代替了NULL"></a>1、nullptr代替了NULL</h3><p>NULL来自C语言，一般由宏定义实现，而nullptr是C++11的新增关键字</p><p>NULL被定义位整数0，nullptr可以明确区分整型和指针类型，并且可以根据环境自动转换成相应的指针类型，但不会被转换为任何整型，使用不会造成参数传递错误</p><h3 id="2、引入了auto和decltype实现了类型推导"><a href="#2、引入了auto和decltype实现了类型推导" class="headerlink" title="2、引入了auto和decltype实现了类型推导"></a>2、引入了auto和decltype实现了类型推导</h3><h4 id="（1）auto"><a href="#（1）auto" class="headerlink" title="（1）auto"></a>（1）auto</h4><p>auto让编译器根据初值进行类型推演，获取变量类型，所以auto修饰的变量必须拥有初值</p><p>基于范围的for循环</p><h4 id="（2）decltype（表达式）"><a href="#（2）decltype（表达式）" class="headerlink" title="（2）decltype（表达式）"></a>（2）decltype（表达式）</h4><p>选择并返回操作数的类型，编译器只分析表达式的类型，并不实际计算表达式的值，可先不赋值</p><h4 id="（3）decltpye（auto）"><a href="#（3）decltpye（auto）" class="headerlink" title="（3）decltpye（auto）"></a>（3）decltpye（auto）</h4><p>可以用来声明变量以及指示函数返回类型，在使用时会用“&#x3D;”后的表达式代替auto，再根据decltype确定类型</p><h3 id="3、类和结构体中的初始化列表"><a href="#3、类和结构体中的初始化列表" class="headerlink" title="3、类和结构体中的初始化列表"></a>3、类和结构体中的初始化列表</h3><h3 id="4、lambda表达式（匿名函数）"><a href="#4、lambda表达式（匿名函数）" class="headerlink" title="4、lambda表达式（匿名函数）"></a>4、lambda表达式（匿名函数）</h3><p>编写内嵌的匿名函数（没有函数名），可以用来替换独立函数或函数对象。</p><p>每当定义一个lambda函数，编译器会自动生成一个闭包类型的对象。运行时会返回一个闭包类型，其实是一个右值（可以绑定到左值，auto x&#x3D; [] ()&#x2F;&#x2F;priority_queue就需要绑定到左值使用匿名函数）。闭包可以通过传值或引用的方法捕捉其封装作用域内的变量，[]用于捕获，可使用尾置指针（尾置返回类型）来返回指定类型，可以忽略参数和返回值（-&gt;返回类型，当类型复杂或存在多条返回类型时，需显示指定），但是必须包含捕获列表（可以为空但是必须存在）和函数体</p><p>mutable允许修改按值捕获的变量（int x,[x]，可以改变x的副本）</p><h3 id="5、新的容器类型"><a href="#5、新的容器类型" class="headerlink" title="5、新的容器类型"></a>5、新的容器类型</h3><h4 id="（1）forward-list（单向链表）"><a href="#（1）forward-list（单向链表）" class="headerlink" title="（1）forward_list（单向链表）"></a>（1）forward_list（单向链表）</h4><p>list(双向链表)</p><h3 id="6、右值引用和移动语义"><a href="#6、右值引用和移动语义" class="headerlink" title="6、右值引用和移动语义"></a>6、右值引用和移动语义</h3><p>移动语义允许将资源从一个对象“转移”到另一个对象，而非传统拷贝，避免了不必要的深拷贝，右值语义绑定到临时对象，表明可“窃取”其资源。move将左值强制转换为右值引用，表明资源可以被移动</p><h4 id="（1）左值、右值定义"><a href="#（1）左值、右值定义" class="headerlink" title="（1）左值、右值定义"></a>（1）左值、右值定义</h4><p>左值是可以出现在赋值语句左侧的表达式，通常标识一个内存地址，可以取地址</p><p>右值是只能出现在赋值语句右边的表达式，通常表示一个临时值（将亡值（通过盗取其他变量获得内存空间的变量）或纯右值（临时变量和不与对象关联的字面量值））</p><h4 id="（2）左值引用和右值引用"><a href="#（2）左值引用和右值引用" class="headerlink" title="（2）左值引用和右值引用"></a>（2）左值引用和右值引用</h4><p>引用必须立即进行初始化</p><p>左值引用：可以绑定在左值void func(int&amp; x);（左值常引用可以用右值初始化）左值引用是引用类型，但它是一个左值，因为它引用的是一个持久存在的对象。</p><p>右值引用：可以绑定在右值void func(int&amp;&amp; x);</p><h4 id="（3）函数参数"><a href="#（3）函数参数" class="headerlink" title="（3）函数参数"></a>（3）函数参数</h4><p>int com(int a,int&amp;b,int&amp;&amp;c);</p><p>其中a是按值传递，可以接受左值或右值；b是左值引用，只能绑定到左值（具名对象）；c是右值引用，明确接受右值</p><h3 id="7、智能指针"><a href="#7、智能指针" class="headerlink" title="7、智能指针"></a>7、智能指针</h3><p>RAII（资源获取及初始化：在构造函数中分配资源，在析构函数中释放资源）的典型应用，用于自动管理动态内存</p><p>智能指针是一个类，用来存储指向动态分配对象的指针，用类对象来管理动态分配的资源，当类对象声明周期结束后，自动调用析构函数释放资源</p><h4 id="（1）shared-ptr"><a href="#（1）shared-ptr" class="headerlink" title="（1）shared_ptr"></a>（1）shared_ptr</h4><p>使用引用计数器，允许多个智能指针指向同一个对象，每当多一个指针指向该对象时，引用技术加一，减少一个指针则减一，当计数为0会自动释放动态内存分配的资源</p><p>内部的引用计数是线程安全的，但调用对象需要单独加锁</p><p>不能将指针直接赋值给智能指针，一个是类，一个是指针，可以使用构造函数传入指针初始化，可以使用make_share初始化</p><ul><li>需要多个对象共享同一资源时（如缓存、观察者模式）。</li></ul><h4 id="（2）unique-ptr"><a href="#（2）unique-ptr" class="headerlink" title="（2）unique_ptr"></a>（2）unique_ptr</h4><p>独享所有语义权，一个非空总是拥有它所指向的资源，不支持普通的拷贝和复制（不能用在STL标准容器中），支持移动</p><ul><li>明确资源唯一所有权的场景（如工厂模式返回的对象）。</li></ul><h4 id="（3）weak-ptr"><a href="#（3）weak-ptr" class="headerlink" title="（3）weak_ptr"></a>（3）weak_ptr</h4><p>弱引用，引用计数shared_ptr会造成引用成环（指针之间相互指），导致计数无法清零，weaker_ptr是为了配合shared_ptr引入的，当它指向由shared_ptr管理的对象时，只引用不计数，当引用计数的shared_ptr都被销毁时，无论是否有weak_ptr资源都会被释放，所以weak_ptr不保证它指向的内存一定是有效的，在使用之前要检查是否为空（使用lock转化为share_ptr），与普通指针相比，可以检测到所管理的对象是否已经被释放</p><p>提供了一个对管理对象的访问手段</p><ul><li>打破 <code>shared_ptr</code> 的循环引用（如双向链表、观察者模式）。</li></ul><h4 id="（4）auto-ptr"><a href="#（4）auto-ptr" class="headerlink" title="（4）auto_ptr"></a>（4）auto_ptr</h4><p>已经废弃</p><p>解决有异常抛出时发生内存泄露的问题。有拷贝语义，但是拷贝后源对象变无效，可能会引发严重的问题，unique_ptr无拷贝语义，但是有移动语义，这样的错误不会再发生，因为必须使用move进行转移</p><h4 id="（5）手写智能指针类需要实现哪些函数"><a href="#（5）手写智能指针类需要实现哪些函数" class="headerlink" title="（5）手写智能指针类需要实现哪些函数"></a>（5）手写智能指针类需要实现哪些函数</h4><p>构造函数、拷贝构造函数（复制构造函数）、拷贝赋值运算符、析构函数、移动函数</p><h3 id="8、并发支持"><a href="#8、并发支持" class="headerlink" title="8、并发支持"></a>8、并发支持</h3><p>线程、原子操作</p><h3 id="9、变长模板"><a href="#9、变长模板" class="headerlink" title="9、变长模板"></a>9、变长模板</h3>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> C++11 </tag>
            
            <tag> 现代C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++数据结构(一)：与其他编程语言对比</title>
      <link href="/2025/11/09/C++%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_1/"/>
      <url>/2025/11/09/C++%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_1/</url>
      
        <content type="html"><![CDATA[<h1 id="C-数据结构-一-：与其他编程语言的对比"><a href="#C-数据结构-一-：与其他编程语言的对比" class="headerlink" title="C++数据结构(一)：与其他编程语言的对比"></a>C++数据结构(一)：与其他编程语言的对比</h1><h2 id="C-与其他编程语言的区别"><a href="#C-与其他编程语言的区别" class="headerlink" title="C++与其他编程语言的区别"></a>C++与其他编程语言的区别</h2><h3 id="C-语言特性"><a href="#C-语言特性" class="headerlink" title="C++语言特性"></a>C++语言特性</h3><p>C++是一种强类型语言，支持泛型编程，兼具高性能和面向对象特性。</p><h3 id="1、C-与C语言的区别"><a href="#1、C-与C语言的区别" class="headerlink" title="1、C++与C语言的区别"></a>1、C++与C语言的区别</h3><h4 id="（1）编程范式"><a href="#（1）编程范式" class="headerlink" title="（1）编程范式"></a>（1）编程范式</h4><ul><li><strong>C语言</strong>：面向过程编程</li><li>**C++**：面向对象编程，支持类、继承、多态等特性</li></ul><h4 id="（2）类型安全"><a href="#（2）类型安全" class="headerlink" title="（2）类型安全"></a>（2）类型安全</h4><p>类型安全即内存安全，确保程序不会访问未授权的内存区域。</p><ul><li><strong>C语言</strong>：局部上下文类型安全；存在不安全操作如<code>printf</code>、<code>malloc</code>（返回<code>void*</code>）</li><li>**C++**：更强的类型安全；<code>new</code>（返回固定类型）、<code>dynamic_cast</code>、模板等特性</li></ul><h5 id="①-new-delete-与-malloc-free-的区别"><a href="#①-new-delete-与-malloc-free-的区别" class="headerlink" title="① new&#x2F;delete 与 malloc&#x2F;free 的区别"></a>① new&#x2F;delete 与 malloc&#x2F;free 的区别</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++方式</span></span><br><span class="line"><span class="type">int</span>* ptr = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">42</span>);</span><br><span class="line"><span class="keyword">delete</span> ptr;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C方式</span></span><br><span class="line"><span class="type">int</span>* ptr = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">*ptr = <span class="number">42</span>;</span><br><span class="line"><span class="built_in">free</span>(ptr);</span><br></pre></td></tr></table></figure><p><strong>区别</strong>：</p><ul><li><code>new/delete</code>是运算符，<code>malloc/free</code>是函数</li><li><code>new</code>自动计算大小，<code>malloc</code>需要手动计算</li><li><code>new</code>会调用构造函数，<code>delete</code>会调用析构函数</li></ul><h4 id="（3）string替代char"><a href="#（3）string替代char" class="headerlink" title="（3）string替代char*"></a>（3）string替代char*</h4><p><code>std::string</code>对<code>char*</code>进行了封装，包含字符数组、长度等信息，支持动态扩展。</p><p><strong>动态扩展机制</strong>：当空间不足时，申请原空间两倍的新空间，拷贝原内容并添加新内容。</p><p><strong>字符串函数对比</strong>：</p><ul><li><code>strcpy</code> vs <code>strncpy</code> vs <code>memcpy</code></li><li><code>sprintf</code> vs <code>snprintf</code></li><li><code>strlen</code> vs <code>sizeof</code></li></ul><h4 id="（4）异常处理"><a href="#（4）异常处理" class="headerlink" title="（4）异常处理"></a>（4）异常处理</h4><p>C++提供完整的异常处理机制：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;错误信息&quot;</span>);</span><br><span class="line">&#125; <span class="built_in">catch</span> (<span class="type">const</span> std::exception&amp; e) &#123;</span><br><span class="line">    std::cout &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="（5）输入输出流"><a href="#（5）输入输出流" class="headerlink" title="（5）输入输出流"></a>（5）输入输出流</h4><p>C++使用控制态的输入输出流：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">std::cin &gt;&gt; variable;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;输出内容&quot;</span> &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><h4 id="（6）函数重载和模板"><a href="#（6）函数重载和模板" class="headerlink" title="（6）函数重载和模板"></a>（6）函数重载和模板</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数重载</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">double</span> x)</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">max</span><span class="params">(T a, T b)</span> </span>&#123; <span class="keyword">return</span> a &gt; b ? a : b; &#125;</span><br></pre></td></tr></table></figure><h4 id="（7）关键字"><a href="#（7）关键字" class="headerlink" title="（7）关键字"></a>（7）关键字</h4><h5 id="①C-98引入的四种类型转换"><a href="#①C-98引入的四种类型转换" class="headerlink" title="①C++98引入的四种类型转换"></a>①C++98引入的四种类型转换</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">const_cast</span>&lt;T&gt;()    <span class="comment">// 去除const/volatile属性</span></span><br><span class="line"><span class="built_in">dynamic_cast</span>&lt;T&gt;()  <span class="comment">// 用于多态类型的向下转换</span></span><br><span class="line"><span class="built_in">static_cast</span>&lt;T&gt;()   <span class="comment">// 编译时类型转换</span></span><br><span class="line"><span class="built_in">reinterpret_cast</span>&lt;T&gt;() <span class="comment">// 底层重新解释</span></span><br></pre></td></tr></table></figure><h4 id="（8）引用"><a href="#（8）引用" class="headerlink" title="（8）引用"></a>（8）引用</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>&amp; ref = a;  <span class="comment">// 引用，ref是a的别名</span></span><br></pre></td></tr></table></figure><h4 id="（9）变量定义"><a href="#（9）变量定义" class="headerlink" title="（9）变量定义"></a>（9）变量定义</h4><ul><li>C语言：变量必须定义在作用域开头</li><li>C++：变量可以在任何位置定义</li></ul><h3 id="2、C-与Python的区别"><a href="#2、C-与Python的区别" class="headerlink" title="2、C++与Python的区别"></a>2、C++与Python的区别</h3><h4 id="（1）语言特性对比"><a href="#（1）语言特性对比" class="headerlink" title="（1）语言特性对比"></a>（1）语言特性对比</h4><table><thead><tr><th align="left">特性</th><th align="left">Python解释语言</th><th align="left">C++编译语言</th></tr></thead><tbody><tr><td align="left">执行方式</td><td align="left">解释执行</td><td align="left">编译执行</td></tr><tr><td align="left">跨平台性</td><td align="left">天然跨平台</td><td align="left">需要针对平台编译</td></tr><tr><td align="left">库函数</td><td align="left">丰富</td><td align="left">相对较少但高效</td></tr><tr><td align="left">效率</td><td align="left">较低</td><td align="left">很高</td></tr><tr><td align="left">代码结构</td><td align="left">缩进</td><td align="left">花括号</td></tr><tr><td align="left">类型系统</td><td align="left">动态类型</td><td align="left">静态强类型</td></tr></tbody></table><h3 id="3、C-与Java的区别"><a href="#3、C-与Java的区别" class="headerlink" title="3、C++与Java的区别"></a>3、C++与Java的区别</h3><h4 id="（1）垃圾回收-GC"><a href="#（1）垃圾回收-GC" class="headerlink" title="（1）垃圾回收(GC)"></a>（1）垃圾回收(GC)</h4><h5 id="①-什么是GC"><a href="#①-什么是GC" class="headerlink" title="① 什么是GC"></a>① 什么是GC</h5><p>垃圾回收器在程序运行时自动识别和清理不再使用的对象，避免内存泄漏。</p><h5 id="②-为什么C-没有垃圾回收"><a href="#②-为什么C-没有垃圾回收" class="headerlink" title="② 为什么C++没有垃圾回收"></a>② 为什么C++没有垃圾回收</h5><ul><li>垃圾回收带来额外的空间和时间开销</li><li>需要维护引用计数和标记信息</li><li>单独的GC线程在空闲时进行回收操作</li><li>垃圾回收会使C++不适合底层系统编程</li></ul><h5 id="③-C-的替代方案"><a href="#③-C-的替代方案" class="headerlink" title="③ C++的替代方案"></a>③ C++的替代方案</h5><ul><li>手动内存管理</li><li>智能指针（RAII机制）</li></ul><h4 id="（2）Java并发三大特性"><a href="#（2）Java并发三大特性" class="headerlink" title="（2）Java并发三大特性"></a>（2）Java并发三大特性</h4><ul><li><strong>原子性</strong>：操作不可中断</li><li><strong>可见性</strong>：一个线程的修改对其他线程可见</li><li><strong>有序性</strong>：程序执行顺序符合预期</li></ul><h4 id="（3）元编程工具对比"><a href="#（3）元编程工具对比" class="headerlink" title="（3）元编程工具对比"></a>（3）元编程工具对比</h4><ul><li><strong>Java</strong>：原生支持自定义注解</li><li>**C++**：依赖属性或宏模拟元编程</li><li><strong>Python</strong>：通过装饰器实现元编程</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>C++在性能和控制力方面具有独特优势，适合系统编程、游戏开发、高性能计算等场景。理解C++与其他语言的区别有助于我们根据项目需求选择合适的编程语言。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 编程语言 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
