<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>场景题（一）</title>
      <link href="/my_tech_blog.github.io/2025/11/09/%E5%9C%BA%E6%99%AF%E9%A2%98_1/"/>
      <url>/my_tech_blog.github.io/2025/11/09/%E5%9C%BA%E6%99%AF%E9%A2%98_1/</url>
      
        <content type="html"><![CDATA[<h1 id="场景题（一）"><a href="#场景题（一）" class="headerlink" title="场景题（一）"></a>场景题（一）</h1>]]></content>
      
      
      <categories>
          
          <category> 场景题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 场景题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面经（一）：华为</title>
      <link href="/my_tech_blog.github.io/2025/11/09/%E9%9D%A2%E7%BB%8F_1/"/>
      <url>/my_tech_blog.github.io/2025/11/09/%E9%9D%A2%E7%BB%8F_1/</url>
      
        <content type="html"><![CDATA[<h1 id="面经（一）：华为"><a href="#面经（一）：华为" class="headerlink" title="面经（一）：华为"></a>面经（一）：华为</h1>]]></content>
      
      
      <categories>
          
          <category> 面经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面经 </tag>
            
            <tag> 华为 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis(五)：应用四分布式锁</title>
      <link href="/my_tech_blog.github.io/2025/11/09/Redis_5/"/>
      <url>/my_tech_blog.github.io/2025/11/09/Redis_5/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis-五-：应用四分布式锁"><a href="#Redis-五-：应用四分布式锁" class="headerlink" title="Redis(五)：应用四分布式锁"></a>Redis(五)：应用四分布式锁</h1><h4 id="使用redis实现分布式锁"><a href="#使用redis实现分布式锁" class="headerlink" title="使用redis实现分布式锁"></a>使用redis实现分布式锁</h4><p>分布式锁保证同一时间只能有一个应用使用资源</p><p>Redis本身可以被多个客户端访问，是共享存储系统，正好可以用来保护分布式锁，而且读写性能高，可以应对高并发的锁操作情况</p><p>优点：性能好；实现方便（setnx）；避免单点故障</p><p>set有nx参数，可以控制当不存在key时进行插入，存在时不插入；可以使用setnx实现分布式锁，不存在加锁成功，反之失败（原子操作读、检测、设置锁；锁过期时间；值唯一保证能区分不同客户端的加锁操作）</p><p>集群时使用分布式锁的可靠性：Redis提供了红锁，多个Redis节点（至少5个），即使有节点发生了故障，锁变量仍然存在，客户端还是可以完成锁操作。客户端和多个独立节点依次请求申请加锁，当半数Redis节点通过且没有超过锁的有效时间，则加锁成功</p><p>客户端获取当前时间</p><p>依次加锁：SET、NX、EX&#x2F;PX、唯一标识；加锁操作的超时时间（放在节点故障）；超过半数，计算总耗时和锁过期时间</p><h5 id="（1）分布式锁"><a href="#（1）分布式锁" class="headerlink" title="（1）分布式锁"></a>（1）分布式锁</h5><p>分布式锁用于在分布式系统中实现资源的互斥访问，确保同一时间只有一个节点可以访问共享资源。</p><h5 id="（2）其他方式实现分布式锁"><a href="#（2）其他方式实现分布式锁" class="headerlink" title="（2）其他方式实现分布式锁"></a>（2）其他方式实现分布式锁</h5><h6 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h6><p>唯一约束或者乐观锁（CAS类：内存地址、预期原值、新值（是否被更改）-&gt;ABA问题时间戳）</p><h6 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h6><p>ZooKeeper 是一个分布式的，开放源码的分布式应用程序协同服务。</p><p>没法客户端在zookeeper上创建一个临时顺序节点，客户端监视比自己序号小的节点，如果发现比自己序号小的节点已经删除，说明可以获取锁</p><h5 id="（3）解决问题"><a href="#（3）解决问题" class="headerlink" title="（3）解决问题"></a>（3）解决问题</h5><p>Redis并发竞争Key：多个系统同时对Key进行操作，但是最后执行的顺序和我们期望的不同，导致结果不同</p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 分布式锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis(四)：应用三消息队列</title>
      <link href="/my_tech_blog.github.io/2025/11/09/Redis_4/"/>
      <url>/my_tech_blog.github.io/2025/11/09/Redis_4/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis-四-：应用三消息队列（mq"><a href="#Redis-四-：应用三消息队列（mq" class="headerlink" title="Redis(四)：应用三消息队列（mq)"></a>Redis(四)：应用三消息队列（mq)</h1><p>消息队列是中间件，提供应用间的异步通信功能，解耦生产者和消费者</p><h4 id="为什么Redis可以作为消息队列"><a href="#为什么Redis可以作为消息队列" class="headerlink" title="为什么Redis可以作为消息队列"></a>为什么Redis可以作为消息队列</h4><p>高效的内存数据结构和原子操作特性</p><p>高性能（内存操作，单线程）持久化（RDB、AOF）原子性（单命令、lua脚本）简单拓扑（无需额外组件）</p><h4 id="Redis作为MQ的优劣"><a href="#Redis作为MQ的优劣" class="headerlink" title="Redis作为MQ的优劣"></a>Redis作为MQ的优劣</h4><h5 id="（1）优点"><a href="#（1）优点" class="headerlink" title="（1）优点"></a>（1）优点</h5><p>简单易用，无需额外组件</p><p>高性能，低延迟</p><p>支持发布&#x2F;订阅（Pub&#x2F;Sub）和列表（List:PUSH&#x2F;RPOP）两种形式</p><h5 id="（2）缺点"><a href="#（2）缺点" class="headerlink" title="（2）缺点"></a>（2）缺点</h5><p>无消息持久化：可以设置</p><p>无完善的消息确认机制（仅stream支持，Redis 5+）</p><p>无死信队列等高级特性（死信队列（DLQ）是消息系统中用于存储处理失败消息的特殊队列，当消息满足特定条件时会被自动路由到DLQ）</p><p>集群模式下功能受限（数据分片问题，不同key可能分布在不同的集群节点；订阅者需连接到所有相关节点）</p><h4 id="Redis-MQ-的用途"><a href="#Redis-MQ-的用途" class="headerlink" title="Redis MQ 的用途"></a>Redis MQ 的用途</h4><p>异步任务处理；应用解耦；流量削峰；事件通知</p><p>简单任务队列；实时性要求高；轻量级Pub&#x2F;Sub</p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20250423113259236.png" alt="image-20250423113259236" style="zoom:67%;" /><h4 id="与专业MQ对比"><a href="#与专业MQ对比" class="headerlink" title="与专业MQ对比"></a>与专业MQ对比</h4><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20250423112257785.png" alt="image-20250423112257785" style="zoom:67%;" /><p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20250423112339032.png" alt="image-20250423112339032" style="zoom:50%;" /><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20250423112407921.png" alt="image-20250423112407921" style="zoom: 50%;" /></p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 消息队列 </tag>
            
            <tag> mq </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis(三)：应用二会话管理</title>
      <link href="/my_tech_blog.github.io/2025/11/09/Redis_3/"/>
      <url>/my_tech_blog.github.io/2025/11/09/Redis_3/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis-三-：应用二会话管理"><a href="#Redis-三-：应用二会话管理" class="headerlink" title="Redis(三)：应用二会话管理"></a>Redis(三)：应用二会话管理</h1><p>会话存储：分布式系统共享Session</p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 会话管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis(二)：应用一缓存</title>
      <link href="/my_tech_blog.github.io/2025/11/09/Redis_2/"/>
      <url>/my_tech_blog.github.io/2025/11/09/Redis_2/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis-二-：应用一缓存"><a href="#Redis-二-：应用一缓存" class="headerlink" title="Redis(二)：应用一缓存"></a>Redis(二)：应用一缓存</h1><h2 id="一、缓存和数据库双写时数据一致性"><a href="#一、缓存和数据库双写时数据一致性" class="headerlink" title="一、缓存和数据库双写时数据一致性"></a>一、缓存和数据库双写时数据一致性</h2><p>缓存与数据库双写</p><p>读请求与写请求串行化：吞吐量大大降低</p><p>异步缓存、写穿透缓存（可以批量更新）</p><h5 id="（1）预留缓存模式"><a href="#（1）预留缓存模式" class="headerlink" title="（1）预留缓存模式"></a>（1）预留缓存模式</h5><p>读先读取缓存，如果缓存中没有再去读取数据库，读取数据库中的结果写入缓存，再返回响应；写时先将缓存删除，再写入数据库</p><p>为什么会出现数据不一致：并发读写访问时，缓存和数据库相互交叉执行</p><h6 id="单库情况下"><a href="#单库情况下" class="headerlink" title="单库情况下"></a>单库情况下</h6><p>操作时序，逻辑处理，导致读取脏数据</p><p>一个写操作和一个读操作，写操作先删除缓存，由于某种原因导致卡顿，没有写入数据库，读操作进行读取，缓存中没有，去数据库读到了脏数据并写入了缓存，此时写操作修改了数据库，但是缓存中一直是脏数据（与源数据不一致的过期或错误数据）</p><h6 id="主从同步，读写分离情况下"><a href="#主从同步，读写分离情况下" class="headerlink" title="主从同步，读写分离情况下"></a>主从同步，读写分离情况下</h6><p>主从同步时延导致读从库产生脏数据</p><p>写操作删除了缓存并写入了主数据库，但是还没有完成主从同步，读操作读缓存没有结果，到从数据库查询，读到脏数据写入缓存并返回</p><h5 id="（2）Cache-Aside-Patter（旁路缓存，推荐方案）"><a href="#（2）Cache-Aside-Patter（旁路缓存，推荐方案）" class="headerlink" title="（2）Cache Aside Patter（旁路缓存，推荐方案）"></a>（2）Cache Aside Patter（旁路缓存，推荐方案）</h5><p>先更新数据库，然后删除缓存</p><p>对缓存的操作速度快，读到脏数据概率低</p><h6 id="为什么是删除缓存不是改变缓存"><a href="#为什么是删除缓存不是改变缓存" class="headerlink" title="为什么是删除缓存不是改变缓存"></a>为什么是删除缓存不是改变缓存</h6><p>避免无效更新：用到缓存才算缓存</p><p>复杂数据一致性：需处理关联函数</p><h6 id="数据不一致解决方案"><a href="#数据不一致解决方案" class="headerlink" title="数据不一致解决方案"></a>数据不一致解决方案</h6><p>删除缓存失败导致数据不一致</p><h6 id="对缓存命中率有严格要求"><a href="#对缓存命中率有严格要求" class="headerlink" title="对缓存命中率有严格要求"></a>对缓存命中率有严格要求</h6><p>更新缓存+分布式锁</p><p>更新缓存+较短过期时间</p><h5 id="（3）预留缓存和旁路缓存比较与选择"><a href="#（3）预留缓存和旁路缓存比较与选择" class="headerlink" title="（3）预留缓存和旁路缓存比较与选择"></a>（3）预留缓存和旁路缓存比较与选择</h5><p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20250330213743271.png" alt="image-20250330213743271"></p><h2 id="二、缓存淘汰"><a href="#二、缓存淘汰" class="headerlink" title="二、缓存淘汰"></a>二、缓存淘汰</h2><h5 id="（1）缓存双淘汰法"><a href="#（1）缓存双淘汰法" class="headerlink" title="（1）缓存双淘汰法"></a>（1）缓存双淘汰法</h5><p>先淘汰缓存</p><p>再写入数据库</p><p>往总线中发送一个淘汰消息，发送完立即返回。存在异步定时消费者在拿到消息1s后淘汰缓存，删除脏数据</p><h5 id="（2）异步淘汰缓存-基于binlog的最终一致性方案"><a href="#（2）异步淘汰缓存-基于binlog的最终一致性方案" class="headerlink" title="（2）异步淘汰缓存(基于binlog的最终一致性方案)"></a>（2）异步淘汰缓存(基于binlog的最终一致性方案)</h5><p>通过数据库变更事件驱动缓存更新，而非依赖业务代码主动操作缓存，无需关心缓存</p><p>不在业务先操作缓存内容，新增一个线下的异步淘汰缓存模块，MySQL记录binlog，解析工具捕获变更并发送到消息队列，缓存消费者监听消息队列，更新Redis</p><h2 id="三、淘汰"><a href="#三、淘汰" class="headerlink" title="三、淘汰"></a>三、淘汰</h2><h3 id="过期时间"><a href="#过期时间" class="headerlink" title="过期时间"></a>过期时间</h3><p>传统数据库自己判断过期</p><h4 id="1、过期时间设置方案"><a href="#1、过期时间设置方案" class="headerlink" title="1、过期时间设置方案"></a>1、过期时间设置方案</h4><h5 id="（1）定期删除"><a href="#（1）定期删除" class="headerlink" title="（1）定期删除"></a>（1）定期删除</h5><p>通常是每100ms检查一次，随机挑选数据查看是否过期，过期则删除</p><p>维护大量key</p><h5 id="（2）惰性删除"><a href="#（2）惰性删除" class="headerlink" title="（2）惰性删除"></a>（2）惰性删除</h5><p>过期时不直接删除，当再次使用到该数据，才会检查到过期并删除</p><p>每次都要判断，且浪费内存</p><h5 id="（3）定期和惰性一定能保证删除数据吗，如果不能Redis会怎么应对"><a href="#（3）定期和惰性一定能保证删除数据吗，如果不能Redis会怎么应对" class="headerlink" title="（3）定期和惰性一定能保证删除数据吗，如果不能Redis会怎么应对"></a>（3）定期和惰性一定能保证删除数据吗，如果不能Redis会怎么应对</h5><p>没有定期删除也没有再次请求，内存会越来越多</p><p>进行内存淘汰机制</p><h4 id="2、内存淘汰机制"><a href="#2、内存淘汰机制" class="headerlink" title="2、内存淘汰机制"></a>2、内存淘汰机制</h4><p>保证数据是热点数据</p><h5 id="（1）no-eviction-驱逐"><a href="#（1）no-eviction-驱逐" class="headerlink" title="（1）no-eviction(驱逐)"></a>（1）no-eviction(驱逐)</h5><p>不淘汰内存，内存不足时返回错误</p><h5 id="（2）allkeys-LRU"><a href="#（2）allkeys-LRU" class="headerlink" title="（2）allkeys-LRU"></a>（2）allkeys-LRU</h5><p>所有键中最近最少使用</p><h5 id="（3）allkeys-random"><a href="#（3）allkeys-random" class="headerlink" title="（3）allkeys-random"></a>（3）allkeys-random</h5><p>所有键中随机淘汰</p><h5 id="（4）volatile-LRU"><a href="#（4）volatile-LRU" class="headerlink" title="（4）volatile-LRU"></a>（4）volatile-LRU</h5><p>设置了过期时间的键中淘汰最近最少使用</p><h5 id="（5）volatile-ttl"><a href="#（5）volatile-ttl" class="headerlink" title="（5）volatile-ttl"></a>（5）volatile-ttl</h5><p>过期键中剩余时间最短的键</p><h5 id="（6）volatile-random"><a href="#（6）volatile-random" class="headerlink" title="（6）volatile-random"></a>（6）volatile-random</h5><p>从已过期的数据集中任意选择数据淘汰</p><p>如果没有设置expire的key，不满足先决条件，那么volatile和noeviction基本一致</p><h2 id="四、问题"><a href="#四、问题" class="headerlink" title="四、问题"></a>四、问题</h2><h4 id="平常使用Redis可能会碰见什么问题"><a href="#平常使用Redis可能会碰见什么问题" class="headerlink" title="平常使用Redis可能会碰见什么问题"></a>平常使用Redis可能会碰见什么问题</h4><h5 id="（1）缓冲雪崩"><a href="#（1）缓冲雪崩" class="headerlink" title="（1）缓冲雪崩"></a>（1）缓冲雪崩</h5><p>当大量数据同一时间失效，如果此时有大量用户请求，都无法在Redis中处理，全部直接访问数据库，从而导致数据库压力大增，严重的会造成数据库宕机，从而造成一系列连锁反应，造成系统崩溃</p><h6 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h6><p>事前：将缓存过期时间随机打乱；缓存不过期：通过后台服务来更新缓存数据；选择合适的内存淘汰策略多级缓存</p><p>事中：限流降级；加锁或者队列控制访问数据库的线程数量</p><p>事后：持久化机制恢复缓存</p><h5 id="（2）缓冲击穿"><a href="#（2）缓冲击穿" class="headerlink" title="（2）缓冲击穿"></a>（2）缓冲击穿</h5><p>当热点数据失效，又有大量请求访问该热点数据，直接访问数据库，数据库被高并发请求冲垮</p><h6 id="解决-1"><a href="#解决-1" class="headerlink" title="解决"></a>解决</h6><p>互斥锁方案</p><p>不给热点数据设置过期时间</p><h5 id="（3）缓存穿透"><a href="#（3）缓存穿透" class="headerlink" title="（3）缓存穿透"></a>（3）缓存穿透</h5><p>大量请求访问的数据既不在缓存也不在数据库（业务误操作；黑客恶意攻击）</p><h6 id="解决-2"><a href="#解决-2" class="headerlink" title="解决"></a>解决</h6><p>非法请求限制</p><p>缓存空对象：设置空值或默认值（数据变化频繁且实时性高，需要缓存空间多，代码维护简单）</p><p>布隆过滤器（数据变化不频繁且实时性低，需要缓存空间少，代码维护复杂）</p><h6 id="布隆过滤器的实现原理"><a href="#布隆过滤器的实现原理" class="headerlink" title="布隆过滤器的实现原理"></a>布隆过滤器的实现原理</h6><p>使用多个哈希函数和位数组（存储的是所有插入元素的哈希标记的并集）存储哈希结果，快速判断目标数据是否存在；减小误判：增加哈希函数数量、位数组长度；选择合适的哈希函数；动态调整布隆过滤器（根据集合中数组元素）；多次哈希缺点：计算开销增加，位数组填充过快，增加误判率</p><h6 id="布隆过滤器的应用场景"><a href="#布隆过滤器的应用场景" class="headerlink" title="布隆过滤器的应用场景"></a>布隆过滤器的应用场景</h6><p>缓存穿透防护、爬虫URL去重（避免重复抓取相同的网页）、数据库查询优化</p><h5 id="（4）缓存预热"><a href="#（4）缓存预热" class="headerlink" title="（4）缓存预热"></a>（4）缓存预热</h5><p>系统启动时提前将高频数据加载到缓存</p><h5 id="（5）缓存更新"><a href="#（5）缓存更新" class="headerlink" title="（5）缓存更新"></a>（5）缓存更新</h5><p>定期删除和惰性删除</p><p>写时删除（更新数据时同时更新缓存）；消息队列通知</p><h5 id="（6）缓存降级"><a href="#（6）缓存降级" class="headerlink" title="（6）缓存降级"></a>（6）缓存降级</h5><p>分级策略：（全局降级）返回静态默认值；（部分降级）核心字段保留；（读旧数据）允许返回略微过期的数据</p><p>保证核心服务可用，即使是有损的</p><h5 id="（7）超卖"><a href="#（7）超卖" class="headerlink" title="（7）超卖"></a>（7）超卖</h5><p>在电商等高并发情况下，商品库存被多个用户同时购买，导致实际销售量超过库存（并发操作缺乏有效的库存控制机制）</p><p>解决：分布式锁+lua脚本</p><h6 id="单独只有锁"><a href="#单独只有锁" class="headerlink" title="单独只有锁"></a>单独只有锁</h6><p>锁粒度问题（只对关键资源加锁）；锁超时问题（设置自动过期时间）；非原子操作（使用lua脚本）</p><h6 id="lua脚本"><a href="#lua脚本" class="headerlink" title="lua脚本"></a>lua脚本</h6><p>lua是一种轻量级脚本语言，被嵌入到Redis中，整个lua脚本在Redis中会当做一个原子操作执行，在执行过程中不会被打断</p><h2 id="五、Map与Memcache"><a href="#五、Map与Memcache" class="headerlink" title="五、Map与Memcache"></a>五、Map与Memcache</h2><h3 id="一）Map"><a href="#一）Map" class="headerlink" title="(一）Map"></a>(一）Map</h3><h4 id="1、C-中Map也是一种缓存型数据结构，为什么不用Map，而选择Redis做缓存"><a href="#1、C-中Map也是一种缓存型数据结构，为什么不用Map，而选择Redis做缓存" class="headerlink" title="1、C++中Map也是一种缓存型数据结构，为什么不用Map，而选择Redis做缓存"></a>1、C++中Map也是一种缓存型数据结构，为什么不用Map，而选择Redis做缓存</h4><p>Map属于本地缓存，具有轻量级、速度快的特点，但是生命周期随程序销毁而结束，且存在多个实例情况下，每个实例都要各自保存一份缓存，缓存不具有一致性</p><h4 id="2、Redis与Map区别"><a href="#2、Redis与Map区别" class="headerlink" title="2、Redis与Map区别"></a>2、Redis与Map区别</h4><p>分布式</p><h3 id="（二）Memcache"><a href="#（二）Memcache" class="headerlink" title="（二）Memcache"></a>（二）Memcache</h3><p>Redis和Memcache是分布式缓存，在多实例的情况下，各实例共享一份缓存，缓存具有一致性；但是需要保持高可用，架构复杂</p><h4 id="1、Redis与Memcache区别"><a href="#1、Redis与Memcache区别" class="headerlink" title="1、Redis与Memcache区别"></a>1、Redis与Memcache区别</h4><p>存储方式：Memcache全部存储在内存，当断电数据全没，没有持久性；Redis有一部分存储在硬盘上，保证了持久性，且支持RDB快照和AOF日志</p><p>数据结构：Memcache只支持String；Redis支持字符串、哈希表、链表、集合、有序集合</p><p>底层模式：Memcache是多线程，使用非阻塞I&#x2F;O；Redis是单线程，使用多路复用I&#x2F;O，VM模式（已废弃：Redis 在内存不足时，将不常用的 Value交换到磁盘上，而Key 和热点 Value仍保留在内存中的机制）</p><p>集群：Memcache无原生集群，依赖客户端分片，Redis支持原生集群模式，可水平扩展</p><p>Value值不同：Redis最大可以达到512MB，Memcache只有1MB</p><h5 id="（1）Redis为什么是单线程不是多线程"><a href="#（1）Redis为什么是单线程不是多线程" class="headerlink" title="（1）Redis为什么是单线程不是多线程"></a>（1）Redis为什么是单线程不是多线程</h5><p>Redis是基于内存，CPU不会成为瓶颈，瓶颈一般是内存大小或者网络带宽，单线程实现更容易</p><h5 id="（2）为什么单线程Redis这么快"><a href="#（2）为什么单线程Redis这么快" class="headerlink" title="（2）为什么单线程Redis这么快"></a>（2）为什么单线程Redis这么快</h5><p>使用内存；单线程，避免了线程上下文切换；使用I&#x2F;O多路复用</p><h5 id="（3）介绍Redis线程模型"><a href="#（3）介绍Redis线程模型" class="headerlink" title="（3）介绍Redis线程模型"></a>（3）介绍Redis线程模型</h5><p>多个Socket</p><p>I&#x2F;O多路复用：监听多个Socket，向文件事件分派器传送已经产生了事件的Socket</p><p>文件事件分派器</p><p>文件事件处理器（单线程）</p><h5 id="（4）Memcache为什么使用多线程"><a href="#（4）Memcache为什么使用多线程" class="headerlink" title="（4）Memcache为什么使用多线程"></a>（4）Memcache为什么使用多线程</h5><p>Memcache的定位是纯缓存服务器，追求机制的读写性能，核心诉求是超高吞吐量与低延迟</p><h4 id="2、Redis的优势"><a href="#2、Redis的优势" class="headerlink" title="2、Redis的优势"></a>2、Redis的优势</h4><h5 id="（1）数据结构丰富"><a href="#（1）数据结构丰富" class="headerlink" title="（1）数据结构丰富"></a>（1）数据结构丰富</h5><h6 id="①字符串"><a href="#①字符串" class="headerlink" title="①字符串"></a>①字符串</h6><p>简单动态字符串</p><h6 id="②哈希"><a href="#②哈希" class="headerlink" title="②哈希"></a>②哈希</h6><p>压缩列表、哈希表</p><h6 id="③集合"><a href="#③集合" class="headerlink" title="③集合"></a>③集合</h6><p>整数集合、哈希表</p><h6 id="④有序集合"><a href="#④有序集合" class="headerlink" title="④有序集合"></a>④有序集合</h6><p>压缩列表、跳跃表+哈希表</p><h6 id="⑤列表-链表"><a href="#⑤列表-链表" class="headerlink" title="⑤列表&#x2F;链表"></a>⑤列表&#x2F;链表</h6><p>压缩列表、双向列表、快速列表</p><p>消息队列</p><h5 id="（2）速度快"><a href="#（2）速度快" class="headerlink" title="（2）速度快"></a>（2）速度快</h5><p>单线程</p><h5 id="（3）持久化"><a href="#（3）持久化" class="headerlink" title="（3）持久化"></a>（3）持久化</h5><p>RDB、AOF</p><h5 id="（4）集群"><a href="#（4）集群" class="headerlink" title="（4）集群"></a>（4）集群</h5><h2 id="六、定义"><a href="#六、定义" class="headerlink" title="六、定义"></a>六、定义</h2><h3 id="（一）热点数据和冷数据"><a href="#（一）热点数据和冷数据" class="headerlink" title="（一）热点数据和冷数据"></a>（一）热点数据和冷数据</h3><p>访问较多的是热点数据，访问次数很少的是冷数据；热点数据一般存储在内存中，冷数据一般存储在硬盘中（没有等到再次访问就已经被挤出内存，不仅占用内存空间而且价值不大）</p><p>数据更新前至少读取两次缓存才有意义</p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis(一)：Redis</title>
      <link href="/my_tech_blog.github.io/2025/11/09/Redis_1/"/>
      <url>/my_tech_blog.github.io/2025/11/09/Redis_1/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis-二-：Redis"><a href="#Redis-二-：Redis" class="headerlink" title="Redis(二)：Redis"></a>Redis(二)：Redis</h1><h2 id="一、特点"><a href="#一、特点" class="headerlink" title="一、特点"></a>一、特点</h2><p>Redis是一个数据库，与传统数据库不同，它存储在内存中</p><h3 id="（二）Redis优点"><a href="#（二）Redis优点" class="headerlink" title="（二）Redis优点"></a>（二）Redis优点</h3><p>访问速度快</p><p>数据类型丰富</p><p>支持事务</p><p>特性丰富：可用于缓存，消息按key设置过期时间，过期自动删除</p><h2 id="二、问题"><a href="#二、问题" class="headerlink" title="二、问题"></a>二、问题</h2><h3 id="（一）有MySQL不就够了吗，为什么要使用Redis这种新的数据库"><a href="#（一）有MySQL不就够了吗，为什么要使用Redis这种新的数据库" class="headerlink" title="（一）有MySQL不就够了吗，为什么要使用Redis这种新的数据库"></a>（一）有MySQL不就够了吗，为什么要使用Redis这种新的数据库</h3><h4 id="1、高性能"><a href="#1、高性能" class="headerlink" title="1、高性能"></a>1、高性能</h4><p>速度快</p><h4 id="2、高并发"><a href="#2、高并发" class="headerlink" title="2、高并发"></a>2、高并发</h4><p>缓存可以承受的请求是远大于直接访问数据库</p><h4 id="3、用途"><a href="#3、用途" class="headerlink" title="3、用途"></a>3、用途</h4><h5 id="（1）缓存"><a href="#（1）缓存" class="headerlink" title="（1）缓存"></a>（1）缓存</h5><p>加速热点数据访问</p><h5 id="（2）会话存储"><a href="#（2）会话存储" class="headerlink" title="（2）会话存储"></a>（2）会话存储</h5><p>分布式系统共享Session</p><h5 id="（3）消息队列mq"><a href="#（3）消息队列mq" class="headerlink" title="（3）消息队列mq"></a>（3）消息队列mq</h5><h5 id="（4）分布式锁"><a href="#（4）分布式锁" class="headerlink" title="（4）分布式锁"></a>（4）分布式锁</h5><h5 id="（5）其他"><a href="#（5）其他" class="headerlink" title="（5）其他"></a>（5）其他</h5><p>实时排行榜</p><p>计数器</p><p>去重</p><h3 id="（二）Redis的高可用和高并发是如何保证的"><a href="#（二）Redis的高可用和高并发是如何保证的" class="headerlink" title="（二）Redis的高可用和高并发是如何保证的"></a>（二）Redis的高可用和高并发是如何保证的</h3><h4 id="1、Redis-Replication（复制）"><a href="#1、Redis-Replication（复制）" class="headerlink" title="1、Redis Replication（复制）"></a>1、Redis Replication（复制）</h4><p>读高并发</p><h4 id="2、哨兵"><a href="#2、哨兵" class="headerlink" title="2、哨兵"></a>2、哨兵</h4><p>高可用：故障转移、主备切换</p><h4 id="3、集群"><a href="#3、集群" class="headerlink" title="3、集群"></a>3、集群</h4><p>写、读高并发；高可用：主备切换</p><h4 id="4、"><a href="#4、" class="headerlink" title="4、"></a>4、</h4><p>无磁盘化复制；过期key处理；heartbeat；异步复制；全量复制；增量复制</p><p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20250330182223444.png" alt="image-20250330182223444"></p><h3 id="（三）Redis-单机崩溃"><a href="#（三）Redis-单机崩溃" class="headerlink" title="（三）Redis 单机崩溃"></a>（三）Redis 单机崩溃</h3><h4 id="1、持久化"><a href="#1、持久化" class="headerlink" title="1、持久化"></a>1、持久化</h4><p>把内存中的数据写入到硬盘，当重启Redis后再将硬盘文件重新加载到内存，达到恢复数据的目的</p><h5 id="（1）AOF文件"><a href="#（1）AOF文件" class="headerlink" title="（1）AOF文件"></a>（1）AOF文件</h5><p>将会改变Redis中数据命令写入在硬盘中的AOF文件，为了兼顾数据和写入性能，可以先写入缓冲区，几秒同步一次AOF，重启时会回放AOF文件中命令恢复数据</p><h6 id="AOF重写"><a href="#AOF重写" class="headerlink" title="AOF重写"></a>AOF重写</h6><p>产生一个更小的AOF，仅包含恢复当前数据所需的最小指令</p><p>在新建一个AOF文件时，将命令写入原AOF缓冲区和重写缓冲区，创建完毕后将缓冲区内容写到新AOF文件末尾，用新AOF文件替换旧的AOF文件</p><h5 id="（2）RDB快照"><a href="#（2）RDB快照" class="headerlink" title="（2）RDB快照"></a>（2）RDB快照</h5><p>生成内存数据的二进制快照，通过快照获得存储在内存中的数据在某个时间点上的副本，适合备份和快速恢复</p><p>Redis主从结构可以通过对快照进行备份，复制到其他服务器创建服务器副本</p><h5 id="（3）混合持久化"><a href="#（3）混合持久化" class="headerlink" title="（3）混合持久化"></a>（3）混合持久化</h5><p>把RDB（RDB 二进制数据头）写入AOF开头（AOF 增量命令日志）</p><p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20250329211108968.png" alt="image-20250329211108968"></p><h4 id="2、预防措施"><a href="#2、预防措施" class="headerlink" title="2、预防措施"></a>2、预防措施</h4><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20250503192620154.png" alt="image-20250503192620154" style="zoom:67%;" /><h5 id="（1）主从复制"><a href="#（1）主从复制" class="headerlink" title="（1）主从复制"></a>（1）主从复制</h5><p>高并发读，读写分离，横向扩展读能力</p><p>主节点崩溃后可以切换从节点继续提供服务</p><h6 id="Redis是怎么主从同步"><a href="#Redis是怎么主从同步" class="headerlink" title="Redis是怎么主从同步"></a>Redis是怎么主从同步</h6><p>①全量同步</p><p>主服务器将数据全部生成RDB发送给从服务器（先写入磁盘再加载到内存），后续命令记录在repl_backlog&#x2F;rɛpl ˈbæk.lɒɡ&#x2F;（复制缓冲区），逐个发送给slave</p><p>从服务器第一次连接主服务器；从服务器断开时间过长，导致主服务器的repl_backlog缓冲区中的数据被覆盖，无法进行增量同步。</p><p>②增量同步</p><p>将setoff之后的日志发送给从服务器</p><p>主服务器的repl_backlog缓冲区中仍然保存了从服务器断开期间的写命令。</p><h6 id="断点续传"><a href="#断点续传" class="headerlink" title="断点续传"></a>断点续传</h6><p>主节点内存中维护一个backlog，主从节点都会保存一个offset，网络连接断掉了就会从offset开始复制</p><h5 id="（2）哨兵模式"><a href="#（2）哨兵模式" class="headerlink" title="（2）哨兵模式"></a>（2）哨兵模式</h5><p>高可用，不保证数据0丢失</p><p>至少3个哨兵节点，确保故障检测和选举的可靠性</p><h6 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h6><p>集群监控；故障消息通知管理员；自动故障转移；通知客户端新主节点地址</p><h6 id="不是3个哨兵节点"><a href="#不是3个哨兵节点" class="headerlink" title="不是3个哨兵节点"></a>不是3个哨兵节点</h6><p>①2个，quorum&#x3D;1（法定人数），一个哨兵节点认为宕机就可用切换，选举一个哨兵进行故障转移，但是majority&#x3D;2（n&#x2F;2+1），如果整个系统（包括进程和哨兵）宕机，那么哨兵只剩下一个，无法选举哨兵进行故障转移</p><h6 id="3个哨兵节点"><a href="#3个哨兵节点" class="headerlink" title="3个哨兵节点"></a>3个哨兵节点</h6><p>健壮性</p><p>①避免误判（故障检测可靠性）</p><p>主观下线：有一个哨兵觉得主节点宕机（ping超过了设定时间）</p><p>客观下线：quorum个哨兵判断同意，分布式选举问题</p><p>转换机制：</p><p>②避免脑裂</p><p>多个节点同时认为自己是主节点，数据不一致</p><p>③故障转移可靠性</p><p>故障转移需要多个哨兵节点协作完成，包括选举新的主节点和更新配置。</p><h6 id="哨兵主备切换的数据丢失问题"><a href="#哨兵主备切换的数据丢失问题" class="headerlink" title="哨兵主备切换的数据丢失问题"></a>哨兵主备切换的数据丢失问题</h6><p>①异步复制</p><p>主从节点之间的复制是异步的，还没来得及复制主节点就宕机了，部分数据丢失</p><p>②脑裂</p><p>主节点脱离网络，选举出了新主节点，客户端的主节点没有改变骗，原主节点恢复，客户端继续向原主节点发送数据，当改变主节点，原主节点变为从节点，数据清空并进行同步，丢失了这一过程中的数据</p><p>③解决</p><p>min-slaves-to-write n：至少有n个节点数据复制和同步的延迟不能超过10秒，否则主节点不再接受请求</p><h6 id="自动发现机制"><a href="#自动发现机制" class="headerlink" title="自动发现机制"></a>自动发现机制</h6><p>发送消息；监听频道；交换对主节点的监控配置</p><h6 id="从节点配置的自动纠正"><a href="#从节点配置的自动纠正" class="headerlink" title="从节点配置的自动纠正"></a>从节点配置的自动纠正</h6><p>纠正从节点配置（成为主节点候选保证复制现有数据；保证故障转移之后从节点连接正确主节点）</p><h6 id="选举算法"><a href="#选举算法" class="headerlink" title="选举算法"></a>选举算法</h6><p>考察从节点：和主节点的断开时间（不能大于10倍down-after-milliseconds）、优先级（priority越低，优先级越高）、offser（靠后）、run id（小）</p><h6 id="configuration"><a href="#configuration" class="headerlink" title="configuration"></a>configuration</h6><p>执行切换的哨兵会从新主节点得到configuration epoch，就是version号</p><p>configuration传播：哨兵完成切换后会生成新的主节点配置，然后同步给其他哨兵，根据version号更新主节点配置</p><h5 id="（3）集群模式"><a href="#（3）集群模式" class="headerlink" title="（3）集群模式"></a>（3）集群模式</h5><p>高并发写，数据分片（多个主节点）；高可用，每个主节点都有从节点，集群内置故障转移，无需哨兵；不支持跨节点事务</p><p>单个Redis内存不足时，使用集群进行分片存储</p><p>将数据分片存储在多台机器，提高可用性和扩展性</p><h6 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h6><p>集群元数据的维护有两种方式：集中式、Gossip，Redis cluster&#x2F;ˈklʌstər&#x2F;采用集中式</p><p>①集中式</p><p>集群元数据集中存储在一个节点上。</p><p>典型代表：大数据领域的storm&#x2F;stɔːrm&#x2F;（分布式大数据实时计算引擎），底层基于zookeeper（分布式协调中间件）对所有元数据进行存储维护</p><p>好处：时效性好</p><p>缺点：存储压力大</p><p>②Gossip&#x2F;ˈɡɒsɪp&#x2F;</p><p>所有节点都持有一份元数据，当某个节点元数据改变，就不断将元数据发送给其他节点，其他节点也进行元数据的变更</p><p>包含多种消息：ping（交换元数据，过于频繁会网络负担3~n-2）&#x2F;pong（返回ping和meet）&#x2F;meet（通知节点加入集群）&#x2F;fail（某个节点判断另一个节点fail，发送fail给其他节点，说明节点宕机）</p><p>好处：分散存储压力</p><p>缺点：有延时、滞后</p><h6 id="分布式寻址"><a href="#分布式寻址" class="headerlink" title="分布式寻址"></a>分布式寻址</h6><p>①hash算法</p><p>hash后对节点取模打在不同的主节点上</p><p>②一致性hash算法</p><p>虚拟圆环，顺时针遇到的第一个主节点就是key所在位置</p><p>节点分布不均导致缓存热点-&gt;虚拟节点</p><p>③Redis cluster的hash slot算法</p><p>有固定的16384个hash slot，对每个key值计算CRC16，对16384取模，可以获得key对应的hash slot，Redis每个主节点有一部分hash slot值，移动节点成本很低</p><h6 id="集群的高可用与主备切换原理"><a href="#集群的高可用与主备切换原理" class="headerlink" title="集群的高可用与主备切换原理"></a>集群的高可用与主备切换原理</h6><p>与哨兵类似</p><p>判断节点宕机（主节点判断主节点）-&gt;从节点过滤（断开时间）-&gt;从节点选举（offset）-&gt;主节点投票-&gt;从节点主备切换</p><h5 id="（4）定期备份"><a href="#（4）定期备份" class="headerlink" title="（4）定期备份"></a>（4）定期备份</h5><p>定期将RDB和AOF备份远程存储</p><p>缓存与数据库双写</p><p>读请求与写请求串行化：吞吐量大大降低</p><p>异步缓存、写穿透缓存（可以批量更新）</p><h5 id="（1）预留缓存模式"><a href="#（1）预留缓存模式" class="headerlink" title="（1）预留缓存模式"></a>（1）预留缓存模式</h5><p>读先读取缓存，如果缓存中没有再去读取数据库，读取数据库中的结果写入缓存，再返回响应；写时先将缓存删除，再写入数据库</p><p>为什么会出现数据不一致：并发读写访问时，缓存和数据库相互交叉执行</p><h6 id="单库情况下"><a href="#单库情况下" class="headerlink" title="单库情况下"></a>单库情况下</h6><p>操作时序，逻辑处理，导致读取脏数据</p><p>一个写操作和一个读操作，写操作先删除缓存，由于某种原因导致卡顿，没有写入数据库，读操作进行读取，缓存中没有，去数据库读到了脏数据并写入了缓存，此时写操作修改了数据库，但是缓存中一直是脏数据（与源数据不一致的过期或错误数据）</p><h6 id="主从同步，读写分离情况下"><a href="#主从同步，读写分离情况下" class="headerlink" title="主从同步，读写分离情况下"></a>主从同步，读写分离情况下</h6><p>主从同步时延导致读从库产生脏数据</p><p>写操作删除了缓存并写入了主数据库，但是还没有完成主从同步，读操作读缓存没有结果，到从数据库查询，读到脏数据写入缓存并返回</p><h5 id="（2）Cache-Aside-Patter（旁路缓存，推荐方案）"><a href="#（2）Cache-Aside-Patter（旁路缓存，推荐方案）" class="headerlink" title="（2）Cache Aside Patter（旁路缓存，推荐方案）"></a>（2）Cache Aside Patter（旁路缓存，推荐方案）</h5><p>先更新数据库，然后删除缓存</p><p>对缓存的操作速度快，读到脏数据概率低</p><h6 id="为什么是删除缓存不是改变缓存"><a href="#为什么是删除缓存不是改变缓存" class="headerlink" title="为什么是删除缓存不是改变缓存"></a>为什么是删除缓存不是改变缓存</h6><p>避免无效更新：用到缓存才算缓存</p><p>复杂数据一致性：需处理关联函数</p><h6 id="数据不一致解决方案"><a href="#数据不一致解决方案" class="headerlink" title="数据不一致解决方案"></a>数据不一致解决方案</h6><p>删除缓存失败导致数据不一致</p><h6 id="对缓存命中率有严格要求"><a href="#对缓存命中率有严格要求" class="headerlink" title="对缓存命中率有严格要求"></a>对缓存命中率有严格要求</h6><p>更新缓存+分布式锁</p><p>更新缓存+较短过期时间</p><h5 id="（3）预留缓存和旁路缓存比较与选择"><a href="#（3）预留缓存和旁路缓存比较与选择" class="headerlink" title="（3）预留缓存和旁路缓存比较与选择"></a>（3）预留缓存和旁路缓存比较与选择</h5><p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20250330213743271.png" alt="image-20250330213743271"></p><h2 id="二、缓存淘汰"><a href="#二、缓存淘汰" class="headerlink" title="二、缓存淘汰"></a>二、缓存淘汰</h2><h5 id="（1）缓存双淘汰法"><a href="#（1）缓存双淘汰法" class="headerlink" title="（1）缓存双淘汰法"></a>（1）缓存双淘汰法</h5><p>先淘汰缓存</p><p>再写入数据库</p><p>往总线中发送一个淘汰消息，发送完立即返回。存在异步定时消费者在拿到消息1s后淘汰缓存，删除脏数据</p><h5 id="（2）异步淘汰缓存-基于binlog的最终一致性方案"><a href="#（2）异步淘汰缓存-基于binlog的最终一致性方案" class="headerlink" title="（2）异步淘汰缓存(基于binlog的最终一致性方案)"></a>（2）异步淘汰缓存(基于binlog的最终一致性方案)</h5><p>通过数据库变更事件驱动缓存更新，而非依赖业务代码主动操作缓存，无需关心缓存</p><p>不在业务先操作缓存内容，新增一个线下的异步淘汰缓存模块，MySQL记录binlog，解析工具捕获变更并发送到消息队列，缓存消费者监听消息队列，更新Redis</p><h2 id="三、淘汰"><a href="#三、淘汰" class="headerlink" title="三、淘汰"></a>三、淘汰</h2><h3 id="过期时间"><a href="#过期时间" class="headerlink" title="过期时间"></a>过期时间</h3><p>传统数据库自己判断过期</p><h4 id="1、过期时间设置方案"><a href="#1、过期时间设置方案" class="headerlink" title="1、过期时间设置方案"></a>1、过期时间设置方案</h4><h5 id="（1）定期删除"><a href="#（1）定期删除" class="headerlink" title="（1）定期删除"></a>（1）定期删除</h5><p>通常是每100ms检查一次，随机挑选数据查看是否过期，过期则删除</p><p>维护大量key</p><h5 id="（2）惰性删除"><a href="#（2）惰性删除" class="headerlink" title="（2）惰性删除"></a>（2）惰性删除</h5><p>过期时不直接删除，当再次使用到该数据，才会检查到过期并删除</p><p>每次都要判断，且浪费内存</p><h5 id="（3）定期和惰性一定能保证删除数据吗，如果不能Redis会怎么应对"><a href="#（3）定期和惰性一定能保证删除数据吗，如果不能Redis会怎么应对" class="headerlink" title="（3）定期和惰性一定能保证删除数据吗，如果不能Redis会怎么应对"></a>（3）定期和惰性一定能保证删除数据吗，如果不能Redis会怎么应对</h5><p>没有定期删除也没有再次请求，内存会越来越多</p><p>进行内存淘汰机制</p><h4 id="2、内存淘汰机制"><a href="#2、内存淘汰机制" class="headerlink" title="2、内存淘汰机制"></a>2、内存淘汰机制</h4><p>保证数据是热点数据</p><h5 id="（1）no-eviction-驱逐"><a href="#（1）no-eviction-驱逐" class="headerlink" title="（1）no-eviction(驱逐)"></a>（1）no-eviction(驱逐)</h5><p>不淘汰内存，内存不足时返回错误</p><h5 id="（2）allkeys-LRU"><a href="#（2）allkeys-LRU" class="headerlink" title="（2）allkeys-LRU"></a>（2）allkeys-LRU</h5><p>所有键中最近最少使用</p><h5 id="（3）allkeys-random"><a href="#（3）allkeys-random" class="headerlink" title="（3）allkeys-random"></a>（3）allkeys-random</h5><p>所有键中随机淘汰</p><h5 id="（4）volatile-LRU"><a href="#（4）volatile-LRU" class="headerlink" title="（4）volatile-LRU"></a>（4）volatile-LRU</h5><p>设置了过期时间的键中淘汰最近最少使用</p><h5 id="（5）volatile-ttl"><a href="#（5）volatile-ttl" class="headerlink" title="（5）volatile-ttl"></a>（5）volatile-ttl</h5><p>过期键中剩余时间最短的键</p><h5 id="（6）volatile-random"><a href="#（6）volatile-random" class="headerlink" title="（6）volatile-random"></a>（6）volatile-random</h5><p>从已过期的数据集中任意选择数据淘汰</p><p>如果没有设置expire的key，不满足先决条件，那么volatile和noeviction基本一致</p><h2 id="四、问题"><a href="#四、问题" class="headerlink" title="四、问题"></a>四、问题</h2><h4 id="平常使用Redis可能会碰见什么问题"><a href="#平常使用Redis可能会碰见什么问题" class="headerlink" title="平常使用Redis可能会碰见什么问题"></a>平常使用Redis可能会碰见什么问题</h4><h5 id="（1）缓冲雪崩"><a href="#（1）缓冲雪崩" class="headerlink" title="（1）缓冲雪崩"></a>（1）缓冲雪崩</h5><p>当大量数据同一时间失效，如果此时有大量用户请求，都无法在Redis中处理，全部直接访问数据库，从而导致数据库压力大增，严重的会造成数据库宕机，从而造成一系列连锁反应，造成系统崩溃</p><h6 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h6><p>事前：将缓存过期时间随机打乱；缓存不过期：通过后台服务来更新缓存数据；选择合适的内存淘汰策略多级缓存</p><p>事中：限流降级；加锁或者队列控制访问数据库的线程数量</p><p>事后：持久化机制恢复缓存</p><h5 id="（2）缓冲击穿"><a href="#（2）缓冲击穿" class="headerlink" title="（2）缓冲击穿"></a>（2）缓冲击穿</h5><p>当热点数据失效，又有大量请求访问该热点数据，直接访问数据库，数据库被高并发请求冲垮</p><h6 id="解决-1"><a href="#解决-1" class="headerlink" title="解决"></a>解决</h6><p>互斥锁方案</p><p>不给热点数据设置过期时间</p><h5 id="（3）缓存穿透"><a href="#（3）缓存穿透" class="headerlink" title="（3）缓存穿透"></a>（3）缓存穿透</h5><p>大量请求访问的数据既不在缓存也不在数据库（业务误操作；黑客恶意攻击）</p><h6 id="解决-2"><a href="#解决-2" class="headerlink" title="解决"></a>解决</h6><p>非法请求限制</p><p>缓存空对象：设置空值或默认值（数据变化频繁且实时性高，需要缓存空间多，代码维护简单）</p><p>布隆过滤器（数据变化不频繁且实时性低，需要缓存空间少，代码维护复杂）</p><h6 id="布隆过滤器的实现原理"><a href="#布隆过滤器的实现原理" class="headerlink" title="布隆过滤器的实现原理"></a>布隆过滤器的实现原理</h6><p>使用多个哈希函数和位数组（存储的是所有插入元素的哈希标记的并集）存储哈希结果，快速判断目标数据是否存在；减小误判：增加哈希函数数量、位数组长度；选择合适的哈希函数；动态调整布隆过滤器（根据集合中数组元素）；多次哈希缺点：计算开销增加，位数组填充过快，增加误判率</p><h6 id="布隆过滤器的应用场景"><a href="#布隆过滤器的应用场景" class="headerlink" title="布隆过滤器的应用场景"></a>布隆过滤器的应用场景</h6><p>缓存穿透防护、爬虫URL去重（避免重复抓取相同的网页）、数据库查询优化</p><h5 id="（4）缓存预热"><a href="#（4）缓存预热" class="headerlink" title="（4）缓存预热"></a>（4）缓存预热</h5><p>系统启动时提前将高频数据加载到缓存</p><h5 id="（5）缓存更新"><a href="#（5）缓存更新" class="headerlink" title="（5）缓存更新"></a>（5）缓存更新</h5><p>定期删除和惰性删除</p><p>写时删除（更新数据时同时更新缓存）；消息队列通知</p><h5 id="（6）缓存降级"><a href="#（6）缓存降级" class="headerlink" title="（6）缓存降级"></a>（6）缓存降级</h5><p>分级策略：（全局降级）返回静态默认值；（部分降级）核心字段保留；（读旧数据）允许返回略微过期的数据</p><p>保证核心服务可用，即使是有损的</p><h5 id="（7）超卖"><a href="#（7）超卖" class="headerlink" title="（7）超卖"></a>（7）超卖</h5><p>在电商等高并发情况下，商品库存被多个用户同时购买，导致实际销售量超过库存（并发操作缺乏有效的库存控制机制）</p><p>解决：分布式锁+lua脚本</p><h6 id="单独只有锁"><a href="#单独只有锁" class="headerlink" title="单独只有锁"></a>单独只有锁</h6><p>锁粒度问题（只对关键资源加锁）；锁超时问题（设置自动过期时间）；非原子操作（使用lua脚本）</p><h6 id="lua脚本"><a href="#lua脚本" class="headerlink" title="lua脚本"></a>lua脚本</h6><p>lua是一种轻量级脚本语言，被嵌入到Redis中，整个lua脚本在Redis中会当做一个原子操作执行，在执行过程中不会被打断</p><h2 id="五、Map与Memcache"><a href="#五、Map与Memcache" class="headerlink" title="五、Map与Memcache"></a>五、Map与Memcache</h2><h3 id="一）Map"><a href="#一）Map" class="headerlink" title="(一）Map"></a>(一）Map</h3><h4 id="1、C-中Map也是一种缓存型数据结构，为什么不用Map，而选择Redis做缓存"><a href="#1、C-中Map也是一种缓存型数据结构，为什么不用Map，而选择Redis做缓存" class="headerlink" title="1、C++中Map也是一种缓存型数据结构，为什么不用Map，而选择Redis做缓存"></a>1、C++中Map也是一种缓存型数据结构，为什么不用Map，而选择Redis做缓存</h4><p>Map属于本地缓存，具有轻量级、速度快的特点，但是生命周期随程序销毁而结束，且存在多个实例情况下，每个实例都要各自保存一份缓存，缓存不具有一致性</p><h4 id="2、Redis与Map区别"><a href="#2、Redis与Map区别" class="headerlink" title="2、Redis与Map区别"></a>2、Redis与Map区别</h4><p>分布式</p><h3 id="（二）Memcache"><a href="#（二）Memcache" class="headerlink" title="（二）Memcache"></a>（二）Memcache</h3><p>Redis和Memcache是分布式缓存，在多实例的情况下，各实例共享一份缓存，缓存具有一致性；但是需要保持高可用，架构复杂</p><h4 id="1、Redis与Memcache区别"><a href="#1、Redis与Memcache区别" class="headerlink" title="1、Redis与Memcache区别"></a>1、Redis与Memcache区别</h4><p>存储方式：Memcache全部存储在内存，当断电数据全没，没有持久性；Redis有一部分存储在硬盘上，保证了持久性，且支持RDB快照和AOF日志</p><p>数据结构：Memcache只支持String；Redis支持字符串、哈希表、链表、集合、有序集合</p><p>底层模式：Memcache是多线程，使用非阻塞I&#x2F;O；Redis是单线程，使用多路复用I&#x2F;O，VM模式（已废弃：Redis 在内存不足时，将不常用的 Value交换到磁盘上，而Key 和热点 Value仍保留在内存中的机制）</p><p>集群：Memcache无原生集群，依赖客户端分片，Redis支持原生集群模式，可水平扩展</p><p>Value值不同：Redis最大可以达到512MB，Memcache只有1MB</p><h5 id="（1）Redis为什么是单线程不是多线程"><a href="#（1）Redis为什么是单线程不是多线程" class="headerlink" title="（1）Redis为什么是单线程不是多线程"></a>（1）Redis为什么是单线程不是多线程</h5><p>Redis是基于内存，CPU不会成为瓶颈，瓶颈一般是内存大小或者网络带宽，单线程实现更容易</p><h5 id="（2）为什么单线程Redis这么快"><a href="#（2）为什么单线程Redis这么快" class="headerlink" title="（2）为什么单线程Redis这么快"></a>（2）为什么单线程Redis这么快</h5><p>使用内存；单线程，避免了线程上下文切换；使用I&#x2F;O多路复用</p><h5 id="（3）介绍Redis线程模型"><a href="#（3）介绍Redis线程模型" class="headerlink" title="（3）介绍Redis线程模型"></a>（3）介绍Redis线程模型</h5><p>多个Socket</p><p>I&#x2F;O多路复用：监听多个Socket，向文件事件分派器传送已经产生了事件的Socket</p><p>文件事件分派器</p><p>文件事件处理器（单线程）</p><h5 id="（4）Memcache为什么使用多线程"><a href="#（4）Memcache为什么使用多线程" class="headerlink" title="（4）Memcache为什么使用多线程"></a>（4）Memcache为什么使用多线程</h5><p>Memcache的定位是纯缓存服务器，追求机制的读写性能，核心诉求是超高吞吐量与低延迟</p><h4 id="2、Redis的优势"><a href="#2、Redis的优势" class="headerlink" title="2、Redis的优势"></a>2、Redis的优势</h4><h5 id="（1）数据结构丰富"><a href="#（1）数据结构丰富" class="headerlink" title="（1）数据结构丰富"></a>（1）数据结构丰富</h5><h6 id="①字符串"><a href="#①字符串" class="headerlink" title="①字符串"></a>①字符串</h6><p>简单动态字符串</p><h6 id="②哈希"><a href="#②哈希" class="headerlink" title="②哈希"></a>②哈希</h6><p>压缩列表、哈希表</p><h6 id="③集合"><a href="#③集合" class="headerlink" title="③集合"></a>③集合</h6><p>整数集合、哈希表</p><h6 id="④有序集合"><a href="#④有序集合" class="headerlink" title="④有序集合"></a>④有序集合</h6><p>压缩列表、跳跃表+哈希表</p><h6 id="⑤列表-链表"><a href="#⑤列表-链表" class="headerlink" title="⑤列表&#x2F;链表"></a>⑤列表&#x2F;链表</h6><p>压缩列表、双向列表、快速列表</p><p>消息队列</p><h5 id="（2）速度快"><a href="#（2）速度快" class="headerlink" title="（2）速度快"></a>（2）速度快</h5><p>单线程</p><h5 id="（3）持久化"><a href="#（3）持久化" class="headerlink" title="（3）持久化"></a>（3）持久化</h5><p>RDB、AOF</p><h5 id="（4）集群"><a href="#（4）集群" class="headerlink" title="（4）集群"></a>（4）集群</h5><h2 id="六、定义"><a href="#六、定义" class="headerlink" title="六、定义"></a>六、定义</h2><h3 id="（一）热点数据和冷数据"><a href="#（一）热点数据和冷数据" class="headerlink" title="（一）热点数据和冷数据"></a>（一）热点数据和冷数据</h3><p>访问较多的是热点数据，访问次数很少的是冷数据；热点数据一般存储在内存中，冷数据一般存储在硬盘中（没有等到再次访问就已经被挤出内存，不仅占用内存空间而且价值不大）</p><p>数据更新前至少读取两次缓存才有意义</p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库（三）：优化</title>
      <link href="/my_tech_blog.github.io/2025/11/09/%E6%95%B0%E6%8D%AE%E5%BA%93_3/"/>
      <url>/my_tech_blog.github.io/2025/11/09/%E6%95%B0%E6%8D%AE%E5%BA%93_3/</url>
      
        <content type="html"><![CDATA[<h1 id="数据库（三）：优化"><a href="#数据库（三）：优化" class="headerlink" title="数据库（三）：优化"></a>数据库（三）：优化</h1>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 其他 </tag>
            
            <tag> 优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库（二）：数据库</title>
      <link href="/my_tech_blog.github.io/2025/11/09/%E6%95%B0%E6%8D%AE%E5%BA%93_2/"/>
      <url>/my_tech_blog.github.io/2025/11/09/%E6%95%B0%E6%8D%AE%E5%BA%93_2/</url>
      
        <content type="html"><![CDATA[<h1 id="数据库（二）：数据库"><a href="#数据库（二）：数据库" class="headerlink" title="数据库（二）：数据库"></a>数据库（二）：数据库</h1>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库（一）：SQL</title>
      <link href="/my_tech_blog.github.io/2025/11/09/%E6%95%B0%E6%8D%AE%E5%BA%93_1/"/>
      <url>/my_tech_blog.github.io/2025/11/09/%E6%95%B0%E6%8D%AE%E5%BA%93_1/</url>
      
        <content type="html"><![CDATA[<h1 id="数据库（一）：SQL"><a href="#数据库（一）：SQL" class="headerlink" title="数据库（一）：SQL"></a>数据库（一）：SQL</h1><h2 id="一、数据类型"><a href="#一、数据类型" class="headerlink" title="一、数据类型"></a>一、数据类型</h2><h3 id="（二）比较"><a href="#（二）比较" class="headerlink" title="（二）比较"></a>（二）比较</h3><h4 id="1、varchar和char"><a href="#1、varchar和char" class="headerlink" title="1、varchar和char"></a>1、varchar和char</h4><h5 id="（1）概念"><a href="#（1）概念" class="headerlink" title="（1）概念"></a>（1）概念</h5><p>varchar：变长字符串，长度是数据长度+1或2字节（数据长度）</p><p>char：定长字符串，长度固定，用空格填充</p><h5 id="（2）区别"><a href="#（2）区别" class="headerlink" title="（2）区别"></a>（2）区别</h5><p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20250324113356840.png" alt="image-20250324113356840"></p><p>存储方式：英文和汉字都两个字节；英文一个字节，汉字两个字节</p><h2 id="二、函数"><a href="#二、函数" class="headerlink" title="二、函数"></a>二、函数</h2><h3 id="（二）比较-1"><a href="#（二）比较-1" class="headerlink" title="（二）比较"></a>（二）比较</h3><h4 id="1、NOW（）和CURRENT-DATE（）"><a href="#1、NOW（）和CURRENT-DATE（）" class="headerlink" title="1、NOW（）和CURRENT_DATE（）"></a>1、NOW（）和CURRENT_DATE（）</h4><h5 id="（1）NOW（）"><a href="#（1）NOW（）" class="headerlink" title="（1）NOW（）"></a>（1）NOW（）</h5><p>年月日-时分秒</p><h5 id="（2）CURRENT-DATE（）"><a href="#（2）CURRENT-DATE（）" class="headerlink" title="（2）CURRENT_DATE（）"></a>（2）CURRENT_DATE（）</h5><p>年月日</p><h2 id="三、键"><a href="#三、键" class="headerlink" title="三、键"></a>三、键</h2><p>数据库中主键、超键、候选键、外键</p><h5 id="（1）超键"><a href="#（1）超键" class="headerlink" title="（1）超键"></a>（1）超键</h5><p>数据库中唯一标识行的属性集</p><h5 id="（2）候选键"><a href="#（2）候选键" class="headerlink" title="（2）候选键"></a>（2）候选键</h5><p>最小的超键，没有多余属性的超键，是主键的候选者</p><h5 id="（3）候选键"><a href="#（3）候选键" class="headerlink" title="（3）候选键"></a>（3）候选键</h5><p>从候选键中选择的一个键，表的唯一标识符</p><h5 id="（4）外键"><a href="#（4）外键" class="headerlink" title="（4）外键"></a>（4）外键</h5><p>被引用表中的主键或候选键，维护数据（引用）完整性</p><h2 id="四、执行"><a href="#四、执行" class="headerlink" title="四、执行"></a>四、执行</h2><h3 id="（一）MySQL是怎样执行一条SQL的"><a href="#（一）MySQL是怎样执行一条SQL的" class="headerlink" title="（一）MySQL是怎样执行一条SQL的"></a>（一）MySQL是怎样执行一条SQL的</h3><p>Server层和存储引擎</p><p>客户端请求-&gt;连接器验证用户身份，给予权限-&gt;查询缓存，有则直接返回，没有进行下一步操作-&gt;分析器，分析SQL语句词法分析和语法分析-&gt;优化器，查询最好的执行方案-&gt;执行器，查看是否有权限，有则执行，有才去使用这个引擎提供的接口-&gt;存储引擎返回结果，如果开启了查询缓存则会缓存查询结果</p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20250503153749869.png" alt="image-20250503153749869" style="zoom:67%;" />]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
            <tag> 数据类型 </tag>
            
            <tag> 函数 </tag>
            
            <tag> 键 </tag>
            
            <tag> 执行 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统（八）：</title>
      <link href="/my_tech_blog.github.io/2025/11/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_7/"/>
      <url>/my_tech_blog.github.io/2025/11/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_7/</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统（八）"><a href="#操作系统（八）" class="headerlink" title="操作系统（八）"></a>操作系统（八）</h1>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统（六）：</title>
      <link href="/my_tech_blog.github.io/2025/11/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_6/"/>
      <url>/my_tech_blog.github.io/2025/11/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_6/</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统（六）"><a href="#操作系统（六）" class="headerlink" title="操作系统（六）"></a>操作系统（六）</h1>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统（五）：</title>
      <link href="/my_tech_blog.github.io/2025/11/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_5/"/>
      <url>/my_tech_blog.github.io/2025/11/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_5/</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统（五）"><a href="#操作系统（五）" class="headerlink" title="操作系统（五）"></a>操作系统（五）</h1>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统（四）：</title>
      <link href="/my_tech_blog.github.io/2025/11/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_4/"/>
      <url>/my_tech_blog.github.io/2025/11/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_4/</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统（四）"><a href="#操作系统（四）" class="headerlink" title="操作系统（四）"></a>操作系统（四）</h1>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统（三）：</title>
      <link href="/my_tech_blog.github.io/2025/11/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_3/"/>
      <url>/my_tech_blog.github.io/2025/11/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_3/</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统（三）"><a href="#操作系统（三）" class="headerlink" title="操作系统（三）"></a>操作系统（三）</h1>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统（二）：</title>
      <link href="/my_tech_blog.github.io/2025/11/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_2/"/>
      <url>/my_tech_blog.github.io/2025/11/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_2/</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统（）"><a href="#操作系统（）" class="headerlink" title="操作系统（）"></a>操作系统（）</h1>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统（一）：进程、线程、协程</title>
      <link href="/my_tech_blog.github.io/2025/11/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_1/"/>
      <url>/my_tech_blog.github.io/2025/11/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_1/</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统（一）：进程、线程、协程"><a href="#操作系统（一）：进程、线程、协程" class="headerlink" title="操作系统（一）：进程、线程、协程"></a>操作系统（一）：进程、线程、协程</h1><h2 id="一、进程、线程、协程"><a href="#一、进程、线程、协程" class="headerlink" title="一、进程、线程、协程"></a>一、进程、线程、协程</h2><p>进程是资源分配的基本单位，运行一个可执行程序可能会创建一个或多个进程，进程就是运行起来的可执行程序</p><p>线程是CPU调度的基本单位，也是程序执行的基本单位，是轻量级进程，每个进程有且只有一个主线程，相互依存</p><p>协程是用户态的轻量级线程，线程内部调度的基本单位</p><p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20250313215209928.png" alt="image-20250313215209928"></p><h3 id="（一）线程与进程比较"><a href="#（一）线程与进程比较" class="headerlink" title="（一）线程与进程比较"></a>（一）线程与进程比较</h3><p>线程速度快，轻量级，系统开销小，使用有一定难度，需要处理数据一致性</p><h4 id="1、一个进程可以创建多少线程，和什么有关？"><a href="#1、一个进程可以创建多少线程，和什么有关？" class="headerlink" title="1、一个进程可以创建多少线程，和什么有关？"></a>1、一个进程可以创建多少线程，和什么有关？</h4><p>系统位数、虚拟空间大小、线程的栈空间大小</p><p>过多的线程会将时间浪费在线程的切换上，无用线程要及时销毁</p><p>C++中一个线程崩溃，它所在的进程中所有线程都会崩溃，JAVA不会</p><h4 id="2、进程线程模型"><a href="#2、进程线程模型" class="headerlink" title="2、进程线程模型"></a>2、进程线程模型</h4><h5 id="（1）多线程"><a href="#（1）多线程" class="headerlink" title="（1）多线程"></a>（1）多线程</h5><p>线程之间有无先后访问顺序（线程依赖关系）</p><p>多个线程共享访问同一变量（同步互斥问题）</p><h6 id="①多线程和线程池有什么区别"><a href="#①多线程和线程池有什么区别" class="headerlink" title="①多线程和线程池有什么区别"></a>①多线程和线程池有什么区别</h6><p>线程池是一开始就创建好的n个线程，效率高，根据程序需要进行复用，任务完成后不会回收（回到阻塞队列），在高并发情况下性能较好，不容易挂掉（线程池通过线程与任务解耦实现线程复用，在C++标准库中，没有直接提供线程池实现，但可以通过第三方库或自行实现。）</p><p>多线程是在任务到来时进行线程创建，效率较低，任务完成后会回收，在高并发情况下容易挂掉</p><h6 id="②线程池会复用线程，那这个线程先前访问的资源对象会被修改吗"><a href="#②线程池会复用线程，那这个线程先前访问的资源对象会被修改吗" class="headerlink" title="②线程池会复用线程，那这个线程先前访问的资源对象会被修改吗"></a>②线程池会复用线程，那这个线程先前访问的资源对象会被修改吗</h6><p>取决于资源的类型和作用域，局部变量不会被修改（线程栈会被清空）；全局、静态变量和堆内存变量（堆内存的全局可见性和对象引用的传递性）可能被共享</p><h5 id="（2）多进程"><a href="#（2）多进程" class="headerlink" title="（2）多进程"></a>（2）多进程</h5><p>进程结构：代码段、堆栈段、数据段，代码段是静态二进制代码，可以多个程序共享父子进程共享全部数据</p><h5 id="（3）多线程和多进程的区别，什么时候使用多线程-进程"><a href="#（3）多线程和多进程的区别，什么时候使用多线程-进程" class="headerlink" title="（3）多线程和多进程的区别，什么时候使用多线程&#x2F;进程"></a>（3）多线程和多进程的区别，什么时候使用多线程&#x2F;进程</h5><p>频繁修改（频繁创建和创建）、计算量大（消耗大量CPU资源且切换频繁）、相关性强（线程数据共享和同步比较简单）：多线程</p><p>多分布：扩展到多机（进程）；多核分布（线程）</p><h5 id="（3）Linux进程控制"><a href="#（3）Linux进程控制" class="headerlink" title="（3）Linux进程控制"></a>（3）Linux进程控制</h5><p>进程地址空间</p><p>进程控制块</p><p>上下文切换</p><h4 id="3、线程间通信"><a href="#3、线程间通信" class="headerlink" title="3、线程间通信"></a>3、线程间通信</h4><h5 id="（1）共享内存"><a href="#（1）共享内存" class="headerlink" title="（1）共享内存"></a>（1）共享内存</h5><p>互斥锁或原子操作保护共享数据</p><h5 id="（2）锁机制"><a href="#（2）锁机制" class="headerlink" title="（2）锁机制"></a>（2）锁机制</h5><p>互斥锁：通过加锁和解锁操作，保证同一时间内只有一个线程访问资源</p><p>条件变量：用于进程间同步，一个线程等待条件成立，一个线程通知条件成立</p><p>读写锁：：允许多个读线程同时访问资源，但写线程独占资源</p><h5 id="（3）信号量机制"><a href="#（3）信号量机制" class="headerlink" title="（3）信号量机制"></a>（3）信号量机制</h5><p>无名线程信号量：用于线程间同步，通过计数器控制资源访问</p><p>命名线程信号量：进程，标识资源</p><h5 id="（4）信号机制"><a href="#（4）信号机制" class="headerlink" title="（4）信号机制"></a>（4）信号机制</h5><p>通过发送信号通知线程或进程</p><h4 id="4、进程间通信方式"><a href="#4、进程间通信方式" class="headerlink" title="4、进程间通信方式"></a>4、进程间通信方式</h4><h5 id="（1）管道"><a href="#（1）管道" class="headerlink" title="（1）管道"></a>（1）管道</h5><p>先入先出</p><p>无名管道（内存文件）：半双工，只能单向传递，进程间必须有亲缘关系</p><p>有名管道（文件系统）：半半双工，进程间可以没有亲缘关系</p><h5 id="（2）共享内存"><a href="#（2）共享内存" class="headerlink" title="（2）共享内存"></a>（2）共享内存</h5><p>最快，往往和信号量一起使用</p><p>直接创建内存共享区域（直接内存访问）</p><p>一段可以被其它进程访问的内存，由一个进程创建，但多个内存都可以访问，是最快的IPC，往往与信号量配合</p><h5 id="（3）内存映射"><a href="#（3）内存映射" class="headerlink" title="（3）内存映射"></a>（3）内存映射</h5><p>将文件映射到进程地址空间（通过文件I&#x2F;O接口或指针访问）</p><h5 id="（4）消息队列"><a href="#（4）消息队列" class="headerlink" title="（4）消息队列"></a>（4）消息队列</h5><p>是一个有消息的链表，存放在内核中并由消息队列标识符标识。克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限</p><p>将消息存储到一个队列中，发送方将消息放入队列，接收方从队列中取出消息</p><p>消息（消息类型、消息内容）；队列（存储）；消息队列标识符（唯一标识一个消息队列）</p><h5 id="（5）套接字"><a href="#（5）套接字" class="headerlink" title="（5）套接字"></a>（5）套接字</h5><p>不同设备及其间的进程通讯</p><p>两个机器之间的进程通信方式，可以是两个进程间的通信方式</p><h5 id="（6）信号"><a href="#（6）信号" class="headerlink" title="（6）信号"></a>（6）信号</h5><p>比较复杂的通信方式，可以发送给进程本身，用于接收进程某个事件已经发生</p><h5 id="（7）信号量"><a href="#（7）信号量" class="headerlink" title="（7）信号量"></a>（7）信号量</h5><p>计数器，可以用来控制多个进程对共享资源的访问。常作为一种锁机制，实现进程、线程对临界区的同步及互斥访问</p><h5 id="（8）辅助命令"><a href="#（8）辅助命令" class="headerlink" title="（8）辅助命令"></a>（8）辅助命令</h5><p>报告共享内存、信号量、消息队列信息</p><p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20250326164727872.png" alt="image-20250326164727872"></p><h4 id="5、同步机制"><a href="#5、同步机制" class="headerlink" title="5、同步机制"></a>5、同步机制</h4><h5 id="（1）信号量"><a href="#（1）信号量" class="headerlink" title="（1）信号量"></a>（1）信号量</h5><p>可以用于进程间同步（SYSTEM V），也可以用于线程间同步（POSIX）</p><h5 id="（2）互斥锁-条件变量"><a href="#（2）互斥锁-条件变量" class="headerlink" title="（2）互斥锁+条件变量"></a>（2）互斥锁+条件变量</h5><p>需要操作共享内存状态，只能用于线程同步（进程默认有独立地址空间）</p><h6 id="生产者-消费者模型"><a href="#生产者-消费者模型" class="headerlink" title="生产者-消费者模型"></a>生产者-消费者模型</h6><p>互斥锁+条件变量、共享内存</p><p>生产者：等待缓冲区非满，生产数据或任务输入共享缓冲区，通知消费者</p><p>消费者：等待缓冲区非空，从缓冲区取出数据，通知消费者，处理数据</p><h3 id="（二）线程"><a href="#（二）线程" class="headerlink" title="（二）线程"></a>（二）线程</h3><h4 id="1、怎么回收线程"><a href="#1、怎么回收线程" class="headerlink" title="1、怎么回收线程"></a>1、怎么回收线程</h4><p>等待线程结束</p><p>结束线程</p><p>分离线程</p><h3 id="（三）进程"><a href="#（三）进程" class="headerlink" title="（三）进程"></a>（三）进程</h3><h4 id="1、进程算法调度"><a href="#1、进程算法调度" class="headerlink" title="1、进程算法调度"></a>1、进程算法调度</h4><h5 id="（1）先来先服务（FCFS）"><a href="#（1）先来先服务（FCFS）" class="headerlink" title="（1）先来先服务（FCFS）"></a>（1）先来先服务（FCFS）</h5><p>非抢占式，按照请求顺序</p><p>有利于长作业，不利于短作业，短作业等待时间过长</p><h5 id="（2）短作业优先（SJF）"><a href="#（2）短作业优先（SJF）" class="headerlink" title="（2）短作业优先（SJF）"></a>（2）短作业优先（SJF）</h5><p>非抢占，按运行时间最短</p><p>长作业可能会饿死</p><h5 id="（3）最短剩余时间优先（SRTN）"><a href="#（3）最短剩余时间优先（SRTN）" class="headerlink" title="（3）最短剩余时间优先（SRTN）"></a>（3）最短剩余时间优先（SRTN）</h5><p>抢占式，与当前进程的剩余时间</p><h5 id="（4）时间片轮转"><a href="#（4）时间片轮转" class="headerlink" title="（4）时间片轮转"></a>（4）时间片轮转</h5><p>按FCFS排，轮着每个进程执行一个时间片</p><p>实时性和切换频率</p><h5 id="（5）优先级调度"><a href="#（5）优先级调度" class="headerlink" title="（5）优先级调度"></a>（5）优先级调度</h5><p>优先级</p><h5 id="（6）多级反馈队列"><a href="#（6）多级反馈队列" class="headerlink" title="（6）多级反馈队列"></a>（6）多级反馈队列</h5><p>时间片轮转调度+优先级调度算法-&gt;每个队列优先级、时间片不同</p><h4 id="2、进程同步的四种方法"><a href="#2、进程同步的四种方法" class="headerlink" title="2、进程同步的四种方法"></a>2、进程同步的四种方法</h4><h5 id="（1）临界区"><a href="#（1）临界区" class="headerlink" title="（1）临界区"></a>（1）临界区</h5><p>对临界区资源进行访问的代码是临界区，为了防止互斥访问临界资源，每个进程进入临界区前要先进行检查</p><h5 id="（2）同步与互斥"><a href="#（2）同步与互斥" class="headerlink" title="（2）同步与互斥"></a>（2）同步与互斥</h5><p>同步：因为合作产生的制约关系，进程之间存在先后执行关系</p><p>互斥：多个进程同一时刻只能有一个进入临界区</p><h5 id="（3）信号量"><a href="#（3）信号量" class="headerlink" title="（3）信号量"></a>（3）信号量</h5><p>有计数能力的锁，控制多个线程对共享资源的访问</p><p>down（P操作-1），up（V操作+1）；如果信号量只能取1或0，则变成了互斥量</p><p>不能先锁再进行信号量查询</p><h6 id="生产者-消费者模型-1"><a href="#生产者-消费者模型-1" class="headerlink" title="生产者-消费者模型"></a>生产者-消费者模型</h6><p>信号量（互斥量mutex控制访问缓冲区，empty空缓冲区数量，full满缓冲区数量）、共享缓冲区</p><p>生产者：等待缓冲区非满，生产数据或任务输入共享缓冲区，通知消费者</p><p>消费者：等待缓冲区非空，从缓冲区取出数据，通知消费者，处理数据</p><h5 id="（4）管程"><a href="#（4）管程" class="headerlink" title="（4）管程"></a>（4）管程</h5><p>将控制代码独立出来，只允许一个进程访问管程，基于条件变量实现进程同步（阻塞和唤醒进程）</p><h4 id="3、进程状态的切换"><a href="#3、进程状态的切换" class="headerlink" title="3、进程状态的切换"></a>3、进程状态的切换</h4><p>就绪：等待被调度</p><p>运行</p><p>阻塞：等待资源</p><p>就绪和运行之间是双箭头（获得CPU时间和CPU时间用完），运行（缺少资源）-&gt;阻塞-&gt;就绪</p><h4 id="4、守护进程、僵尸进程、孤儿进程"><a href="#4、守护进程、僵尸进程、孤儿进程" class="headerlink" title="4、守护进程、僵尸进程、孤儿进程"></a>4、守护进程、僵尸进程、孤儿进程</h4><h5 id="（1）守护进程"><a href="#（1）守护进程" class="headerlink" title="（1）守护进程"></a>（1）守护进程</h5><p>在后台进行，没有控制终端与之相连，Linux大多数服务器使用守护进程实现</p><h6 id="①创建守护进程要点"><a href="#①创建守护进程要点" class="headerlink" title="①创建守护进程要点"></a>①创建守护进程要点</h6><p>调用fork创建子进程，父进程退出：子进程成为孤儿进程，接管，脱离终端</p><p>setsid创建新会话：脱离原会话组、进程组、控制终端</p><p>忽略SIGHUP&#x2F;ˌsɪɡˈhʌp&#x2F;信号：防止受终端挂断影响</p><p>再次fork()（可选）：避免重新获取终端</p><p>关闭文件描述符</p><p>更改工作目录到根目录：避免占用挂载点</p><p>重设文件掩码：确保文件权限不受限制</p><h5 id="（2）僵尸进程"><a href="#（2）僵尸进程" class="headerlink" title="（2）僵尸进程"></a>（2）僵尸进程</h5><p>子进程退出，父进程还没有退出，当父进程捕获到子进程退出状态，子进程才会结束，在这之前子进程会变成僵尸进程</p><p>维护子进程的信息，以便父进程在某个时间获取</p><h6 id="①回收方式"><a href="#①回收方式" class="headerlink" title="①回收方式"></a>①回收方式</h6><p>父进程调用wait()（会阻塞父进程，直到子进程退出）或waitpid()</p><p>父进程先退出，僵尸进程会被init接管并自动回收</p><h6 id="②怎么避免僵尸进程"><a href="#②怎么避免僵尸进程" class="headerlink" title="②怎么避免僵尸进程"></a>②怎么避免僵尸进程</h6><p>wait()和waitpid()</p><p>忽略SIGCHLD&#x2F;ˌsɪɡˈkɪld&#x2F;信号（子进程终止时触发，需父进程 wait()），内核会自动回收僵尸进程。</p><p>注册SIGCHID信号处理函数，在回调中调用wait()</p><p>fork()两次，守护进程，分离父进程与子进程</p><h5 id="（3）孤儿进程"><a href="#（3）孤儿进程" class="headerlink" title="（3）孤儿进程"></a>（3）孤儿进程</h5><p>父进程退出，子进程没有退出，子进程变成孤儿进程，每个进程都要有父进程，子进程的父进程将变为init进程，由init进程对它们完成状态收集工作（<code>init</code> 会定期调用 <code>wait()</code> 回收孤儿进程的资源）</p><h6 id="①init进程"><a href="#①init进程" class="headerlink" title="①init进程"></a>①init进程</h6><p><code>init</code> 是内核启动的第一个用户态进程，其父进程为内核线程（如 <code>kthreadd</code>），但 <code>init</code> 自身没有真正的父进程。</p><p>在 Systemd 系统中（如 Ubuntu 22.04），<code>init</code> 被替换为 <code>systemd</code>（PID&#x3D;1），功能类似。</p><p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20250327174253259.png" alt="image-20250327174253259"></p><h4 id="5、父进程、子进程、进程组、作业和会话"><a href="#5、父进程、子进程、进程组、作业和会话" class="headerlink" title="5、父进程、子进程、进程组、作业和会话"></a>5、父进程、子进程、进程组、作业和会话</h4><h5 id="（1）父进程"><a href="#（1）父进程" class="headerlink" title="（1）父进程"></a>（1）父进程</h5><p>有一个或多个子进程的进程</p><h5 id="（2）子进程"><a href="#（2）子进程" class="headerlink" title="（2）子进程"></a>（2）子进程</h5><p>由fork()创建的进程。调用一次，返回两次，子进程返回0，父进程返回子进程的进程号，子进程可以通过getpid获得自己的进程号，通过getppid获得父进程的进程号，如果fork不成功，父进程返回错误</p><p>fork之后操作系统会复制一个和父进程一模一样的子进程，共享代码空间，独享数据空间，子进程的数据空间是从父进程拷贝的，指针指令也完全相同，子进程拥有父进程当前运行的位置（程序计数器pc值相同）</p><p>子进程从父进程继承的有：进程的资格、代码段（只读）、环境、进程组号</p><p>独有：进程号；内存数据（堆栈、全局变量）、资源使用；父进程号</p><h5 id="（3）进程组"><a href="#（3）进程组" class="headerlink" title="（3）进程组"></a>（3）进程组</h5><p>多个相关联进程的集合，存在一个组进程，但是只要该进程组中存在一个进程，该进程组就存在</p><p>shell通过进程组管理作业，进程组是内核层面的概念</p><h5 id="（4）作业"><a href="#（4）作业" class="headerlink" title="（4）作业"></a>（4）作业</h5><p>作业是shell（操作系统的用户界面，充当用户与内核之间的桥梁Shell &#x3D; 命令解释器 + 脚本执行环境 + 用户交互界面）层面的概念，一个作业对应一个进程组，shell区分前后台不是来控制的不是进程，而是作业或进程组</p><p>一个后台&#x2F;前台（占用终端，受shell控制，可以Ctrl+C终止）作业可以由多个进程组成，shell可以运行一个前台作业和任意多个后台作业，这称为作业控制</p><h6 id="①为什么只能运行一个前台作业"><a href="#①为什么只能运行一个前台作业" class="headerlink" title="①为什么只能运行一个前台作业"></a>①为什么只能运行一个前台作业</h6><p>当在前台运行一个作业，shell就被提到后台，没有办法接受指令并解析，前台进程退出，shell会提到前台</p><p>如果作业中创建了一个子进程且该子进程不属于该作业，一旦作业运行结束，shell把自己提到前台（子进程还存在但是不属于作业，游离子进程），如果原前台进程还存在还存在存活进程，自动变为后台进程组</p><h5 id="（5）会话"><a href="#（5）会话" class="headerlink" title="（5）会话"></a>（5）会话</h5><p>一个会话包含多个进程组，代表一个用户登录后的完整工作环境，每个会话关联一个终端，会话由会话首进程创建，在xshell或WinSCP打开一个窗口就是新建一个会话</p><h4 id="6、当终端退出，运行在终端的进程会怎样"><a href="#6、当终端退出，运行在终端的进程会怎样" class="headerlink" title="6、当终端退出，运行在终端的进程会怎样"></a>6、当终端退出，运行在终端的进程会怎样</h4><p>当终端退出时，会发送SIGHUP信号给bash进程，bash进程会接着将信号发送给session下面是进程，如果SIGHUP信号没有特殊设定，进程会终止</p><h4 id="7、如何让进程在后台运行"><a href="#7、如何让进程在后台运行" class="headerlink" title="7、如何让进程在后台运行"></a>7、如何让进程在后台运行</h4><p>命令+&amp;，进入队列</p><p>ctrl+z挂起进程，job获得序号，bg %序号继续运行</p><p>nobup+&amp;，重定向到nohub.out文件，忽略hup信号</p><p>setsid+指令，父进程编程init子进程，不受hup信号</p><p>(命令+&amp;)，进程不受HUP影响</p><h4 id="8、进程终止方式"><a href="#8、进程终止方式" class="headerlink" title="8、进程终止方式"></a>8、进程终止方式</h4><p>main函数中return的自然返回</p><p>exit：属于C函数库（封装了——exit）</p><p>_exit：系统调用</p><p>abort：函数，异常程序终止，发送SIGABRT&#x2F;ˌsɪɡəˈbɔːrt&#x2F;给调用进程</p><p>能导致进程终止的信号Ctrl+C，会发送SIGINT&#x2F;ˌsɪɡˈɪnt&#x2F;信号向前台进程组</p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20250327183951577.png" alt="image-20250327183951577" style="zoom:33%;" />]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络（四）：其他</title>
      <link href="/my_tech_blog.github.io/2025/11/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_4/"/>
      <url>/my_tech_blog.github.io/2025/11/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_4/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网络（三）：其他"><a href="#计算机网络（三）：其他" class="headerlink" title="计算机网络（三）：其他"></a>计算机网络（三）：其他</h1><h2 id="一、攻击"><a href="#一、攻击" class="headerlink" title="一、攻击"></a>一、攻击</h2><h3 id="（一）DDos攻击"><a href="#（一）DDos攻击" class="headerlink" title="（一）DDos攻击"></a>（一）DDos攻击</h3><p>客户端向服务器发送请求链接数据包，服务器向客户端发送确认请求链接数据包，客户端不回应，服务器一直等待</p><p>没有彻底根治的方法，除非不使用TCP，预防：<br>限制同时打开的半连接的SYN的数目（资源有限的中小型系统，可能误杀合法连接，但保护彻底）；缩短SYN半连接的time out时间；关闭不必要的服务</p><h4 id="1、SYN攻击"><a href="#1、SYN攻击" class="headerlink" title="1、SYN攻击"></a>1、SYN攻击</h4><p>客户端短时间内伪造大量不存在的IP地址，向服务器发送SYN，服务器发送ACK，但是由于原地址不存在，服务器不断发送到超时，正常请求的SYN因为队列已满而被抛弃，网络拥塞甚至瘫痪</p><p>大量半连接且源地址IP是随机的</p><p>检测：Linux的netstats</p><p>防御：缩短超时时间，增加最大半连接数（高带宽、高性能服务器，消耗更多资源，但用户体验更好），过滤网关防护，SYN cookie技术</p><h3 id="（二）SQL注入攻击"><a href="#（二）SQL注入攻击" class="headerlink" title="（二）SQL注入攻击"></a>（二）SQL注入攻击</h3><p>在http请求中注入恶意的SQL代码，服务器使用参数构造数据库SQL命令时，恶意SQL被一起构造，并在数据库中执行</p><h4 id="Web端预防"><a href="#Web端预防" class="headerlink" title="Web端预防"></a>Web端预防</h4><p>有效性检验；</p><h4 id="服务端预防"><a href="#服务端预防" class="headerlink" title="服务端预防"></a>服务端预防</h4><p>限制长度；有效性检验；不用拼接的SQL字符；过滤特殊字符（‘、“）；使用预编译的PrepareStatement（预编译的 SQL 语句对象，允许将 SQL 语句中的参数用占位符（?）表示，并在执行时动态设置这些参数）</p><h3 id="（三）XSS攻击"><a href="#（三）XSS攻击" class="headerlink" title="（三）XSS攻击"></a>（三）XSS攻击</h3><p>跨站点脚本攻击，篡改网页，用户浏览网页时，操控用户的浏览器进行恶意操作</p><h4 id="1、如何防范XSS攻击"><a href="#1、如何防范XSS攻击" class="headerlink" title="1、如何防范XSS攻击"></a>1、如何防范XSS攻击</h4><p>对输入数据进行过滤处理</p><p>前端、服务端限制输入数据长度，对HTML进行转义处理</p><h3 id="（四）CSRF攻击"><a href="#（四）CSRF攻击" class="headerlink" title="（四）CSRF攻击"></a>（四）CSRF攻击</h3><p>跨站点请求伪造，利用合法的用户信息进行非法操作（盗用身份，向第三方网站发送恶意请求）</p><h4 id="1、如何防范CSRF攻击"><a href="#1、如何防范CSRF攻击" class="headerlink" title="1、如何防范CSRF攻击"></a>1、如何防范CSRF攻击</h4><p>安全框架</p><p>token机制</p><p>验证码</p><p>referer识别，记录HTTP请求的来源地址</p><h2 id="二、其他安全问题"><a href="#二、其他安全问题" class="headerlink" title="二、其他安全问题"></a>二、其他安全问题</h2><h3 id="（一）文件上传漏洞"><a href="#（一）文件上传漏洞" class="headerlink" title="（一）文件上传漏洞"></a>（一）文件上传漏洞</h3><h4 id="1、原因"><a href="#1、原因" class="headerlink" title="1、原因"></a>1、原因</h4><p>用户上传一个可执行脚本文件，通过运行该脚本文件，获得了执行服务端命令的能力</p><h4 id="2、防范"><a href="#2、防范" class="headerlink" title="2、防范"></a>2、防范</h4><p>文件上传的目录设为不可执行</p><p>判断文件类型；白名单；重命名；限制上传文件大小；单独设置文件服务器的域名</p><h2 id="三、其他问题"><a href="#三、其他问题" class="headerlink" title="三、其他问题"></a>三、其他问题</h2><h2 id="（一）会话管理"><a href="#（一）会话管理" class="headerlink" title="（一）会话管理"></a>（一）会话管理</h2><h4 id="1、如何通过-HTTP-实现会话管理"><a href="#1、如何通过-HTTP-实现会话管理" class="headerlink" title="1、如何通过 HTTP 实现会话管理"></a>1、如何通过 HTTP 实现会话管理</h4><p>Cookie机制；Token方案；服务端Session存储</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 攻击 </tag>
            
            <tag> 安全 </tag>
            
            <tag> 面试问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络（三）：传入URL到网页显示</title>
      <link href="/my_tech_blog.github.io/2025/11/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_3/"/>
      <url>/my_tech_blog.github.io/2025/11/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_3/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网络（三）：传入URL到网页显示"><a href="#计算机网络（三）：传入URL到网页显示" class="headerlink" title="计算机网络（三）：传入URL到网页显示"></a>计算机网络（三）：传入URL到网页显示</h1><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20250428152626485.png" alt="image-20250428152626485" style="zoom:67%;" /><p>输入URL，解析URL-&gt;查看浏览器缓存没有-&gt;操作系统缓存没有-&gt;本机host文件没有-&gt;根据域名进行DNS域名解析-&gt;得到IP地址，进行TCP连接-&gt;TLS&#x2F;SSL连接（HTTPS）-&gt;向IP地址发送HTTP请求（生成HTTP报文并封装网络数据包：MAC头是通过ARP根据IP得到服务器MAC（同一局域网）&#x2F;默认网关MAC（不同网络））-&gt;数据传输（交换机、路由器：MAC地址会重写）-&gt;服务器处理请求-&gt;服务器响应，返回响应报文（HTTP头+html）-&gt;浏览器解析HTML-&gt;请求html中元素，返回-&gt;浏览器渲染-&gt;TCP断开（四次挥手）</p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20250428155200617.png" alt="image-20250428155200617" style="zoom: 33%;" /><p>通过DNS获取到IP后，可以把HTTP的传输工作交给操作系统的协议栈</p><p>协议栈上面的部分会向下面的部分委托工作，下面的部分收到委托的工作并执行</p><h2 id="一、URL"><a href="#一、URL" class="headerlink" title="一、URL"></a>一、URL</h2><p>访问数据的协议:+&#x2F;&#x2F;服务器的名称（服务器域名）+数据源（文件）的路径名（&#x2F;是Web服务的根目录）（刻省略，会访问根目录下事先设置的默认文件）</p><h2 id="二、缓存"><a href="#二、缓存" class="headerlink" title="二、缓存"></a>二、缓存</h2><p>避免发送HTTP请求，缓存在本地</p><h3 id="（一）实现方式"><a href="#（一）实现方式" class="headerlink" title="（一）实现方式"></a>（一）实现方式</h3><p>强制缓存（只要没有过期，就直接使用缓存）和协商缓存（304，服务端告知客户端是否可以使用缓存）</p><h3 id="（二）问题"><a href="#（二）问题" class="headerlink" title="（二）问题"></a>（二）问题</h3><h4 id="1、私有和共用字段"><a href="#1、私有和共用字段" class="headerlink" title="1、私有和共用字段"></a>1、私有和共用字段</h4><p>private指令规定了将资源作为私有资源，只能被用户单独使用，一般存储在用户浏览器中</p><p>pubilc指令规定了将资源作为共有资源，可以被多个用户使用，一般存储在代理服务器中</p><h4 id="2、如何保证缓存是最新的（缓存过期机制）"><a href="#2、如何保证缓存是最新的（缓存过期机制）" class="headerlink" title="2、如何保证缓存是最新的（缓存过期机制）"></a>2、如何保证缓存是最新的（缓存过期机制）</h4><p>max-age出现在请求报文，并且缓存资源的缓存时间小于该值，接受缓存</p><p>max-age出现在响应报文，表示缓存资源在缓存服务器中保存的时间</p><p>Expires首部字段也可以用于告知缓存服务器该资源什么时候过期</p><p>HTTP1.1会优先处理max-age，1.0会忽略</p><h4 id="3、如何禁用缓存，如何确认缓存"><a href="#3、如何禁用缓存，如何确认缓存" class="headerlink" title="3、如何禁用缓存，如何确认缓存"></a>3、如何禁用缓存，如何确认缓存</h4><p>HTTP&#x2F;1.1使用cache-Control首部字段控制缓存</p><p>no-store：不能对请求或响应的任何一部分进行缓存</p><p>no-cache强制确认缓存，有效才能使用该缓存进行响应</p><h2 id="三、域名"><a href="#三、域名" class="headerlink" title="三、域名"></a>三、域名</h2><h3 id="（一）层级关系"><a href="#（一）层级关系" class="headerlink" title="（一）层级关系"></a>（一）层级关系</h3><p>使用句点来分隔不同层级的域名，越靠右层级越高，实际上域名最后有一个.代表根域名</p><p>根DNS服务器(.)，根域的DNS服务器信息保存在互联网中所有的DNS服务器中</p><p>顶级域DNS服务器(.com)</p><p>权威DNS服务器(server.com)</p><h3 id="（二）域名解析"><a href="#（二）域名解析" class="headerlink" title="（二）域名解析"></a>（二）域名解析</h3><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20250428153950204.png" alt="image-20250428153950204" style="zoom:50%;" /><p>浏览器看本身缓存，操作系统缓存，hosts文件</p><p>客户端向本地DNS服务器（在TCP&#x2F;IP中设置的DNS服务器地址，114.114.114.114是电信提供的公用DNS服务器）询问DNS的IP地址，本地DNS服务器在缓存中查找，有则直接返回，没有则下一步</p><p>本地DNS服务器向根DNS服务器查询（所有DNS服务器都保存了根DNS服务器的信息），根DNS服务器返回给本地DNS服务器顶级DNS服务器地址</p><p>本地DNS服务器向顶级DNS服务器查询，顶级DNS服务器返回权威DNS服务器地址</p><p>本地DNS服务器向权威DNS服务器查询，权威DNS服务器（DNS解析结果的原出处）返回IP地址</p><p>本地DNS将IP地址返回客户端，客户端和目标建立连接</p><h3 id="（三）DNS"><a href="#（三）DNS" class="headerlink" title="（三）DNS"></a>（三）DNS</h3><h4 id="1、定义"><a href="#1、定义" class="headerlink" title="1、定义"></a>1、定义</h4><p>DNS：域名解析服务53，域名和IP地址相互映射的分布式数据库</p><p>域名解析（主机名解析）：根据主机名得到IP地址</p><h4 id="2、工作原理"><a href="#2、工作原理" class="headerlink" title="2、工作原理"></a>2、工作原理</h4><p>根据主机域名得到IP地址，是应用层协议，底层是UDP</p><p>主机-&gt;本地（递归，直接返回结果）；本地-&gt;根（迭代，返回地址）</p><p>Host文件（手动配置的，优先级最高）-&gt;浏览器缓存-&gt;操作系统缓存-&gt;本地域名服务器（网络接入服务商）-&gt;本向根域名服务器.com（双向）-&gt;本向顶级-&gt;本向权威（负责存储并直接提供特定域名）-&gt;本返回给客户端（存储在缓存）</p><h4 id="3、为什么域名解析使用UDP"><a href="#3、为什么域名解析使用UDP" class="headerlink" title="3、为什么域名解析使用UDP"></a>3、为什么域名解析使用UDP</h4><p>客户端查询DNS服务器</p><p>只需要一个请求一个一个应答，速度快，传输内容不能超过512字节</p><p>重试机制、超时机制</p><h4 id="4、为什么区域传送用TCP"><a href="#4、为什么区域传送用TCP" class="headerlink" title="4、为什么区域传送用TCP"></a>4、为什么区域传送用TCP</h4><p>服务器间进行域传递</p><p>主域名服务器向从域名服务器传输整个区域的数据时</p><p>可靠性好，传输内容大</p><h4 id="5、DNS负载均衡是什么策略"><a href="#5、DNS负载均衡是什么策略" class="headerlink" title="5、DNS负载均衡是什么策略"></a>5、DNS负载均衡是什么策略</h4><p>在DNS服务器中，一个域名可以配置多个IP地址，当客户端发起DNS查询时，DNS服务器会根据负载均衡策略，从多个服务器中选择一个返回给客户端</p><p>轮询（每个节点数据相同）、加权轮询、给予地理位置（一致性哈希）、最小连接树（连接到节点最少的服务器）</p><h5 id="（1）一致性哈希"><a href="#（1）一致性哈希" class="headerlink" title="（1）一致性哈希"></a>（1）一致性哈希</h5><p>解决：分布式系统在扩容或者缩容时，发生过多的数据迁移的问题</p><p>特点：对2^32取模的结果组成一个圆环，在移除或添加节点时，尽可能小的改变以经存在的key的映射关系</p><p>步骤：对存储节点（IP地址等）做哈希映射；对数据进行哈希映射，找到映射后顺时针距离最近的节点</p><p>影响：该节点在哈希环上顺时针相邻的后继节点</p><p>问题：减少了数据迁移量，但是存在节点分布不均的问题</p><p>解决（带虚拟节点的一致性哈希）：通过虚拟节点提高均衡度，同时还提高了稳定度</p><h2 id="四、TCP三次握手"><a href="#四、TCP三次握手" class="headerlink" title="四、TCP三次握手"></a>四、TCP三次握手</h2><p>确保双方都有发送和接收的能力</p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20250428164308316.png" alt="image-20250428164308316" style="zoom: 33%;" /><p>客户端和服务器都处于CLOSED状态，先是服务器主动监听某个端口，处于LISTEN状态</p><p>客户端connect()：客户端主动打开，服务器被动打开</p><p>CLOSED客户端SYN_SEND-&gt;LISTEN服务器（序列号seq&#x3D;x，SYN&#x3D;1）；服务器-SYN_RCVD-&gt;客户端（序列号seq&#x3D;y，确认号ack&#x3D;x+1，SYN&#x3D;1，ACK&#x3D;1）；客户端ESTABLISH-&gt;服务器ESTABLISH（序列号seq&#x3D;x+1，确认号&#x3D;y+1，ACK&#x3D;1）</p><h3 id="（）问题"><a href="#（）问题" class="headerlink" title="（）问题"></a>（）问题</h3><h4 id="1、ISN（初始序列号）的生成"><a href="#1、ISN（初始序列号）的生成" class="headerlink" title="1、ISN（初始序列号）的生成"></a>1、ISN（初始序列号）的生成</h4><p>M+F</p><p>动态生成</p><h4 id="2、TCP连接与HTTP请求"><a href="#2、TCP连接与HTTP请求" class="headerlink" title="2、TCP连接与HTTP请求"></a>2、TCP连接与HTTP请求</h4><h5 id="（1）一个TCP连接可以对应几个HTTP请求"><a href="#（1）一个TCP连接可以对应几个HTTP请求" class="headerlink" title="（1）一个TCP连接可以对应几个HTTP请求"></a>（1）一个TCP连接可以对应几个HTTP请求</h5><p>一对多，持久连接，有时候刷新连接不需要重新建立SSL连接</p><h5 id="（2）一个TCP连接中HTTP请求可以一起发送吗"><a href="#（2）一个TCP连接中HTTP请求可以一起发送吗" class="headerlink" title="（2）一个TCP连接中HTTP请求可以一起发送吗"></a>（2）一个TCP连接中HTTP请求可以一起发送吗</h5><p>HTTP1中不可以：顺序处理多个请求；建立多个TCP连接</p><p>HTTP2中可以</p><h4 id="3、浏览器对同一Host建立TCP连接的数量有没有限制"><a href="#3、浏览器对同一Host建立TCP连接的数量有没有限制" class="headerlink" title="3、浏览器对同一Host建立TCP连接的数量有没有限制"></a>3、浏览器对同一Host建立TCP连接的数量有没有限制</h4><p>有，Chrome最多六个</p><h4 id="4、服务端最多的TCP连接数"><a href="#4、服务端最多的TCP连接数" class="headerlink" title="4、服务端最多的TCP连接数"></a>4、服务端最多的TCP连接数</h4><p>客户端IP数（2^32）*客户端端口数（2^16），但是收到文件描述符限制</p><h4 id="5、怎么查看TCP连接状态"><a href="#5、怎么查看TCP连接状态" class="headerlink" title="5、怎么查看TCP连接状态"></a>5、怎么查看TCP连接状态</h4><p>Linux使用netstat -napt</p><h4 id="6、为什么需要三次握手，两次、四次不行吗"><a href="#6、为什么需要三次握手，两次、四次不行吗" class="headerlink" title="6、为什么需要三次握手，两次、四次不行吗"></a>6、为什么需要三次握手，两次、四次不行吗</h4><h5 id="阻止重复历史连接"><a href="#阻止重复历史连接" class="headerlink" title="阻止重复历史连接"></a>阻止重复历史连接</h5><p>防止历史连接初始化连接（服务器需要收到客户端的ACK然后进入Established阶段）：客户端发现服务器的确认号不是自己期望的，发送RST报文释放连接</p><h5 id="确保双方都有接收和发送的能力"><a href="#确保双方都有接收和发送的能力" class="headerlink" title="确保双方都有接收和发送的能力"></a>确保双方都有接收和发送的能力</h5><p>第一次握手：客户端了解到自己的发送能力是没有问题的；服务器了解掉客户端的发送、服务器的接收</p><p>第二次握手：服务器了解到客户端的发送能力和服务器的接收能力没有问题；客户端了解到客户端的发送、接收能力、服务器的发送能力、接收能力</p><p>第三次握手：服务器了解到客户端的发送、接收能力、服务器的发送能力、接收能力没问题</p><h5 id="同步双方序列号"><a href="#同步双方序列号" class="headerlink" title="同步双方序列号"></a>同步双方序列号</h5><h5 id="避免资源浪费"><a href="#避免资源浪费" class="headerlink" title="避免资源浪费"></a>避免资源浪费</h5><p>收到客户端ACK才会建立连接，防止超时重发SYN导致建立多个连接资源浪费</p><h5 id="三次就可以建立可靠连接，不需要四次握手"><a href="#三次就可以建立可靠连接，不需要四次握手" class="headerlink" title="三次就可以建立可靠连接，不需要四次握手"></a>三次就可以建立可靠连接，不需要四次握手</h5><h5 id="（2）三次握手可以携带数据吗"><a href="#（2）三次握手可以携带数据吗" class="headerlink" title="（2）三次握手可以携带数据吗"></a>（2）三次握手可以携带数据吗</h5><p>第一次（恶意攻击服务器，消耗服务器时间、内存）、第二次不可以</p><p>第三次可以，此时客户端已经ESTABLISH</p><h5 id="（3）为什么建立TCP连接时，初始化序列号都不一样"><a href="#（3）为什么建立TCP连接时，初始化序列号都不一样" class="headerlink" title="（3）为什么建立TCP连接时，初始化序列号都不一样"></a>（3）为什么建立TCP连接时，初始化序列号都不一样</h5><p>为了防止历史报文被下一个相同四元组的连接接收</p><h5 id="（5）为什么需要四次挥手"><a href="#（5）为什么需要四次挥手" class="headerlink" title="（5）为什么需要四次挥手"></a>（5）为什么需要四次挥手</h5><p>保证服务器报文也都发送完毕</p><h5 id="（6）丢失"><a href="#（6）丢失" class="headerlink" title="（6）丢失"></a>（6）丢失</h5><p>SYN报文丢失会重传</p><p>SYN+ACK报文丢失，SYN和SYN+ACK报文都会重传</p><p>ACK 报文是不会有重传的，当 ACK 丢失了，就由对方重传对应的报文（2MSL会重置）</p><h2 id="五、5、SSL-TLS"><a href="#五、5、SSL-TLS" class="headerlink" title="五、5、SSL&#x2F;TLS"></a>五、5、SSL&#x2F;TLS</h2><h3 id="（一）定义"><a href="#（一）定义" class="headerlink" title="（一）定义"></a>（一）定义</h3><p>保护网络通讯安全的协议，主要用于客户端和服务器之间建立加密连续</p><h3 id="（二）作用"><a href="#（二）作用" class="headerlink" title="（二）作用"></a>（二）作用</h3><p>数据加密、身份验证、数据完整性</p><h3 id="（三）加密机制"><a href="#（三）加密机制" class="headerlink" title="（三）加密机制"></a>（三）加密机制</h3><p>混合加密</p><p>非对称加密：用于密钥交换和身份验证；使用一对密钥，公钥加密，私钥解密</p><p>对称加密：用于数据传输；使用一个密钥（运算速度快，避免了使用非对称加密耗时长；无法安全的将密钥传输给通信方）</p><h3 id="（四）四次握手过程"><a href="#（四）四次握手过程" class="headerlink" title="（四）四次握手过程"></a>（四）四次握手过程</h3><p>握手阶段：</p><p>客户端发送支持的SSL&#x2F;TLS版本、加密套件列表和一个随机数（CR）</p><p>服务器选择SSL&#x2F;TLS版本、加密套件和一个随机数（SR），同时发送数字证书，包含公钥</p><p>客户端验证服务器的数字证书（通过浏览器或操作系统的CA公钥），用公钥加密随机数（预主密钥PS），还有包含所有握手消息的哈希（供服务端校验）生成finished消息，使用预三个随机数生成会话密钥</p><p>服务器使用私钥解密，第三个随机数密钥；服务器使用三个随机数生成会话密钥；服务器发送finished消息（包含所有握手消息的哈希（供客户端校验）），验证握手是否成功</p><p>双方校验Finished消息</p><p>加密通信阶段：</p><p>客户端和服务器使用主密钥生成对称密钥进行加密和解密通信内容</p><p>2RTT（4次消息交互，但是2次网络往返）</p><h3 id="（五）三次握手过程"><a href="#（五）三次握手过程" class="headerlink" title="（五）三次握手过程"></a>（五）三次握手过程</h3><p>客户端发送CR和密钥交换参数（PS改为基于DH的共享密钥）</p><p>1RTT（3次消息交互，但是1次网络往返）</p><ul><li><strong>Client Hello</strong> → <strong>Server Hello + Certificate + Finished</strong> → <strong>Client Finished</strong></li></ul><h3 id="（六）HTTP（超文本传输协议）和HTTPS（超文本传输安全协议）"><a href="#（六）HTTP（超文本传输协议）和HTTPS（超文本传输安全协议）" class="headerlink" title="（六）HTTP（超文本传输协议）和HTTPS（超文本传输安全协议）"></a>（六）HTTP（超文本传输协议）和HTTPS（超文本传输安全协议）</h3><p>无状态协议（每次请求都是独立的）；用于客户端和服务器之间传输超文本数据；半双工（不能同时发送和接收，是交替进行的；服务器不能主动推送数据）</p><p>两点之间传输超文本（文字、图片、视频的混合体，有超链接可以实现跳转）数据的约定和规范</p><h4 id="1、HTTP请求过程"><a href="#1、HTTP请求过程" class="headerlink" title="1、HTTP请求过程"></a>1、HTTP请求过程</h4><p>连接、请求、响应、解析呈现并断开连接</p><p>域名解析-&gt;TCP三次握手连接-&gt;客户端发送HTTP请求-&gt;服务器响应发送html-&gt;客户端收到html进行解析-&gt;请求html中元素（通过TCP）-&gt;呈现-&gt;TCP四次挥手断开连接</p><h4 id="2、HTTP和HTTS的区别"><a href="#2、HTTP和HTTS的区别" class="headerlink" title="2、HTTP和HTTS的区别"></a>2、HTTP和HTTS的区别</h4><p>HTTP是明文传输数据，HTTPS是通过SSL进行握手加密传输数据的</p><p>HTTPS是让HTTP先和SSL通信再让SSL和TCP通信，使用了隧道进行通信</p><p>HTTPS需要到ca申请证书，来保证服务器的身份是可信的</p><p>http使用80端口，https使用443端口</p><h5 id="（1）HTTP缺点"><a href="#（1）HTTP缺点" class="headerlink" title="（1）HTTP缺点"></a>（1）HTTP缺点</h5><p>使用明文，可能被窃听</p><p>不验证对方身份，可能伪装、冒充</p><p>无法验证报文完整性，可能被篡改</p><h5 id="（2）HTTTS的解决"><a href="#（2）HTTTS的解决" class="headerlink" title="（2）HTTTS的解决"></a>（2）HTTTS的解决</h5><p>混合加密（公钥加密，私钥解密+会话密钥加解密）：信息加密；</p><p>摘要算法（哈希函数）+数字签名（私钥加密摘要，公钥解密验证）：校验机制</p><p>数字证书（包含公钥）：身份验证</p><h3 id="（七）问题"><a href="#（七）问题" class="headerlink" title="（七）问题"></a>（七）问题</h3><h4 id="1、如何保证公钥不被篡改"><a href="#1、如何保证公钥不被篡改" class="headerlink" title="1、如何保证公钥不被篡改"></a>1、如何保证公钥不被篡改</h4><p>公钥放在数字证书中，只要证书是可信的，公钥就是可信的</p><h5 id="2、SSL中证书是什么"><a href="#2、SSL中证书是什么" class="headerlink" title="2、SSL中证书是什么"></a>2、SSL中证书是什么</h5><p>数字证书认证机构CA是一个客户端和服务器均信任的第三方机构，当服务器运营者向CA发出公开密钥申请，CA对判明申请者的身份，对已申请的公开密钥进行数字签名，将带有数字签名的密钥放入公开密钥证书并绑定，分配给服务器，当进行SSL连接时，客户端获得其中的公开密钥后，先使用数字签名进行验证，验证通过就可以开始通讯了</p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20250429104751925.png" alt="image-20250429104751925" style="zoom:67%;" /><h5 id="3、缺陷"><a href="#3、缺陷" class="headerlink" title="3、缺陷"></a>3、缺陷</h5><p>RSA 密钥协商算法不支持前向保密：因为预主密钥（PS）的加密依赖服务器的长期 RSA 私钥，一旦私钥泄露，历史会话可被解密。</p><p>ECDHE 密钥协商算法支持前向保密：通过临时密钥交换，确保每次会话的密钥独立性。</p><h2 id="六、HTTP报文"><a href="#六、HTTP报文" class="headerlink" title="六、HTTP报文"></a>六、HTTP报文</h2><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20250428153042387.png" alt="image-20250428153042387" style="zoom:50%;" /><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20250428153053372.png" alt="image-20250428153053372" style="zoom:50%;" /><h3 id="（一）请求行"><a href="#（一）请求行" class="headerlink" title="（一）请求行"></a>（一）请求行</h3><h4 id="1、HTTP请求方法"><a href="#1、HTTP请求方法" class="headerlink" title="1、HTTP请求方法"></a>1、HTTP请求方法</h4><h5 id="（1）get"><a href="#（1）get" class="headerlink" title="（1）get"></a>（1）get</h5><p>请求指定页面的内容，并返回消息主体，（？参数1&amp;参数2）</p><h6 id="①参数写法是固定的吗"><a href="#①参数写法是固定的吗" class="headerlink" title="①参数写法是固定的吗"></a>①参数写法是固定的吗</h6><p>可以自己约定，服务器可以解释出来就行</p><h6 id="②长度限制"><a href="#②长度限制" class="headerlink" title="②长度限制"></a>②长度限制</h6><p>HTTP协议没有限制，是由于数据在URL上，通常是浏览器和服务端的限制，服务端长URL消耗资源多，防止SQL注入</p><h5 id="（2）post"><a href="#（2）post" class="headerlink" title="（2）post"></a>（2）post</h5><p>向指定资源提交数据请求，数据包含在请求体中，可能会导致新的资源的建立和已有资源的修改</p><h5 id="（3）head"><a href="#（3）head" class="headerlink" title="（3）head"></a>（3）head</h5><p>和GET类似，但是响应中没有具体内容，用于获得报头</p><h5 id="（4）PUT（替换）、DELETE（删除）、CONNECT、OPTIONS、TRACE、PATCH"><a href="#（4）PUT（替换）、DELETE（删除）、CONNECT、OPTIONS、TRACE、PATCH" class="headerlink" title="（4）PUT（替换）、DELETE（删除）、CONNECT、OPTIONS、TRACE、PATCH"></a>（4）PUT（替换）、DELETE（删除）、CONNECT、OPTIONS、TRACE、PATCH</h5><h5 id="（5）GET和POST的区别"><a href="#（5）GET和POST的区别" class="headerlink" title="（5）GET和POST的区别"></a>（5）GET和POST的区别</h5><p>GET是获取数据，POST会修改数据</p><p>GET的请求数据放在url中（？参数1&amp;参数2），POST的数据放在请求体</p><p>GET提交有数据大小限制，POST理论上没有</p><p>GET产生一个TCP数据包，浏览器会把header和data一起发送，服务器响应200；POST产生两个数据包，先发送header，服务器返回100continue，再发送data，服务器响应200（浏览器和框架的请求方法）</p><p>GET会被浏览器主动缓存，POST不会，除非手动设置</p><p>本质区别：GET是幂等的，POST不是幂等的（幂等性：一次和多次请求某个资源有相同的副作用，对同一个url请求返回同样的结果，所以GET不可用于数据的增删改这些会有副作用的操作，有重复操作的风险）</p><h6 id="①POST比GET安全吗"><a href="#①POST比GET安全吗" class="headerlink" title="①POST比GET安全吗"></a>①POST比GET安全吗</h6><p>虽然POST的数据在地址栏不可见，但从传输上来说都是不安全的，传输安全只有加密</p><h6 id="②幂等"><a href="#②幂等" class="headerlink" title="②幂等"></a>②幂等</h6><p>幂等性是指对同一操作的多次执行所产生的影响与一次执行的影响相同。</p><p>GET语义约束只用于获取资源，不改变服务器状态，具有可缓存性</p><p>保证幂等：唯一标识符；数据库约束（唯一索引，乐观锁：版本号、时间戳）；状态机；去重表；幂等令牌；消息队列幂等</p><h4 id="2、URL"><a href="#2、URL" class="headerlink" title="2、URL"></a>2、URL</h4><h4 id="3、版本（HTTP1-0、HTTP1-1、HTTP2-0、HTTP3-0）"><a href="#3、版本（HTTP1-0、HTTP1-1、HTTP2-0、HTTP3-0）" class="headerlink" title="3、版本（HTTP1.0、HTTP1.1、HTTP2.0、HTTP3.0）"></a>3、版本（HTTP1.0、HTTP1.1、HTTP2.0、HTTP3.0）</h4><p>HTTP1.0-&gt;1.1长连接、管道（解决了请求的队头阻塞）</p><p>1.0-&gt;2.0多路复用技术的引入，同时将多个资源通过一个TCP连接进行发送，减少了建立多个连接的握手时间（并发传输：解决了HTTP的客户端队头阻塞）；头部压缩；二进制格式；服务器推送（但受限于初始请求）</p><p>2.0-&gt;3.0基于新的传输层协议QUIC（基于UDP，通过重传机制和序号控制实现可靠传输，内置快速握手，使用TLS加密，支持多流并行传输）：解决队头阻塞（解决TCP的队头阻塞），更快建立连接（1RTT连接），强制加密，迁移连接（网络切换通过连接ID，不必重新断开再连接）</p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20250429114846925.png" alt="image-20250429114846925" style="zoom:50%;" /><h5 id="（1）HTTP3-0为什么选择基于UDP-相比有什么优势"><a href="#（1）HTTP3-0为什么选择基于UDP-相比有什么优势" class="headerlink" title="（1）HTTP3.0为什么选择基于UDP,相比有什么优势"></a>（1）HTTP3.0为什么选择基于UDP,相比有什么优势</h5><p>解决队头阻塞：多路复用，每个流独立传输，丢失的包仅影响当前流</p><p>极速连接：0-RTT（对已知服务器可立即发送数据）；1-RTT（新连接仅需往返1次）</p><p>无缝连接迁移：通过连接ID标识连接，IP变化（网络从WLAN-&gt;移动）不会影响会话</p><p>强化安全性：强制加密；0-RTT数据通过特殊令牌（单次令牌）防止重放（攻击者截获合法通信数据包后，在后续时间重新发送这些数据包以达到欺骗目的）</p><h5 id="（2）为什么改造UDP而不是TCP"><a href="#（2）为什么改造UDP而不是TCP" class="headerlink" title="（2）为什么改造UDP而不是TCP"></a>（2）为什么改造UDP而不是TCP</h5><p>TCP协议栈由内核实现，修改需跨平台适配</p><p>避免中间设备干扰：许多网络设备对TCP有特殊处理</p><p>UDP仅提供基本端口功能，可自定义实现可靠性、拥塞控制等</p><h5 id="（3）http1-1"><a href="#（3）http1-1" class="headerlink" title="（3）http1.1"></a>（3）http1.1</h5><p>优点：简单；灵活和易于扩展；应用广泛和跨平台</p><p>缺点：无状态（使用长连接解决）、明文传输、请求-应答模式导致队头堵塞（管道网络传输可以解决请求队头堵塞）</p><h5 id="（4）http1-1优化"><a href="#（4）http1-1优化" class="headerlink" title="（4）http1.1优化"></a>（4）http1.1优化</h5><p>避免HTTP请求发送：缓存</p><p>减少HTTP发送：减少重定向（将原本由客户端处理的重定向请求，交给代理服务器处理）；资源合并；按需访问</p><p>压缩响应资源：</p><h3 id="（三）消息头"><a href="#（三）消息头" class="headerlink" title="（三）消息头"></a>（三）消息头</h3><p>Content-Length：数据长度，防止TCP粘包</p><p>Connection：长连接</p><h4 id="2、长连接和短连接的区别"><a href="#2、长连接和短连接的区别" class="headerlink" title="2、长连接和短连接的区别"></a>2、长连接和短连接的区别</h4><p>http1.0默认短连接，客户端和服务器每进行一次HTTP操作就建立一次连接，任务结束就中断连接</p><p>http1.1默认长连接，用以保持连接特性</p><p>缓存</p><p>Set-Cookie：会话管理</p><h4 id="4、Cookie-ˈkʊki-和Session"><a href="#4、Cookie-ˈkʊki-和Session" class="headerlink" title="4、Cookie&#x2F;ˈkʊki&#x2F; 和Session"></a>4、Cookie&#x2F;ˈkʊki&#x2F; 和Session</h4><p>实现会话管理</p><p>http是无状态的，为了服务器可以识别是同一个客户端的请求，保持连接状态</p><h5 id="（1）Cookie用途"><a href="#（1）Cookie用途" class="headerlink" title="（1）Cookie用途"></a>（1）Cookie用途</h5><p>会话状态管理</p><p>个性化设置</p><p>浏览器行为跟踪</p><h5 id="（2）维护用户登录状态-工作原理"><a href="#（2）维护用户登录状态-工作原理" class="headerlink" title="（2）维护用户登录状态&#x2F;工作原理"></a>（2）维护用户登录状态&#x2F;工作原理</h5><p>用户登录提交包含用户名和密码的表单放入http请求报文中</p><p>服务器端收到后检查是否是正确的，如果正确则存入在Redis中，Redis的键是SessionID（<code>SessionID</code> 用来在服务器上查找对应的 <code>Session</code> 数据）</p><p>服务器返回响应报文的Set-Cookie首部字段包含SessionID，客户端将Cookie保存在浏览器，下一次用户请求会带着Cookie，服务器提取出Session，从Redis中取出用户信息，继续业务</p><h5 id="（3）Cookie与Session对比"><a href="#（3）Cookie与Session对比" class="headerlink" title="（3）Cookie与Session对比"></a>（3）Cookie与Session对比</h5><p>Cookie：</p><p>客户端保持状态</p><p>服务器会向用户浏览器发送一小块数据，并保存在浏览器</p><p>会话Cookie：内存中，关闭浏览器自动销毁</p><p>持久Cookie：客户端磁盘上，有效期内多个浏览器代理共享（生命周期是累计的）</p><p>只能存储ACSII码，大小受浏览器限制</p><p>如果禁用，使用重写URL，附加参数</p><p>Session：</p><p>服务器保持状态（更安全）</p><p>用户信息存在服务器端</p><p>生命周期是间隔的：会话是否活跃</p><p>任何数据类型，大小受内存限制</p><p>不能产生容易被猜到的sessionID，经常生成SessionID，重新验证</p><h3 id="（四）状态行"><a href="#（四）状态行" class="headerlink" title="（四）状态行"></a>（四）状态行</h3><h4 id="1、状态码"><a href="#1、状态码" class="headerlink" title="1、状态码"></a>1、状态码</h4><h5 id="1xx（信息性状态码）：信息已被接收，需要继续处理"><a href="#1xx（信息性状态码）：信息已被接收，需要继续处理" class="headerlink" title="1xx（信息性状态码）：信息已被接收，需要继续处理"></a>1xx（信息性状态码）：信息已被接收，需要继续处理</h5><p>100 Continue 客户端应当继续发送请求</p><p>101切换协议</p><h5 id="2xx（成功状态码）：信息已被接收、理解、处理"><a href="#2xx（成功状态码）：信息已被接收、理解、处理" class="headerlink" title="2xx（成功状态码）：信息已被接收、理解、处理"></a>2xx（成功状态码）：信息已被接收、理解、处理</h5><p>200 OK 请求已成功</p><p>201 已创建</p><p>202 已接收</p><p>204没有内容：响应头没有body数据</p><p>206范围请求</p><h5 id="3xx（重定向状态码）：需要客户端进一步处理"><a href="#3xx（重定向状态码）：需要客户端进一步处理" class="headerlink" title="3xx（重定向状态码）：需要客户端进一步处理"></a>3xx（重定向状态码）：需要客户端进一步处理</h5><p>300 多种选择</p><p>301 永久移动、永久性重定向</p><p>302 临时移动</p><p>303 可在另一个URL找到（同302，但要求客户端使用GET）</p><p>304 GET已允许但文档未改变，服务器对缓存有效性的确认</p><p>307 临时重定向（同302，但POST不能该为GET）</p><h5 id="4xx（客户端错误，客户端发送的报文有误）"><a href="#4xx（客户端错误，客户端发送的报文有误）" class="headerlink" title="4xx（客户端错误，客户端发送的报文有误）"></a>4xx（客户端错误，客户端发送的报文有误）</h5><p>400 语法错误</p><p>401 需要认证信息或认证失败</p><p>403 已理解，但是拒绝执行</p><p>404 请求失败，未发现、找不到资源</p><p>405 请求方法不能用于请求相应资源</p><h5 id="5xx（服务器错误，服务器处理时内部发生错误）"><a href="#5xx（服务器错误，服务器处理时内部发生错误）" class="headerlink" title="5xx（服务器错误，服务器处理时内部发生错误）"></a>5xx（服务器错误，服务器处理时内部发生错误）</h5><p>500 执行请求时错误</p><p>501 服务器不支持请求所需的某个功能</p><p>502 访问后端服务器错误</p><p>503服务器处于超载或进行停机维护</p><h2 id="七、TCP报文"><a href="#七、TCP报文" class="headerlink" title="七、TCP报文"></a>七、TCP报文</h2><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20250428163659746.png" alt="image-20250428163659746" style="zoom:50%;" /><p>源端口号（2字节）、目标端口号（2字节）：发送给哪个应用</p><p>序列号(随机初始值+数据在整个字节流中的偏移，解决网络包乱序)-&gt;4字节：解决包乱序；确认号（对方序列号+1）-&gt;4字节：解决丢包</p><p>数据偏移（首部长）：标识首部有多少个4字节*首部长，最大为15（对应头部最大为60，其中40是可选择的选项字段）-&gt;半个字节（4bit）</p><p>标识位（状态位）：URG、ACK（回复：确认号是否有效，确认报文段）、PSH、PST、SYN（发起连接：请求建立一个链接，连接报文段）、FIN（结束连接：关闭连接，断开报文段）-&gt;6bit</p><p>窗口大小：2字节（流量控制，当前的处理能力）；校验和-&gt;2字节；紧急指针-&gt;2字节</p><p>选项：可选，长度&#x3D;(数据偏移*4-20)</p><h3 id="（一）TCP（传输控制协议）"><a href="#（一）TCP（传输控制协议）" class="headerlink" title="（一）TCP（传输控制协议）"></a>（一）TCP（传输控制协议）</h3><p>传输控制协议，面向连接的（是否需要建立连接来保证数据传输）、可靠的（序列号与确认号，重传机制、流量控制、拥塞控制）基于字节流的传输层协议</p><h3 id="（二）可靠"><a href="#（二）可靠" class="headerlink" title="（二）可靠"></a>（二）可靠</h3><h4 id="1、TCP协议如何保证可靠传输"><a href="#1、TCP协议如何保证可靠传输" class="headerlink" title="1、TCP协议如何保证可靠传输"></a>1、TCP协议如何保证可靠传输</h4><p>确认和重传</p><p>数据校验</p><p>数据分片和排序</p><p>滑动窗口</p><p>流量控制</p><p>拥塞控制</p><h4 id="2、首部校验能保证数据传输不会出错吗"><a href="#2、首部校验能保证数据传输不会出错吗" class="headerlink" title="2、首部校验能保证数据传输不会出错吗"></a>2、首部校验能保证数据传输不会出错吗</h4><p>不能，使用（伪首部、TCP首部、TCP数据）累加求和后取末位</p><p>使用MD5加密数据获得摘要，到达后也进行MD5加密，看算法一致</p><h4 id="3、TCP重传"><a href="#3、TCP重传" class="headerlink" title="3、TCP重传"></a>3、TCP重传</h4><p>数据包丢失或者ACK丢失</p><h5 id="（1）超时重传"><a href="#（1）超时重传" class="headerlink" title="（1）超时重传"></a>（1）超时重传</h5><p>时间驱动：超过RTO没有收到ACK</p><p>RTO：重传间隔，两次数据发送之间的时间间隔，一般第一次RTO略大于RTT，通常是上一次RTO的两倍，计量单位通常是RTT</p><p>RTT：数据从发送到收到确认的时间间隔</p><h5 id="（2）快速重传"><a href="#（2）快速重传" class="headerlink" title="（2）快速重传"></a>（2）快速重传</h5><p>数据驱动：收到三个重复ACK</p><h5 id="（3）SACK方法"><a href="#（3）SACK方法" class="headerlink" title="（3）SACK方法"></a>（3）SACK方法</h5><p>选择性确认：只重传丢失的数据</p><h5 id="（4）D-SACK"><a href="#（4）D-SACK" class="headerlink" title="（4）D-SACK"></a>（4）D-SACK</h5><p>数据被重复接收：知道不是自己的数据包丢失了，是ACK丢失或者网络延迟</p><h4 id="4、流量控制"><a href="#4、流量控制" class="headerlink" title="4、流量控制"></a>4、流量控制</h4><p>接收方通过TCP窗口字段告诉发送方能够接受的最大数据量，防止传输过快导致接收方不能有效接受数据（发送方可以根据接收方的实际接收能力控制发送的数据量）。点对点控制</p><p>双工控制，发送方和接收方各自维护一个发送窗和接收窗</p><p>发送窗：限制发送方可以发送的数据大小，由接收方返回报文的TCP窗口字段决定</p><p>接受窗：标记可以接受的数据大小，自己决定</p><h5 id="（1）TCP是流数据："><a href="#（1）TCP是流数据：" class="headerlink" title="（1）TCP是流数据："></a>（1）TCP是流数据：</h5><p>发送数据&#x3D;已发送且已被确认|已发送且未被确认|未发送但可发送|未发送且不可发送；发送窗口swnd&#x3D;已发送且未被确认+未发送但可发送；</p><p>接收数据&#x3D;已接收|未接收但准备接收|未接收且不准备接收；接收窗口rwnd&#x3D;未接收但准备接收</p><p>接收到ACK、接收到数据才移动窗口左侧</p><h5 id="（2）TCP使用滑动窗口实现流量控制"><a href="#（2）TCP使用滑动窗口实现流量控制" class="headerlink" title="（2）TCP使用滑动窗口实现流量控制"></a>（2）TCP使用滑动窗口实现流量控制</h5><p>接收方有多大的缓冲区可以用于接收数据</p><p>滑动窗口为0-&gt;紧急数据；零窗口探测包，强制接收方返回ACK，得到新的窗口大小</p><h5 id="（3）滑动窗口"><a href="#（3）滑动窗口" class="headerlink" title="（3）滑动窗口"></a>（3）滑动窗口</h5><p>实现流量控制和拥塞控制；接收方通过发送方的报文中窗口大小定义滑动窗口的大小；接收方通过ACK报文更新窗口大小</p><p>无需等待确认应答，而是可以继续发送数据的最大值；</p><p>累计确认&#x2F;应答：收到ACK n说明这之前的ACK也都收到了</p><p>接收方的TCP报文中有窗口大小这一字段，可以决定窗口大小</p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20250430185257357.png" alt="image-20250430185257357" style="zoom:67%;" /><p>可用窗口耗尽则在未收到ACK前无法继续发送</p><p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20250430185552888.png" alt="image-20250430185552888" style="zoom:67%;" />、</p><h4 id="5、TCP四大拥塞控制算法"><a href="#5、TCP四大拥塞控制算法" class="headerlink" title="5、TCP四大拥塞控制算法"></a>5、TCP四大拥塞控制算法</h4><h5 id="（1）慢启动：发送方每收到一个ACK，拥塞窗口cwnd-1"><a href="#（1）慢启动：发送方每收到一个ACK，拥塞窗口cwnd-1" class="headerlink" title="（1）慢启动：发送方每收到一个ACK，拥塞窗口cwnd+1"></a>（1）慢启动：发送方每收到一个ACK，拥塞窗口cwnd+1</h5><p>TCP刚建立，一点点提速，试探网络承受能力，避免扰乱了网络通道秩序</p><p>慢启动算法：指数增长</p><p>初始化拥塞窗口cwnd&#x3D;1，可以传输一个MSS大小的数据包</p><p>每当接受到一个ACK，数据包对应一个增长+1</p><p>当过了一个往返延迟时间RTT，cwnd翻倍</p><p>当cwnd到达一个阈值ssthresh&#x2F;ˈɛsˌθrɛʃ&#x2F;（慢启动门限：一般为65535） ，进入拥塞避免算法</p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20250430203447190.png" alt="image-20250430203447190" style="zoom:67%;" /><h5 id="（2）拥塞控制：收到一个ACK，cwnd-cwnd-1-cwnd"><a href="#（2）拥塞控制：收到一个ACK，cwnd-cwnd-1-cwnd" class="headerlink" title="（2）拥塞控制：收到一个ACK，cwnd&#x3D;cwnd+1&#x2F;cwnd"></a>（2）拥塞控制：收到一个ACK，cwnd&#x3D;cwnd+1&#x2F;cwnd</h5><p>到达慢启动之后，防止窗口增长过快导致拥塞，缓慢调整到最佳</p><p>拥塞避免算法：</p><p>收到一个ACK，cwnd&#x3D;cwnd+1&#x2F;cwnd</p><p>RTT，cwnd&#x3D;cwnd+1</p><p>当触发重传机制，进入拥塞发生</p><h5 id="（3）拥塞发生：阈值ssthresh设为cwnd的一半-cwnd设为1；ssthresh-cwnd-cwnd-2"><a href="#（3）拥塞发生：阈值ssthresh设为cwnd的一半-cwnd设为1；ssthresh-cwnd-cwnd-2" class="headerlink" title="（3）拥塞发生：阈值ssthresh设为cwnd的一半+cwnd设为1；ssthresh&#x3D;cwnd+cwnd&#x2F;&#x3D;2"></a>（3）拥塞发生：阈值ssthresh设为cwnd的一半+cwnd设为1；ssthresh&#x3D;cwnd+cwnd&#x2F;&#x3D;2</h5><p>一般丢包是由于网络拥塞导致的，所以可以使用丢包判断此时的网络状态</p><p>判断丢包的两种方式：超时重传超时（当发送数据后就开启一个定时器，在规定时间内没有收到ACK就判定为丢包进行重传）+重复收到三个ACK（快速重传，不需要定时器）</p><h6 id="超时重传："><a href="#超时重传：" class="headerlink" title="超时重传："></a>超时重传：</h6><p>阈值ssthresh设为cwnd的一半；cwnd设为1；进行慢启动</p><p>不利于网络数据的稳定传输</p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20250430204027403.png" alt="image-20250430204027403" style="zoom:50%;" /><h6 id="快速重传："><a href="#快速重传：" class="headerlink" title="快速重传："></a>快速重传：</h6><p>cwnd变为一半；阈值设为当前的cwnd；进入快速恢复算法</p><h5 id="（4）快速恢复"><a href="#（4）快速恢复" class="headerlink" title="（4）快速恢复"></a>（4）快速恢复</h5><p>一般和快速重传一起使用：先减半，+3，</p><p>cwnd&#x3D;cwnd+3*MSS；重传DACKs指定的数据包；如果再次收到DACKs，cwnd+1（解决丢包问题）；如果收到ACK，那么退出快速恢复算法，将cwnd设为阈值，进入拥塞避免算法（缓解拥塞）</p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20250430204220627.png" alt="image-20250430204220627" style="zoom:50%;" /><p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20250325185605942.png" alt="image-20250325185605942"></p><h5 id="（5）为何快速重传是选择3次ACK"><a href="#（5）为何快速重传是选择3次ACK" class="headerlink" title="（5）为何快速重传是选择3次ACK"></a>（5）为何快速重传是选择3次ACK</h5><p>收到1~2个重复ACK可能是乱序造成的，每新包触发1次DupACK</p><h5 id="（6）RTO、RTT、超时重传"><a href="#（6）RTO、RTT、超时重传" class="headerlink" title="（6）RTO、RTT、超时重传"></a>（6）RTO、RTT、超时重传</h5><p>RTO：重传间隔，两次数据发送之间的时间间隔，通常是上一次RTO的两倍，计量单位通常是RTT</p><p>RTT：数据从发送到收到确认的时间间隔</p><p>超时重传：未收到确认，进行重传；没有达到接收端、ACK报文丢失、接收端拒绝或丢弃</p><h5 id="（7）拥塞窗口"><a href="#（7）拥塞窗口" class="headerlink" title="（7）拥塞窗口"></a>（7）拥塞窗口</h5><p>发送方维护的状态量，根据网络的拥塞程度动态变化的swnd&#x3D;min(rwnd,cwnd)</p><p>Linux查看初始cwnd：ss -nli</p><h4 id="6、流量控制和拥塞控制区别"><a href="#6、流量控制和拥塞控制区别" class="headerlink" title="6、流量控制和拥塞控制区别"></a>6、流量控制和拥塞控制区别</h4><p>流量控制：防止缓冲区溢出；点对点流量；接收窗口rwnd（接收方在ACK中携带（TCP头部））</p><p>拥塞控制：防止网络拥塞（链路过载）；发送方和整个网络的全局流量；根据网络状况自适应调整拥塞窗口</p><h3 id="（三）面向连接"><a href="#（三）面向连接" class="headerlink" title="（三）面向连接"></a>（三）面向连接</h3><h4 id="1、常见的TCP状态"><a href="#1、常见的TCP状态" class="headerlink" title="1、常见的TCP状态"></a>1、常见的TCP状态</h4><p>CLOSED：初始状态</p><p>LISTEN：服务器监听状态</p><p>SYN_SENT：客户端Socket执行connect，发送了SYN</p><p>SYN_RCVT：服务端收到SYN并发送SYN</p><p>半连接队列：服务器在此种状态下将请求信息放入队列（哈希表）</p><p>ESTABLISH：建立联系，客户端发送ACK、服务器收到ACK</p><p>全连接队列：将半连接队列中的sock取出（链表）</p><p>FIN_WAIT1：客户端发送FIN</p><p>CLOSE_WAIT：服务器收到FIN，发送ACK，但是没有发送FIN（被动关闭一方还有剩余数据）</p><p>FIN_WAIT2：客户端收到ACK，没收到FIN（半关闭状态，还有接收能力，但是已经没有发送能力）</p><p>LAST_ACK：服务器发送FIN</p><p>TIME_WAIT：客户端收到FIN，并发送ACK给服务器，在此之后的2MSL（报文段在网络中的最大生存时间）时间内</p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20250430162657956.png" alt="image-20250430162657956" style="zoom:50%;" /><p>accept并不在建立连接的过程中，是为了从全连接队列里取出一个已经建立的连接并返回一个新的socket</p><h3 id="（四）基于字节流"><a href="#（四）基于字节流" class="headerlink" title="（四）基于字节流"></a>（四）基于字节流</h3><h4 id="1、TCP分割数据生成报文——拆包"><a href="#1、TCP分割数据生成报文——拆包" class="headerlink" title="1、TCP分割数据生成报文——拆包"></a>1、TCP分割数据生成报文——拆包</h4><p>TCP分片、拆包</p><p>当HTTP消息比较长，超过了MSS的长度，TCP就会对数据（HTTP头部+数据）进行分割，加上TCP头，交给IP模块发送数据</p><p>MSS（最大报文段）：TCP层能传输的最大数据段</p><p>网络拥塞或MTU（最大传输单元）：数据链路层能传输的最大数据包，由硬件规定</p><p>MSS&#x3D;MTU-TCP头部（20字节）-IP头部（20字节）</p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20250428165220599.png" alt="image-20250428165220599" style="zoom:33%;" /><h4 id="2、什么是TCP粘包-拆包（分片、解包）-封包"><a href="#2、什么是TCP粘包-拆包（分片、解包）-封包" class="headerlink" title="2、什么是TCP粘包&#x2F;拆包（分片、解包）&#x2F;封包"></a>2、什么是TCP粘包&#x2F;拆包（分片、解包）&#x2F;封包</h4><p>一个完整的TCP业务可能会被拆分为多个包进行发送，页有可能把多个小包封装成一个大的数据包发送，TCP面向字节流的特性导致，无边界的流传输</p><h5 id="（1）粘包"><a href="#（1）粘包" class="headerlink" title="（1）粘包"></a>（1）粘包</h5><p>由于TCP是基于字节流的，所以数据没有边界，发送方发送的若干个数据包到达接收方时粘成一团</p><p>只能计算当前 TCP 数据段的长度，但无法区分多个应用层消息的边界（用户消息通过TCP协议传输，消息可能会被操作系统分组为多个TCP报文）。</p><h6 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h6><p>TCP连接复用</p><p>TCP默认Nagle算法（只有上一个分组确认才会发送下一个分组），会将小的TCP合并发送，减小网络开销</p><p>发送方每次写入数据 &lt; 接收方套接字(Socket)缓冲区大小，可能导致多个数据包被一次性读取</p><h6 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h6><p>特殊场景关闭Nagle算法</p><p>固定数据包大小</p><p>自定义请求协议PDU</p><p>长度前缀（在消息头部声明包体长度）</p><p>特殊字符结尾（分隔符，如HTTP：回车、换行）</p><h5 id="（2）分片"><a href="#（2）分片" class="headerlink" title="（2）分片"></a>（2）分片</h5><p>传输层MSS分片</p><h6 id="原因-1"><a href="#原因-1" class="headerlink" title="原因"></a>原因</h6><p>MSS（最大报文段）：TCP层能传输的最大数据段</p><p>网络拥塞或MTU（最大传输单元）：数据链路层能传输的最大数据包，由硬件规定</p><p>MSS&#x3D;MTU-TCP头部（20字节）-IP头部（20字节）</p><p>发送方每次写入数据 -&gt; 接收方套接字(Socket)缓冲区大小</p><h6 id="解决-1"><a href="#解决-1" class="headerlink" title="解决"></a>解决</h6><p>PDU</p><p>滑动窗口</p><h5 id="（3）UDP没有粘包问题"><a href="#（3）UDP没有粘包问题" class="headerlink" title="（3）UDP没有粘包问题"></a>（3）UDP没有粘包问题</h5><p>是面向消息的协议，具有保护消息边界,在每个UDP包中就有了消息头(UDP长度、源端口、目的端口、校验和)</p><h5 id="（4）HTTP是如何解决粘包问题"><a href="#（4）HTTP是如何解决粘包问题" class="headerlink" title="（4）HTTP是如何解决粘包问题"></a>（4）HTTP是如何解决粘包问题</h5><p>请求头和请求行以\r\n结束</p><h5 id="（5）封包"><a href="#（5）封包" class="headerlink" title="（5）封包"></a>（5）封包</h5><p>在发送数据报时加上一个包头，数据报分为包头和包体两个部分，包头是固定长度的结构体，包含该数据包的总长度</p><h5 id="（6）解包"><a href="#（6）解包" class="headerlink" title="（6）解包"></a>（6）解包</h5><p>应用层协议自定义行为</p><p>接收方提取包头中的长度信息进行截取</p><h3 id="（二）问题-1"><a href="#（二）问题-1" class="headerlink" title="（二）问题"></a>（二）问题</h3><h4 id="1、建立TCP服务器的各个系统调用过程是怎样的"><a href="#1、建立TCP服务器的各个系统调用过程是怎样的" class="headerlink" title="1、建立TCP服务器的各个系统调用过程是怎样的"></a>1、建立TCP服务器的各个系统调用过程是怎样的</h4><h5 id="（1）服务器"><a href="#（1）服务器" class="headerlink" title="（1）服务器"></a>（1）服务器</h5><p>Socket：创建Socket，协议域（Socket地址类型）、Socket类型（TCP）、指定协议</p><p>bind：绑定Socket和端口号，套接字描述符，被绑的结构变量，地址长度</p><p>listen：监听端口号，套接字描述符、Socket可以排队的最大连接数</p><p>accept：接收用户请求，服务器套接字描述符，指向地址结构指针，协议地址长度；返回新的Socket和客户端地址</p><p>一旦接收用户请求会创建一个新的Socket用于标识具体的客户的TCP连接</p><p>read：从Socket中读取字符，连接描述符、缓冲区、缓冲区长度</p><p>write</p><p>close：关闭Socket</p><h5 id="（2）客户端"><a href="#（2）客户端" class="headerlink" title="（2）客户端"></a>（2）客户端</h5><p>Socket：创建Socket</p><p>connect：连接指定计算机，客户端Socket描述符、服务器地址、Socket地址长度</p><p>write：向Socket写入信息</p><p>read</p><p>close：关闭Socket</p><h4 id="2、TCP对应的应用层协议"><a href="#2、TCP对应的应用层协议" class="headerlink" title="2、TCP对应的应用层协议"></a>2、TCP对应的应用层协议</h4><p>HTTP、DNS、FTP、Telnet、SMTP、POP3</p><h4 id="3、有效端口号"><a href="#3、有效端口号" class="headerlink" title="3、有效端口号"></a>3、有效端口号</h4><p>知名端口号是0~1023，其中http是80，FTP：数据端口是20、控制端口是21</p><p>2的10次方：1024；2的16次方：65536</p><p>UDP和TCP使用两位字节存储端口号，所以有效端口号是0<del>65535，动态端口号1024</del>65535</p><p>对于服务器来说，没有这个限制，受限于可以打开的文件数量，并且可以通过MaxUserPort配置</p><h2 id="（八）IP报文生成"><a href="#（八）IP报文生成" class="headerlink" title="（八）IP报文生成"></a>（八）IP报文生成</h2><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20250428180207139.png" alt="image-20250428180207139" style="zoom:33%;" /><h3 id="（一）IP头部"><a href="#（一）IP头部" class="headerlink" title="（一）IP头部"></a>（一）IP头部</h3><h4 id="协议号"><a href="#协议号" class="headerlink" title="协议号"></a>协议号</h4><p>06代表TCP</p><h3 id="（二）IP"><a href="#（二）IP" class="headerlink" title="（二）IP"></a>（二）IP</h3><p><strong>IP 地址</strong>是一个数字标签，用于唯一标识一个连接到网络的设备</p><p>没有直连的两个网络之间进行通信传输</p><p>网络层协议，无连接协议，不保证数据包的可靠性、顺序性，将数据包从源地址传输到目的地址，可以跨越不同的网络进行路由（IP协议通过路由器在不同网络间转发数据包，由路由器根据目标IP地址决定数据包的转发路径）</p><h4 id="1、IP地址如何工作"><a href="#1、IP地址如何工作" class="headerlink" title="1、IP地址如何工作"></a>1、IP地址如何工作</h4><p>路由和转发</p><p>分配和映射</p><h4 id="2、IPv4与IPv6"><a href="#2、IPv4与IPv6" class="headerlink" title="2、IPv4与IPv6"></a>2、IPv4与IPv6</h4><p>地址长度：32和128</p><p>地址表示：4个十进制数和8个十六进制数</p><p>地址类型：有专门的广播地址和组播、</p><p>头部结构：复杂和简化（不需要校验和）</p><h4 id="3、IP子网掩码，如何计算子网"><a href="#3、IP子网掩码，如何计算子网" class="headerlink" title="3、IP子网掩码，如何计算子网"></a>3、IP子网掩码，如何计算子网</h4><p>32位划分IP地址的网络部分和主机部分</p><p>将IP地址和掩码进行按位与得到网络地址，确定可用主机地址范围（主机部分的位置）</p><h4 id="4、IP地址分类"><a href="#4、IP地址分类" class="headerlink" title="4、IP地址分类"></a>4、IP地址分类</h4><p>A（0：1<del>127）、B（10：128</del>191）、C（110：192~223）、D（1110：组播地址）、E类（1111：预留使用）</p><h4 id="5、IP分片与重组"><a href="#5、IP分片与重组" class="headerlink" title="5、IP分片与重组"></a>5、IP分片与重组</h4><p>当发送方要发送一个超过最大传输单元（MTU）的数据包时，会进行分割（包含目标地址和标识符），目标地址（只能由布标主机重组）收到所有片段后，会根据标识符将其组合</p><p>在分片传输中，如果有一个分片丢失，会导致整个数据包失效，所以TCP引入了MSS，在TCP分片，对于UDP，尽量不要发送一个大于MTU的数据报</p><h3 id="（三）工作"><a href="#（三）工作" class="headerlink" title="（三）工作"></a>（三）工作</h3><p>查看路由表（route -n查看）利用子网掩码（根据Web服务器的目标地址）进行计算选择网卡为源地址IP</p><h2 id="九、MAC包"><a href="#九、MAC包" class="headerlink" title="九、MAC包"></a>九、MAC包</h2><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20250428181753825.png" alt="image-20250428181753825" style="zoom: 33%;" /><h3 id="（一）MAC包头"><a href="#（一）MAC包头" class="headerlink" title="（一）MAC包头"></a>（一）MAC包头</h3><p>发送方和接收方的MAC：用于两点之间的传输</p><p>协议类型：0800IP协议、0806ARP协议</p><h3 id="（二）问题-2"><a href="#（二）问题-2" class="headerlink" title="（二）问题"></a>（二）问题</h3><h4 id="1、MAC的发送方和接收方如何确认"><a href="#1、MAC的发送方和接收方如何确认" class="headerlink" title="1、MAC的发送方和接收方如何确认"></a>1、MAC的发送方和接收方如何确认</h4><p>发送方：生产网卡时写到ROM中</p><p>ARP获得路由器的MAC：先查询ARP缓存（arp -a查看内容），再在以太网中广播</p><h3 id="（三）网卡"><a href="#（三）网卡" class="headerlink" title="（三）网卡"></a>（三）网卡</h3><p>在开头加上报头和起始帧分界符，在末尾加上帧校验序列，网卡驱动程序控制网卡将数字信息转换为电信息</p><h2 id="十、交换机和路由器"><a href="#十、交换机和路由器" class="headerlink" title="十、交换机和路由器"></a>十、交换机和路由器</h2><h5 id="（16）交换机"><a href="#（16）交换机" class="headerlink" title="（16）交换机"></a>（16）交换机</h5><p>交换机工作在MAC层，基于以太网设计，二层网络设备，交换机端口没有MAC地址</p><p>将电信号转化为数字信号，通过包末尾的FXS进行错误校验，没有错误则放入缓冲区。保存有MAC表，保存端口连接的设备的MAC地址，如果MAC表中没有记录或者接收方的地址的广播地址，则会发向除源端口之外的所有端口</p><h5 id="（17）路由器"><a href="#（17）路由器" class="headerlink" title="（17）路由器"></a>（17）路由器</h5><p>基于IP设计，是三层网络设备，每个端口都有IP和MAC地址</p><p>将电信号转化为数字信号，通过包末尾的FXS进行错误校验，检查接收方MAC是否匹配，匹配则放入缓冲区。丢弃MAC头；转发：根据IP头部通过路由表查询转发目标（子网掩码&amp;IP）；发送：网关为空说明到达终点，网关非空通过ARP获得IP的MAC地址，加上MAC包头，将数字信号转换为电信号发送；接着-交换机-路由器-……</p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20250428192635654.png" alt="image-20250428192635654" style="zoom:67%;" /><h3 id="十一、到达服务器"><a href="#十一、到达服务器" class="headerlink" title="十一、到达服务器"></a>十一、到达服务器</h3><p>看MAC是否符合，看IP地址是否符合，看TCP序列号是否是想要的如果是则放入缓存并返回ACK，不是则丢弃，TCP头部中有端口号，HTTP正在监听这个端口号，发送给HTTP进程，进程把网页封装在HTTP响应报文中，-穿上TCP、IP、MAC包头-网卡-交换机-路由器-……-客户端-拆开MAC、IP、TCP包头-交给浏览器渲染页面</p><h3 id="十二、TCP四次挥手"><a href="#十二、TCP四次挥手" class="headerlink" title="十二、TCP四次挥手"></a>十二、TCP四次挥手</h3><p>ESTABLISH客户端FIN_WAIT1-&gt;ESTABLISH服务器（seq&#x3D;x，FIN&#x3D;1）；服务器CLOSE_WAIT-&gt;客户端FIN_WAIT2（seq&#x3D;y，ack&#x3D;x+1，ACK&#x3D;1）；服务器LAST_ACK-&gt;（seq&#x3D;z，ack&#x3D;x+1，FIN，ACK），如果服务器没有发送数据，z&#x3D;y；客户端TIME_WAIT-&gt;服务器（seq&#x3D;x+1，ack&#x3D;z+1，ACK）</p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20250430154327399.png" alt="image-20250430154327399" style="zoom: 33%;" /><h3 id="（一）问题"><a href="#（一）问题" class="headerlink" title="（一）问题"></a>（一）问题</h3><h4 id="1、等待2MSL原因"><a href="#1、等待2MSL原因" class="headerlink" title="1、等待2MSL原因"></a>1、等待2MSL原因</h4><p>MSL是报文最大生存时间，允许丢包一次</p><p>处理网络中延迟的报文（第四次挥手ACK丢失，服务器重传FIN）</p><p>确保对方收到ACK</p><p>避免新旧连接混淆（旧连接报文失效）</p><h4 id="2、服务器出现大量CLOSE-WAIT"><a href="#2、服务器出现大量CLOSE-WAIT" class="headerlink" title="2、服务器出现大量CLOSE_WAIT"></a>2、服务器出现大量CLOSE_WAIT</h4><p>服务器内部业务占用大量资源，没有处理完业务；还有数据没有发送；服务器业务逻辑有问题，没有执行close()方法</p><p>服务器的父进程派生出了子进程，子进程继承该Socket，收到FIN的时候子进程处理但是父进程没有处理，Socket引用不为0，不能回收</p><p>处理方法：停止应用程序；修改程序中bug；检查代码逻辑，确保资源释放</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络体系结构 </tag>
            
            <tag> URL </tag>
            
            <tag> 网络传输 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络（二）：TCP/IP五层模型</title>
      <link href="/my_tech_blog.github.io/2025/11/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_2/"/>
      <url>/my_tech_blog.github.io/2025/11/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_2/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网络（二）：TCP-IP五层模型"><a href="#计算机网络（二）：TCP-IP五层模型" class="headerlink" title="计算机网络（二）：TCP&#x2F;IP五层模型"></a>计算机网络（二）：TCP&#x2F;IP五层模型</h1><p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\1762997968991.png" alt="1762997968991"></p><p>进行不同设备之间的网络通信，而设备是多样的，为了兼容设备多样性，协商一套通用的网络协议</p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20250428150312205.png" alt="image-20250428150312205" style="zoom: 67%;" /><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20250428152230857.png" alt="image-20250428152230857" style="zoom: 50%;" /><h2 id="一、应用层——第五层"><a href="#一、应用层——第五层" class="headerlink" title="一、应用层——第五层"></a>一、应用层——第五层</h2><p>专注于为用户提供服务，用户直接接触</p><p>工作在操作系统的用户态，以下都工作在内核态</p><p>消息或报文</p><p>HTTP、HTTPS、Telnet（远程登录服务的标准协议，23）、FTP（文件传输协议，数据端口是20、控制端口是21）、TFTP（简单文件传输协议，69）、SMTP（简单邮件传输协议，发送25）、POP（邮局协议，接收110）、DNS、DHCP</p><p>WebSocket 是一种基于 TCP 的全双工通信协议（HTTP长连接虽然复用TCP传输多个HTTP请求，但是还是“请求-响应模式”）</p><h3 id="（一）基础协议"><a href="#（一）基础协议" class="headerlink" title="（一）基础协议"></a>（一）基础协议</h3><h4 id="1、DHCP动态主机配置协议"><a href="#1、DHCP动态主机配置协议" class="headerlink" title="1、DHCP动态主机配置协议"></a>1、DHCP动态主机配置协议</h4><p>通过DHCP获得IP地址，DHCP客户端监听68端口，DHCP服务端监听67端口</p><p>客户端发出DHCP发现报文，使用UDP广播：源IP0.0.0.0，目标255.255.255.255</p><p>DHCP服务器用DHCP提供报文，广播或单播</p><p>客户端选择服务器，向其发送DHCP请求报文：UDP广播（通知其他服务器、防止IP冲突）</p><p>服务端用DHCP ACK报文响应，广播或单播</p><h5 id="（1）不在同一个链路"><a href="#（1）不在同一个链路" class="headerlink" title="（1）不在同一个链路"></a>（1）不在同一个链路</h5><p>DHCP中继代理服务器</p><h4 id="2、MQTT协议"><a href="#2、MQTT协议" class="headerlink" title="2、MQTT协议"></a>2、MQTT协议</h4><p>消息队列遥测传输协议，应用层协议，工作在TCP&#x2F;IP协议栈上</p><p>轻量级发布&#x2F;订阅模式消息协议（HTTP：请求&#x2F;响应模型），专门为低带宽、高延迟或不稳定网络设计</p><h5 id="（1）安全保证"><a href="#（1）安全保证" class="headerlink" title="（1）安全保证"></a>（1）安全保证</h5><p>强制使用TLS&#x2F;SSL加密传输（TLS证书验证：设备级身份，防御中间人攻击）：8883端口，建立TLS握手，加密所有MQTT报文</p><p>客户端证书认证（设备合法性）</p><p>对用户使用用户名&#x2F;密码认证（业务级权限，防止凭证泄露）</p><p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20250423115650378.png" alt="image-20250423115650378" style="zoom: 50%;" /><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20250423120115661.png" alt="image-20250423120115661" style="zoom:50%;" /></p><h5 id="（2）与HTTP对比"><a href="#（2）与HTTP对比" class="headerlink" title="（2）与HTTP对比"></a>（2）与HTTP对比</h5><h6 id="①核心职能对比"><a href="#①核心职能对比" class="headerlink" title="①核心职能对比"></a>①核心职能对比</h6><p>MQTT：设备间消息路由；低消耗通信；实时数据分发；离线消息处理</p><p>HTTP：资源传输；状态操作；超媒体交互；缓存控制</p><h6 id="②技术特性对比"><a href="#②技术特性对比" class="headerlink" title="②技术特性对比"></a>②技术特性对比</h6><p>报文：二进制，纯文本</p><p>连接管理：长连接，短连接；有心跳机制，无心跳机制；无状态，但是访问点维护状态&#x2F;无状态（需要Cookie）</p><h6 id="③性能对比"><a href="#③性能对比" class="headerlink" title="③性能对比"></a>③性能对比</h6><p>延迟：实时，轮训</p><p>吞吐量：大（二进制、长连接、服务器可主动推送），小</p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20250423114850486.png" alt="image-20250423114850486" style="zoom:67%;" /><h5 id="（3）应用"><a href="#（3）应用" class="headerlink" title="（3）应用"></a>（3）应用</h5><p>物联网设备通信</p><p>移动推送通知</p><p>车联网系统</p><p>工业4.0（设备监控）</p><h3 id="（二）扩展协议"><a href="#（二）扩展协议" class="headerlink" title="（二）扩展协议"></a>（二）扩展协议</h3><p>扩展协议：WebSocket(全双工通信)、gRPC(基于HTTP&#x2F;2的RPC)</p><h4 id="1、WebSocket"><a href="#1、WebSocket" class="headerlink" title="1、WebSocket"></a>1、WebSocket</h4><p>全双工，基于TCP，帧</p><p>数据头（防止纯裸TCP粘包）+data</p><p>opcode字段：什么类型的数据帧</p><p>payload（是否大于125，继续读payload）：数据长度</p><p>payload data：数据</p><h5 id="（1）和HTTP区别"><a href="#（1）和HTTP区别" class="headerlink" title="（1）和HTTP区别"></a>（1）和HTTP区别</h5><p>HTTP半双工，WebSocket全双工</p><p>HTTP用于图文网页，WebSocket用于网页游戏（经历了TCP三次握手后，利用HTTP协议升级为WebSocket协议，HTTP请求会带上特殊header头：升级协议、想升级为的协议、随机生成的base64码（经过公开算法转换为字符串），频繁交互）</p><h5 id="（2）用户不操作，HTTP网页如何收到服务端消息"><a href="#（2）用户不操作，HTTP网页如何收到服务端消息" class="headerlink" title="（2）用户不操作，HTTP网页如何收到服务端消息"></a>（2）用户不操作，HTTP网页如何收到服务端消息</h5><p>HTTP不断轮训（伪服务器推）</p><p>长轮训：延迟超时时间（服务器推送）</p><h4 id="2、RPC技术"><a href="#2、RPC技术" class="headerlink" title="2、RPC技术"></a>2、RPC技术</h4><p>远程过程调用，允许调用另一地址空间（通常是远程机器）的过程或函数，想调用本地方法一样。</p><p>本身不是一种具体的协议，而是一种调用方式（它的具体实现方式才是协议：gRPC、Thrift），大部分RPC协议底层是TCP，但是也可以改为UDP、HTTP</p><h5 id="（1）用途"><a href="#（1）用途" class="headerlink" title="（1）用途"></a>（1）用途</h5><p>分布式系统通信；微服务架构中服务调用；跨语言、跨平台的服务集成</p><h5 id="（2）与HTTP区别"><a href="#（2）与HTTP区别" class="headerlink" title="（2）与HTTP区别"></a>（2）与HTTP区别</h5><p>协议层级：HTTP是应用层，RPC是协议（定义了远程调用的标准交互模式）与框架（提供实现该协议的具体工具库）的双重身份（协议是框架的基础规范，框架扩展协议能力）</p><p>服务发现（找到对应服务器的IP端口）：HTTP使用DNS七解析IP地址，默认80端口；RPC一般有专门的中间件（也可以使用DNS）</p><p>底层连接形式：TCP长连接，但是还会建立连接池，多条连接可以复用，可以提升网络请求性能，许多变成语言的网络库会给HTTP加连接池（如Go）</p><p>性能：RPC通常性能更高（与HTTP1.1比较），（二进制协议），HTTP传输内容以文本为主（头和体：Json序列化），PRC使用Protobuf</p><p>目的：跨网络调用本地方法；资源传输与操作</p><p>使用场景：HTTP适合对外API，RPC适合内部服务调用</p><p>服务治理：RPC框架通常内置服务发现、负载均衡等</p><p>先有的RPC，再有的HTTP，RPC可以支持C&#x2F;S架构，但是Browser不仅需要和自家公司服务器访问，也要访问别的公司家的服务器，为了适应browser&#x2F;S，出现HTTP</p><h5 id="（3）gRPC"><a href="#（3）gRPC" class="headerlink" title="（3）gRPC"></a>（3）gRPC</h5><p>全双工，基于HTTP&#x2F;2</p><h2 id="二、传输层——第四层"><a href="#二、传输层——第四层" class="headerlink" title="二、传输层——第四层"></a>二、传输层——第四层</h2><p>为应用层提供网络服务，简单、高效、专注</p><p>TCP、UDP；段</p><p>传输时数据包分块：当传输层数据包大小超过MSS（TCP最大报文段长度），在TCP协议中，将分块称为TCP报文段</p><p>接收时：负责把数据包传给应用，使用端口区分应用</p><h3 id="（一）UDP（用户数据报协议）"><a href="#（一）UDP（用户数据报协议）" class="headerlink" title="（一）UDP（用户数据报协议）"></a>（一）UDP（用户数据报协议）</h3><p>无连接，尽最大努力的数据传输服务（不保证数据传输的可靠性），面向报文（每个UDP报文就是一个用户消息的边界）</p><h4 id="1、和TCP的区别"><a href="#1、和TCP的区别" class="headerlink" title="1、和TCP的区别"></a>1、和TCP的区别</h4><p>UDP：面向报文的（TCP面向字节流），不合并、拆分，只加入首部，需要应用层控制报文大小；UDP首部只有8个字节（源端口+目的端口+包长度+校验和；TCP20）；没有拥塞控制；没有流量控制；不可靠信道；支持一和多对（TCP只能点到点）</p><p>连接</p><p>服务对象</p><p>可靠性</p><p>拥塞控制、流量控制</p><p>首部开销</p><p>传输方式</p><p>分片</p><h4 id="2、UDP对应的应用层协议"><a href="#2、UDP对应的应用层协议" class="headerlink" title="2、UDP对应的应用层协议"></a>2、UDP对应的应用层协议</h4><p>DNS、SNMP（简单网络管理协议161）、TFTP</p><h4 id="3、在进行UDP编程，一次发送多少字节好"><a href="#3、在进行UDP编程，一次发送多少字节好" class="headerlink" title="3、在进行UDP编程，一次发送多少字节好"></a>3、在进行UDP编程，一次发送多少字节好</h4><p>MTU（最大传输单元，网络层IP数据报长度，不包括链路层首尾18个字节）-8（UDP头部）-20（IP首部）</p><p>网络上标准MTU&#x3D;576，所以控制在548以内比较好</p><h4 id="4、如何优化UDP可靠性"><a href="#4、如何优化UDP可靠性" class="headerlink" title="4、如何优化UDP可靠性"></a>4、如何优化UDP可靠性</h4><p>序列号+确认应答（ACK）</p><p>超时重传+滑动窗口</p><p>校验</p><p>现成方案：QUIC协议（Quick UDP Internet Connections&#x2F;kwɪk&#x2F; 快速UDP网络连接）</p><h2 id="三、网络层——第三层"><a href="#三、网络层——第三层" class="headerlink" title="三、网络层——第三层"></a>三、网络层——第三层</h2><p>实际传输功能，将数据从一个设备传输到另一个设备，需要有区分设备的编号。将传输层的报文作为数据部分，再加上IP包头组成IP报文，如果IP包围大小超过MTU（最大传输单元，以太网中一般为1500），就会再次进行分片，得到IP报文</p><p>NAT、ICMP、IGMP、IP协议：寻址、路由；路由器；包</p><h3 id="（一）功能"><a href="#（一）功能" class="headerlink" title="（一）功能"></a>（一）功能</h3><h4 id="1、寻址"><a href="#1、寻址" class="headerlink" title="1、寻址"></a>1、寻址</h4><p>去往下一个目的地该朝哪个方向走，寻址先匹配到相同的网络号，才会去找对应的主机</p><p>IP区分了设备，并将IP地址分成了两种意义：根据子网掩码（IP&#x2F;24，其中24就是简化的子网掩码，24个1：111111111111111111000000（255.255.255.0））计算出网络号（属于哪个子网）+主机号（标识同一子网的不同设备）</p><p>网络号&#x3D;IP与子网掩码进行按位与</p><p>主机号&#x3D;子网掩码取反后与IP进行按位与操作</p><p>子网中最后一个是广播地址225</p><h4 id="2、路由"><a href="#2、路由" class="headerlink" title="2、路由"></a>2、路由</h4><p>当到达一个网络节点，需要路由算法决定下一步走哪条路径</p><h3 id="（二）协议"><a href="#（二）协议" class="headerlink" title="（二）协议"></a>（二）协议</h3><h4 id="1、NAT网络地址转换"><a href="#1、NAT网络地址转换" class="headerlink" title="1、NAT网络地址转换"></a>1、NAT网络地址转换</h4><p>将私有IP地址转换为公有IP地址，解决IPv4地址不足的问题</p><p>NAPT（网络地址端口转换，通过IP+端口的唯一组合，实现多个内网设备共享一个公共IP）路由转换表在NAT路由器上生成</p><h4 id="2、ICMP互联网控制报文协议"><a href="#2、ICMP互联网控制报文协议" class="headerlink" title="2、ICMP互联网控制报文协议"></a>2、ICMP互联网控制报文协议</h4><p>网络层协议，网络控制报文协议；传递网络信息，诊断网络故障</p><h5 id="（1）报文分类"><a href="#（1）报文分类" class="headerlink" title="（1）报文分类"></a>（1）报文分类</h5><p>ICMP差错报告报文：终点不可达；参数问题；改变路由；时间超过</p><p>ICMP询问报文：回送请求和回答；时间戳请求和回答：询问当前时间，返回一个32位时间戳</p><h5 id="（2）Ping原理"><a href="#（2）Ping原理" class="headerlink" title="（2）Ping原理"></a>（2）Ping原理</h5><p>向对方发送一个ICMP回送请求报文，如果可以到达，对方返回一个回送回答报文</p><h4 id="3、IGMP互联网组管理协议"><a href="#3、IGMP互联网组管理协议" class="headerlink" title="3、IGMP互联网组管理协议"></a>3、IGMP互联网组管理协议</h4><p>管理IP组播组成员，工作在主机（组播成员）和最后一跳路由之间</p><h2 id="四、数据链路层（网络接口层）——第二层"><a href="#四、数据链路层（网络接口层）——第二层" class="headerlink" title="四、数据链路层（网络接口层）——第二层"></a>四、数据链路层（网络接口层）——第二层</h2><p>为网络层提供链路级别传输的服务，负责在以太网、WiFi这样的底层网络上发送原始数据包，工作在网卡这个层次，使用MAC地址来标识网络上的设备。生成了IP头部后，接下来交给网络接口层，在IP头部前加上MAC头部，并封装成数据帧发送到网络上</p><p>APR协议、RARP、PPP；交换机；帧</p><h6 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h6><p>在一种局域网内，将附近的设备连接起来，使它们之间可以通讯的技术。通讯需要MAC地址。</p><h3 id="（一）协议"><a href="#（一）协议" class="headerlink" title="（一）协议"></a>（一）协议</h3><h4 id="1、RARP"><a href="#1、RARP" class="headerlink" title="1、RARP"></a>1、RARP</h4><p>数据链路层协议</p><p>反向地址转换协议，与ARP工作方式相反；发出要解释的物理地址并返回七IP地址</p><h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><p>网络上每台设备都有自己的硬件地址，是由设备厂商分配的MAC地址，主机从网卡上读取MAC地址，然后在网络上发送一个RARP请求的数据包，请求RARP服务器返回IP地址</p><p>RARP服务器接收到RARP请求后，分配IP地址并返回应答</p><p>客户端收到IP地址，利用IP地址进行通信</p><h2 id="五、物理层——第一层"><a href="#五、物理层——第一层" class="headerlink" title="五、物理层——第一层"></a>五、物理层——第一层</h2><h2 id="六、为什么要把TCP-IP协议栈分成5层（或7层）"><a href="#六、为什么要把TCP-IP协议栈分成5层（或7层）" class="headerlink" title="六、为什么要把TCP&#x2F;IP协议栈分成5层（或7层）"></a>六、为什么要把TCP&#x2F;IP协议栈分成5层（或7层）</h2><p>根据阿帕网的设计经验，复杂的网络结构应该是分层的</p><p>层之间是独立的</p><p>灵活性好</p><p>结构上可以分隔开</p><p>便于实现和维护</p><p>能促进标准化工作</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络协议 </tag>
            
            <tag> 网络体系结构 </tag>
            
            <tag> TCP/IP模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络（一）：OSI七层模型</title>
      <link href="/my_tech_blog.github.io/2025/11/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_1/"/>
      <url>/my_tech_blog.github.io/2025/11/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_1/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网络（一）：OSI七层模型"><a href="#计算机网络（一）：OSI七层模型" class="headerlink" title="计算机网络（一）：OSI七层模型"></a>计算机网络（一）：OSI七层模型</h1><h2 id="一、OSI七层网络参考模型"><a href="#一、OSI七层网络参考模型" class="headerlink" title="一、OSI七层网络参考模型"></a>一、OSI七层网络参考模型</h2><p>OSI（Open Systems Interconnection）参考模型是国际标准化组织提出的网络通信概念模型，将网络通信的工作分为7个层次。</p><p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\1762997940492.png" alt="1762997940492"></p><h3 id="（1）应用层（Application-Layer）-第7层"><a href="#（1）应用层（Application-Layer）-第7层" class="headerlink" title="（1）应用层（Application Layer） - 第7层"></a>（1）应用层（Application Layer） - 第7层</h3><p><strong>作用</strong>：为应用程序提供网络服务接口，直接面向用户。（各种应用软件）</p><p><strong>主要功能</strong>：</p><ul><li>提供用户接口，支持各种网络服务</li><li>识别通信伙伴的身份和可用性</li><li>同步通信过程</li><li>错误恢复的约定</li></ul><p><strong>典型协议和服务</strong>：</p><ul><li>HTTP&#x2F;HTTPS：网页浏览</li><li>FTP：文件传输</li><li>SMTP&#x2F;POP3&#x2F;IMAP：电子邮件</li><li>DNS：域名解析</li><li>SSH：安全远程登录</li></ul><p><strong>数据单位</strong>：报文（Message）</p><h3 id="（2）表示层（Presentation-Layer）-第6层"><a href="#（2）表示层（Presentation-Layer）-第6层" class="headerlink" title="（2）表示层（Presentation Layer） - 第6层"></a>（2）表示层（Presentation Layer） - 第6层</h3><p><strong>作用</strong>：处理两个通信系统中交换信息的表示方式，确保不同系统能够理解彼此的数据。（用户信息的表示问题，数据格式标识；图像视频编解码，数据加密）</p><p><strong>主要功能</strong>：</p><ul><li>数据格式转换（编码、解码）</li><li>数据加密和解密</li><li>数据压缩和解压缩</li><li>字符集转换</li></ul><p><strong>实际应用</strong>：</p><ul><li>JPEG、MPEG等多媒体格式处理</li><li>SSL&#x2F;TLS加密</li><li>ASCII与Unicode转换</li></ul><p><strong>数据单位</strong>：报文（Message）</p><h3 id="（3）会话层（Session-Layer）-第5层"><a href="#（3）会话层（Session-Layer）-第5层" class="headerlink" title="（3）会话层（Session Layer） - 第5层"></a>（3）会话层（Session Layer） - 第5层</h3><p><strong>作用</strong>：建立、管理和终止应用程序之间的会话连接。（应用程序之间会话能力，建立会话（如session认证，断点续传））</p><p><strong>主要功能</strong>：</p><ul><li>建立、维护和终止会话</li><li>会话同步控制</li><li>对话控制（全双工、半双工）</li><li>故障恢复点设置</li></ul><p><strong>实际应用</strong>：</p><ul><li>RPC（远程过程调用）</li><li>NetBIOS会话管理</li><li>断点续传的会话管理</li></ul><p><strong>数据单位</strong>：报文（Message）</p><h3 id="（4）传输层（Transport-Layer）-第4层"><a href="#（4）传输层（Transport-Layer）-第4层" class="headerlink" title="（4）传输层（Transport Layer） - 第4层"></a>（4）传输层（Transport Layer） - 第4层</h3><p><strong>作用</strong>：为端到端通信提供可靠或不可靠的数据传输服务。（端到端传输数据的基本功能）</p><p><strong>主要功能</strong>：</p><ul><li>端到端的连接管理</li><li>流量控制</li><li>差错控制</li><li>数据分段和重组</li><li>多路复用和解复用</li></ul><p><strong>核心协议</strong>：</p><ul><li><strong>TCP</strong>控制传输协议：面向连接、可靠传输</li><li><strong>UDP</strong>用户数据报协议：无连接、高效传输</li></ul><p><strong>数据单位</strong>：段（Segment）（tcp报文段&#x2F;udp用户数据报）</p><h3 id="（5）网络层（Network-Layer）-第3层"><a href="#（5）网络层（Network-Layer）-第3层" class="headerlink" title="（5）网络层（Network Layer） - 第3层"></a>（5）网络层（Network Layer） - 第3层</h3><p><strong>作用</strong>：实现不同网络之间的数据包路由和转发。（不同设备的数据转发）</p><p><strong>主要功能</strong>：</p><ul><li>逻辑寻址（IP地址）</li><li>路由选择</li><li>拥塞控制</li><li>分组转发</li></ul><p><strong>核心协议</strong>：</p><ul><li>IP（IPv4&#x2F;IPv6）：：数据传输时的基本单元和格式，数据报交递方式和路由选择</li><li>ICMP（网络控制消息）：“错误侦测与回报机制”，检测网络的连线情况，ping</li><li>OSPF、BGP（路由协议）</li><li>RIP路由信息协议：根据跳数得到距离目标地址的路由距离</li><li>IGMP网络组管理协议：组播、广播</li></ul><p><strong>网络设备</strong>：路由器（Router）</p><p><strong>数据单位</strong>：包（Packet）</p><h3 id="（6）数据链路层（Data-Link-Layer）-第2层"><a href="#（6）数据链路层（Data-Link-Layer）-第2层" class="headerlink" title="（6）数据链路层（Data Link Layer） - 第2层"></a>（6）数据链路层（Data Link Layer） - 第2层</h3><p><strong>作用</strong>：在相邻节点之间提供可靠的数据帧传输。（定义数据的基本格式，如何传输，如何标识）</p><p><strong>主要功能</strong>：</p><ul><li>物理寻址（MAC地址）</li><li>帧的封装和拆装</li><li>差错检测（CRC校验）</li><li>流量控制</li><li>介质访问控制</li></ul><p><strong>协议</strong>：</p><p>ARP地址解析协议：根据IP地址得到物理地址</p><p>RARP反向地址解析协议：根据物理地址得到IP地址</p><p>PPP点对点协议：拨号或专线点对点传输数据</p><p><strong>子层划分</strong>：</p><ul><li><strong>LLC</strong>：逻辑链路控制</li><li><strong>MAC</strong>：介质访问控制</li></ul><p><strong>网络设备</strong>：交换机（Switch）、网桥（Bridge）</p><p><strong>数据单位</strong>：帧（Frame）</p><h3 id="（7）物理层（Physical-Layer）-第1层"><a href="#（7）物理层（Physical-Layer）-第1层" class="headerlink" title="（7）物理层（Physical Layer） - 第1层"></a>（7）物理层（Physical Layer） - 第1层</h3><p><strong>作用</strong>：在物理介质上传输原始比特流。（利用传输介质为数据链路层提供物理连接，底层数据传输，如网线）</p><p><strong>主要功能</strong>：</p><ul><li>定义机械、电气特性</li><li>比特同步</li><li>线路配置</li><li>数据传输模式</li></ul><p><strong>涉及内容</strong>：</p><ul><li>网线、光纤、无线信号</li><li>接口类型（RJ45、USB）</li><li>信号编码（曼彻斯特编码）</li><li>传输速率</li></ul><p><strong>数据单位</strong>：比特（Bit）（网卡标准-&gt;比特流）</p><h2 id="二、数据封装过程"><a href="#二、数据封装过程" class="headerlink" title="二、数据封装过程"></a>二、数据封装过程</h2><p>数据在网络中传输时的封装过程：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">应用层数据 → 表示层加密/压缩 → 会话层建立会话</span><br><span class="line">    ↓</span><br><span class="line">传输层添加TCP/UDP头部 → 网络层添加IP头部</span><br><span class="line">    ↓</span><br><span class="line">数据链路层添加帧头帧尾 → 物理层转换为比特流</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OSI模型 </tag>
            
            <tag> 网络协议 </tag>
            
            <tag> 网络体系结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++数据结构(九)：其他问题</title>
      <link href="/my_tech_blog.github.io/2025/11/09/C++%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_9/"/>
      <url>/my_tech_blog.github.io/2025/11/09/C++%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_9/</url>
      
        <content type="html"><![CDATA[<h1 id="C-数据结构（九）：其他问题"><a href="#C-数据结构（九）：其他问题" class="headerlink" title="C++数据结构（九）：其他问题"></a>C++数据结构（九）：其他问题</h1><h4 id="1、debug和release"><a href="#1、debug和release" class="headerlink" title="1、debug和release"></a>1、debug和release</h4><p>调试版本，包含调试信息，不进行优化，优化会使调试很复杂，除了.exe或.dll文件外，还会生成.pdb文件记录中断点等调试信息</p><p>发布版本，不对源代码进行调试，编译时对应用程序的速度进行优化，使得程序在代码大小和运行速度上是最优的，生成一个.exe文件或.dll文件</p><h4 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h4><h5 id="（1）定义"><a href="#（1）定义" class="headerlink" title="（1）定义"></a>（1）定义</h5><p>当达成某个条件时，系统或者函数会自动调用一段自定义的函数；通过函数指针调用的函数，当将函数的指针（地址）作为参数传递给其它函数，该指针被用来调用函数则该函数为回调函数。</p><p>相当于中断处理函数，在系统符号你设定的条件时自动调用</p><p>需要：声明、定义、设置触发条件</p><h5 id="（2）作用"><a href="#（2）作用" class="headerlink" title="（2）作用"></a>（2）作用</h5><p>逻辑的动态注入、代码的解耦（可以把调用者和被调用者分开）、异步支持</p><h3 id="（）C"><a href="#（）C" class="headerlink" title="（）C++"></a>（）C++</h3><h4 id="1、重构函数"><a href="#1、重构函数" class="headerlink" title="1、重构函数"></a>1、重构函数</h4><p>不改变外部行为的前提下，对函数内部结构进行优化，提高代码可读性、可维护性或性能</p><p>不改变函数的功能和输入输出，可能重命名、拆分大数据、合并重复代码、简化逻辑条件，属于代码优化手段而非语言特性</p><h4 id="2、回调函数"><a href="#2、回调函数" class="headerlink" title="2、回调函数"></a>2、回调函数</h4><h5 id="（1）定义-1"><a href="#（1）定义-1" class="headerlink" title="（1）定义"></a>（1）定义</h5><p>当达成某个条件时，系统或者函数会自动调用一段自定义的函数；通过函数指针调用的函数，当将函数的指针（地址）作为参数传递给其它函数，该指针被用来调用函数则该函数为回调函数。</p><p>相当于中断处理函数，在系统符号你设定的条件时自动调用</p><p>需要：声明、定义、设置触发条件</p><h5 id="（2）作用-1"><a href="#（2）作用-1" class="headerlink" title="（2）作用"></a>（2）作用</h5><p>逻辑的动态注入、代码的解耦（可以把调用者和被调用者分开）、异步支持</p><h4 id="3、友元"><a href="#3、友元" class="headerlink" title="3、友元"></a>3、友元</h4><p>可以只用前向声明在类外声明，但是也必须要在类内声明；可以访问类中的私有、保护成员</p><h5 id="（1）友元函数"><a href="#（1）友元函数" class="headerlink" title="（1）友元函数"></a>（1）友元函数</h5><p>定义在类外的普通函数</p><h5 id="（2）友元类"><a href="#（2）友元类" class="headerlink" title="（2）友元类"></a>（2）友元类</h5><p>不能继承、单向、不具有传递性</p><h4 id="4、形参和实参的区别"><a href="#4、形参和实参的区别" class="headerlink" title="4、形参和实参的区别"></a>4、形参和实参的区别</h4><p>形参是只有在被调用时才分配内存单元，在调用结束立即释放内存单元，只在函数内部有效。</p><p>在函数进行调用时，实参必须有确定的值</p><p>单向传递</p><h4 id="5、零拷贝"><a href="#5、零拷贝" class="headerlink" title="5、零拷贝"></a>5、零拷贝</h4><p>避免CPU将数据从一块存储拷贝到另一块存储，减少数据拷贝和共享总线资源的次数</p><p>e.g.push_back()需要调用拷贝构造函数和转移构造函数，emplace_back()插入的元素原地构造，不触发拷贝构造和转移构造</p><h5 id="（1）文件系统实现零拷贝"><a href="#（1）文件系统实现零拷贝" class="headerlink" title="（1）文件系统实现零拷贝"></a>（1）文件系统实现零拷贝</h5><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20250502174741932.png" alt="image-20250502174741932" style="zoom:67%;" /><p>减少用户态与内核态的切换（系统调用）和内存拷贝</p><p>sendfile：文件直接发送到Socket（无需用户态参与）；</p><p>mmap+write：内存映射（内核空间映射到用户空间）减少拷贝次数</p><h4 id="1、微服务"><a href="#1、微服务" class="headerlink" title="1、微服务"></a>1、微服务</h4><h5 id="（1）微服务架构"><a href="#（1）微服务架构" class="headerlink" title="（1）微服务架构"></a>（1）微服务架构</h5><p>将单体应用拆分为多个小型服务，每个服务独立部署、运行、扩展</p><h5 id="（2）特点"><a href="#（2）特点" class="headerlink" title="（2）特点"></a>（2）特点</h5><p>松耦合</p><p>独立技术栈</p><p>独立扩缩容</p><h5 id="（3）操作"><a href="#（3）操作" class="headerlink" title="（3）操作"></a>（3）操作</h5><p>服务熔断、服务降级</p><h4 id="1、动态代理"><a href="#1、动态代理" class="headerlink" title="1、动态代理"></a>1、动态代理</h4><p>在运行时动态创建代理对象的技术，用于在不修改原始类代码的情况下，拦截并增强其方法调用</p><p>C++：虚函数+组合模式</p><h3 id="（）线程、协程"><a href="#（）线程、协程" class="headerlink" title="（）线程、协程"></a>（）线程、协程</h3><h4 id="1、Threadlocal"><a href="#1、Threadlocal" class="headerlink" title="1、Threadlocal"></a>1、Threadlocal</h4><h5 id="（1）概念"><a href="#（1）概念" class="headerlink" title="（1）概念"></a>（1）概念</h5><p>线程局部存储（TLS），每个线程拥有变量的独立副本，避免多线程共享数据时的竞争条件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="keyword">thread_local</span> <span class="type">int</span> counter = <span class="number">0</span>;  <span class="comment">// 每个线程独立的counter</span></span><br></pre></td></tr></table></figure><h4 id="2、C-如何实现协程"><a href="#2、C-如何实现协程" class="headerlink" title="2、C++如何实现协程"></a>2、C++如何实现协程</h4><p>coroutine提供了原生的协程支持，可以方便实现异步操作</p><h3 id="（）序列化"><a href="#（）序列化" class="headerlink" title="（）序列化"></a>（）序列化</h3><h4 id="1、序列化和反序列化"><a href="#1、序列化和反序列化" class="headerlink" title="1、序列化和反序列化"></a>1、序列化和反序列化</h4><p>序列化：将对象转化为可存储&#x2F;传输的格式</p><p>反序列化：将序列化后的数据恢复为内存中的对象</p><p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20250421154641595.png" alt="image-20250421154641595"></p><h4 id="2、Protobuf-ˈproʊ-tə-bvf"><a href="#2、Protobuf-ˈproʊ-tə-bvf" class="headerlink" title="2、Protobuf &#x2F;ˈproʊ.tə.bʌf&#x2F;"></a>2、Protobuf &#x2F;ˈproʊ.tə.bʌf&#x2F;</h4><p>跨语言的数据序列化格式，高效二进制数据交换格式，用于高性能、跨语言的序列化和反序列化（提供多语言代码生成器，通过 <code>protoc</code> 编译器生成跨语言的序列化代码），自动生成序列化、反序列化代码，确保各语言数据兼容性</p><h5 id="（1）-proto文件"><a href="#（1）-proto文件" class="headerlink" title="（1）.proto文件"></a>（1）.proto文件</h5><p>定义数据模型</p><h5 id="（2）为什么protobuf比Json-ˈdʒeɪ-sən-xml-ˌeks-emˈel-Trift-θrɪft-Avro-ˈaev-roʊ-快"><a href="#（2）为什么protobuf比Json-ˈdʒeɪ-sən-xml-ˌeks-emˈel-Trift-θrɪft-Avro-ˈaev-roʊ-快" class="headerlink" title="（2）为什么protobuf比Json&#x2F;ˈdʒeɪ.sən&#x2F;&#x2F;xml&#x2F;ˌeks.emˈel&#x2F; &#x2F;Trift&#x2F;θrɪft&#x2F; &#x2F;Avro&#x2F;ˈæv.roʊ&#x2F; 快"></a>（2）为什么protobuf比Json&#x2F;ˈdʒeɪ.sən&#x2F;&#x2F;xml&#x2F;ˌeks.emˈel&#x2F; &#x2F;Trift&#x2F;θrɪft&#x2F; &#x2F;Avro&#x2F;ˈæv.roʊ&#x2F; 快</h5><p>二进制编码，体积更小；直接二进制解码，无需词法分析；紧凑存储，无额外格式字符；直接映射到结构体，CPU消耗低；占用宽带少</p><p>Json：纯文本，键值对，支持嵌套</p><p>XML：标签式结构，冗余度高</p><p>Thrift：需先定义.thrift文件；二进制+IDL（接口定义语言）</p><p>Avro：需先定义.avsc（JSON Schema）；Schema（JSON 格式的）+二进制</p><h5 id="（3）缺点"><a href="#（3）缺点" class="headerlink" title="（3）缺点"></a>（3）缺点</h5><p>二进制代码，可读性差（需反序列化）</p><p>需预编译：必须提前定义.proto文件并生成代码</p><p>动态性弱</p><h5 id="（4）支持数据加密吗"><a href="#（4）支持数据加密吗" class="headerlink" title="（4）支持数据加密吗"></a>（4）支持数据加密吗</h5><p>本身不提供数据加密功能</p><p>可以传输层加密：TLS&#x2F;SSL；应用层加密：序列化后手动加密二进制数据</p><h5 id="（5）schema-ˈskiː-mə"><a href="#（5）schema-ˈskiː-mə" class="headerlink" title="（5）schema&#x2F;ˈskiː.mə&#x2F;"></a>（5）schema&#x2F;ˈskiː.mə&#x2F;</h5><p>数据结构的蓝图</p><p>Schema（模式） 是用于定义数据结构的元数据（Metadata），它规定了数据的类型、字段、格式和约束条件。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 其他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++数据结构(八)：设计模式</title>
      <link href="/my_tech_blog.github.io/2025/11/09/C++%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_8/"/>
      <url>/my_tech_blog.github.io/2025/11/09/C++%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_8/</url>
      
        <content type="html"><![CDATA[<h1 id="C-数据结构（八）：设计模式"><a href="#C-数据结构（八）：设计模式" class="headerlink" title="C++数据结构（八）：设计模式"></a>C++数据结构（八）：设计模式</h1><p>设计模式是解决软件设计问题的经典解决方案。它们是在多年实践中总结出来的最佳实践，可以帮助开发者编写可维护、可扩展和可重用的代码。常见的设计模式分为三大类：</p><h2 id="一、创建型模式（CreatI-Onal-Patterns）"><a href="#一、创建型模式（CreatI-Onal-Patterns）" class="headerlink" title="一、创建型模式（CreatI&#x2F;Onal Patterns）"></a>一、创建型模式（CreatI&#x2F;Onal Patterns）</h2><h3 id="（一）单例模式（Singleton）"><a href="#（一）单例模式（Singleton）" class="headerlink" title="（一）单例模式（Singleton）"></a>（一）<strong>单例模式（Singleton）</strong></h3><p>确保一个类只有一个实例，并提供全局访问点。</p><p>将构造函数私有，删除拷贝构造和赋值，静态成员函数创建对象（静态实例指针&#x2F;对象（全局唯一实例存储）+静态获取方法（提供全局访问点）），确保线程安全（懒汉式或者饿汉式）</p><h4 id="1、懒汉式"><a href="#1、懒汉式" class="headerlink" title="1、懒汉式"></a>1、懒汉式</h4><p>是指在第一次调用时才创建实例。使用双重检查锁定（互斥锁：竞态条件（多线程同时调用可能重复创建实例，确保原子操作））</p><p>C++11 保证了局部静态变量的初始化是线程安全的（明确规定局部静态变量的初始化在多线程环境下只会执行一次，由编译器插入底层同步机制（类似隐式锁）），因此可以利用这一特性实现简单的线程安全单例模式。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span> </span>&#123;<span class="comment">//C++11之前</span></span><br><span class="line">    <span class="keyword">if</span> (!instance) &#123;  <span class="comment">// 第一次检查（避免每次加锁）</span></span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (!instance) &#123;  <span class="comment">// 第二次检查（确保唯一性）</span></span><br><span class="line">            instance = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2、饿汉式"><a href="#2、饿汉式" class="headerlink" title="2、饿汉式"></a>2、饿汉式</h4><p>是指在程序启动时就创建实例。由于实例在程序启动时就已经创建，因此不存在多线程竞争问题。</p><p><code>std::call_once</code>，可以确保某个函数只被调用一次，适合用于实现线程安全的单例模式。</p><h4 id="3、应用"><a href="#3、应用" class="headerlink" title="3、应用"></a>3、应用</h4><h5 id="（1）数据库连接池"><a href="#（1）数据库连接池" class="headerlink" title="（1）数据库连接池"></a>（1）数据库连接池</h5><p>管理和复用数据库连接（Web应用，微服务框架，高并发系统，云数据库访问）</p><p>单例模式确保全局唯一连接池实例（双重检查锁定）+对象池模式（类似享元模式，但复用昂贵对象，主动回收、分配）管理数据库连接的创建获取与回收+代理模式（可选）</p><p>类似线程池</p><h3 id="（二）工厂方法模式（Factory-Method）"><a href="#（二）工厂方法模式（Factory-Method）" class="headerlink" title="（二）工厂方法模式（Factory Method）"></a>（二）<strong>工厂方法模式（Factory Method）</strong></h3><p>定义一个创建对象的接口，但由子类决定实例化哪个类。</p><h4 id="1、应用"><a href="#1、应用" class="headerlink" title="1、应用"></a>1、应用</h4><h5 id="（1）线程池"><a href="#（1）线程池" class="headerlink" title="（1）线程池"></a>（1）线程池</h5><p>线程池本质是对象池：线程池是对象池模式的具体应用，但因为其任务调度机制更复杂，通常用 生产者-消费者模式描述。</p><p>工厂模式统一创建线程+命令模式将任务封装为对象+生产者-消费者模式通过任务队列解耦任务提交和执行</p><h6 id="线程池的种类"><a href="#线程池的种类" class="headerlink" title="线程池的种类"></a>线程池的种类</h6><p>固定大小线程池：线程数量确定，适合稳定负载</p><p>动态扩容线程池：根据任务需求动态调整线程数</p><h6 id="关键参数"><a href="#关键参数" class="headerlink" title="关键参数"></a>关键参数</h6><p>线程数量：默认CPU核心数量</p><p>队列任务容量</p><p>线程空闲超时</p><h3 id="（三）抽象工厂模式（Abstract-Factory）"><a href="#（三）抽象工厂模式（Abstract-Factory）" class="headerlink" title="（三）抽象工厂模式（Abstract Factory）"></a>（三）<strong>抽象工厂模式（Abstract Factory）</strong></h3><p>提供一个接口，用于创建相关或依赖对象的家族，而不需要指定具体类。</p><h4 id="1、如何阻止一个类被实例化"><a href="#1、如何阻止一个类被实例化" class="headerlink" title="1、如何阻止一个类被实例化"></a>1、如何阻止一个类被实例化</h4><p>工具类、接口类、单例模式</p><p>抽象基类；构造函数private（静态成员函数创建对象：单例模式）；不允许在类外部创建类对象，只能在类内部创建对象；删除构造函数（&#x3D;delete）</p><h3 id="（四）建造者模式（Builder）"><a href="#（四）建造者模式（Builder）" class="headerlink" title="（四）建造者模式（Builder）"></a>（四）<strong>建造者模式（Builder）</strong></h3><p>将一个复杂对象的构建与其表示分离，使得同样的构建过程可以创建不同的表示。</p><h3 id="（五）原型模式（Prototype）"><a href="#（五）原型模式（Prototype）" class="headerlink" title="（五）原型模式（Prototype）"></a>（五）<strong>原型模式（Prototype）</strong></h3><p>通过复制现有对象来创建新对象。</p><h2 id="二、结构型模式（Structural-Patterns）"><a href="#二、结构型模式（Structural-Patterns）" class="headerlink" title="二、结构型模式（Structural Patterns）"></a>二、结构型模式（Structural Patterns）</h2><h3 id="（一）适配器模式（Adapter）"><a href="#（一）适配器模式（Adapter）" class="headerlink" title="（一）适配器模式（Adapter）"></a>（一）<strong>适配器模式（Adapter）</strong></h3><p>将一个类的接口转换成客户端期望的另一个接口。</p><h3 id="（二）装饰器模式（Decorator）"><a href="#（二）装饰器模式（Decorator）" class="headerlink" title="（二）装饰器模式（Decorator）"></a>（二）<strong>装饰器模式（Decorator）</strong></h3><p>动态地给对象添加额外的职责。</p><h3 id="（三）代理模式（Proxy）"><a href="#（三）代理模式（Proxy）" class="headerlink" title="（三）代理模式（Proxy）"></a>（三）<strong>代理模式（Proxy）</strong></h3><p>为其他对象提供一个代理以控制对这个对象的访问。</p><h4 id="1、代理模式类关系图"><a href="#1、代理模式类关系图" class="headerlink" title="1、代理模式类关系图"></a>1、代理模式类关系图</h4><p>Subject：抽象接口，定义request方法</p><p>RealSubject：真实对象，执行实际逻辑</p><p>Proxy：代理类，控制对真实对象的访问</p><h4 id="2、私有方法能代理吗"><a href="#2、私有方法能代理吗" class="headerlink" title="2、私有方法能代理吗"></a>2、私有方法能代理吗</h4><p>静态语言：代理类不可以访问私有方法（C++使用友元，Java使用反射）</p><p>动态语言可以直接访问</p><h3 id="（四）外观模式（Facade）"><a href="#（四）外观模式（Facade）" class="headerlink" title="（四）外观模式（Facade）"></a>（四）<strong>外观模式（Facade）</strong></h3><p>提供一个统一的接口，用来访问子系统中的一群接口。</p><h3 id="（五）桥接模式（Bridge）"><a href="#（五）桥接模式（Bridge）" class="headerlink" title="（五）桥接模式（Bridge）"></a>（五）<strong>桥接模式（Bridge）</strong></h3><p>将抽象部分与实现部分分离，使它们可以独立变化。</p><h3 id="（六）组合模式（Composite）"><a href="#（六）组合模式（Composite）" class="headerlink" title="（六）组合模式（Composite）"></a>（六）<strong>组合模式（Composite）</strong></h3><p>将对象组合成树形结构以表示“部分-整体”的层次结构。</p><h3 id="（七）享元模式（Flyweight）"><a href="#（七）享元模式（Flyweight）" class="headerlink" title="（七）享元模式（Flyweight）"></a>（七）<strong>享元模式（Flyweight）</strong></h3><p>通过共享技术有效地支持大量细粒度的对象。</p><h4 id="1、对象复用"><a href="#1、对象复用" class="headerlink" title="1、对象复用"></a>1、对象复用</h4><p>将对象存储到“对象池”中实现对象的重复利用，可以避免多次创建重复对象的开销，节约系统资源（缓存、单例模式）</p><h2 id="三、行为型模式（BehavI-Oral-Patterns）"><a href="#三、行为型模式（BehavI-Oral-Patterns）" class="headerlink" title="三、行为型模式（BehavI&#x2F;Oral Patterns）"></a>三、行为型模式（BehavI&#x2F;Oral Patterns）</h2><h3 id="（一）策略模式（Strategy）"><a href="#（一）策略模式（Strategy）" class="headerlink" title="（一）策略模式（Strategy）"></a>（一）<strong>策略模式（Strategy）</strong></h3><p>定义一系列算法，将它们封装起来，并使它们可以互相替换。</p><h3 id="（二）观察者模式（Observer）"><a href="#（二）观察者模式（Observer）" class="headerlink" title="（二）观察者模式（Observer）"></a>（二）<strong>观察者模式（Observer）</strong></h3><p>定义对象间的一对多依赖关系，当一个对象改变状态时，其所有依赖者都会收到通知并自动更新。e.g.<strong>事件驱动</strong></p><h4 id="1、特点"><a href="#1、特点" class="headerlink" title="1、特点"></a>1、特点</h4><p>松耦合：Subject和观察者之间没有直接依赖</p><p>动态订阅：观察者可以随时注册、注销</p><p>事件驱动：适用于异步通知</p><h4 id="2、解决问题"><a href="#2、解决问题" class="headerlink" title="2、解决问题"></a>2、解决问题</h4><p> 实时数据更新</p><p>事件监听</p><p>日志系统</p><h3 id="（三）命令模式（Command）"><a href="#（三）命令模式（Command）" class="headerlink" title="（三）命令模式（Command）"></a>（三）<strong>命令模式（Command）</strong></h3><p>将请求封装为对象，从而使你可以用不同的请求对客户进行参数化。</p><h3 id="（四）状态模式（State）"><a href="#（四）状态模式（State）" class="headerlink" title="（四）状态模式（State）"></a>（四）<strong>状态模式（State）</strong></h3><p>允许对象在其内部状态改变时改变其行为。</p><h3 id="（五）责任链模式（Chain-of-Responsibility）"><a href="#（五）责任链模式（Chain-of-Responsibility）" class="headerlink" title="（五）责任链模式（Chain of Responsibility）"></a>（五）<strong>责任链模式（Chain of Responsibility）</strong></h3><p>将请求的发送者和接收者解耦，使多个对象都有机会处理请求。</p><h3 id="（六）模板方法模式（Template-Method）"><a href="#（六）模板方法模式（Template-Method）" class="headerlink" title="（六）模板方法模式（Template Method）"></a>（六）<strong>模板方法模式（Template Method）</strong></h3><p>定义一个算法的骨架，而将一些步骤延迟到子类中。</p><h3 id="（七）迭代器模式（Iterator）"><a href="#（七）迭代器模式（Iterator）" class="headerlink" title="（七）迭代器模式（Iterator）"></a>（七）迭代器模式（Iterator）</h3><p>提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部表示。</p><h3 id="（八）中介者模式（Mediator）"><a href="#（八）中介者模式（Mediator）" class="headerlink" title="（八）中介者模式（Mediator）"></a>（八）中介者模式（Mediator）</h3><p>定义一个中介对象来封装一系列对象之间的交互。</p><h3 id="（九）备忘录模式（Memento）"><a href="#（九）备忘录模式（Memento）" class="headerlink" title="（九）备忘录模式（Memento）"></a>（九）备忘录模式（Memento）</h3><p>在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。</p><h3 id="（十）访问者模式（Visitor）"><a href="#（十）访问者模式（Visitor）" class="headerlink" title="（十）访问者模式（Visitor）"></a>（十）访问者模式（Visitor）</h3><p>表示一个作用于某对象结构中的各元素的操作。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++数据结构(七)：STL</title>
      <link href="/my_tech_blog.github.io/2025/11/09/C++%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_7/"/>
      <url>/my_tech_blog.github.io/2025/11/09/C++%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_7/</url>
      
        <content type="html"><![CDATA[<h1 id="C-数据结构（七）：STL"><a href="#C-数据结构（七）：STL" class="headerlink" title="C++数据结构（七）：STL"></a>C++数据结构（七）：STL</h1><h2 id="一、C-中标准库是什么"><a href="#一、C-中标准库是什么" class="headerlink" title="一、C++中标准库是什么"></a>一、C++中标准库是什么</h2><h3 id="（一）标准函数库"><a href="#（一）标准函数库" class="headerlink" title="（一）标准函数库"></a>（一）标准函数库</h3><p>独立的通用的，不属于任何类的函数，继承自C语言，过程式，不设计面向对象</p><p>如输入输出、数学函数、字符串处理、内存关联、时间和日期、随机数</p><h3 id="二）标准模板库STL"><a href="#二）标准模板库STL" class="headerlink" title="(二）标准模板库STL"></a>(二）标准模板库STL</h3><p>基于模板的，有高可用性和可扩展性</p><p>容器（序列、关联、无序关联、容器适配器）；迭代器；算法；函数对象（仿函数）；适配器（容器适配器、函数适配器）；采用面向对象；组件通过迭代器解耦，使得算法可以独立于容器使用</p><h2 id="二、STL"><a href="#二、STL" class="headerlink" title="二、STL"></a>二、STL</h2><h3 id="（一）什么是STL"><a href="#（一）什么是STL" class="headerlink" title="（一）什么是STL"></a>（一）什么是STL</h3><p>算法、容器（序列式容器、关联式容器、适配器）、迭代器</p><p>容器线程不安全，需要mutex（C++标准库提供的互斥锁，用于保护共享资源，防止多线程并发访问导致数据竞争）</p><h3 id="（二）迭代器"><a href="#（二）迭代器" class="headerlink" title="（二）迭代器"></a>（二）迭代器</h3><h4 id="1、迭代器如何实现"><a href="#1、迭代器如何实现" class="headerlink" title="1、迭代器如何实现"></a>1、迭代器如何实现</h4><p>与容器相关联的指针，提供遍历容器所有元素的借接口</p><h4 id="2、-it和it"><a href="#2、-it和it" class="headerlink" title="2、++it和it++"></a>2、++it和it++</h4><p>前者返回一个引用（没有临时对象），后者返回一个对象（会产生临时对象）</p><p>整数的后置++也需要临时对象存储，返回旧副本值</p><p>通常不是原子的，需多步骤完成</p><h3 id="（三）容器"><a href="#（三）容器" class="headerlink" title="（三）容器"></a>（三）容器</h3><h4 id="1、顺序容器"><a href="#1、顺序容器" class="headerlink" title="1、顺序容器"></a>1、顺序容器</h4><p>vector和deque和list和slist</p><h5 id="（1）vector"><a href="#（1）vector" class="headerlink" title="（1）vector"></a>（1）vector</h5><p>和数组类似，分配一块连续内存空间，当内存不够会重新分配一块内存并拷贝，支持高效率访问和在尾部插入、删除，不需要考虑容量问题；迭代器使用后失效，重新分配空间则所有迭代器失效（随机访问迭代器）</p><p>单向开口，在尾部进行操作</p><h6 id="①扩容"><a href="#①扩容" class="headerlink" title="①扩容"></a>①扩容</h6><p>2倍扩容（或1.5倍）：分配一块更大的内存，将原来的数据复制过来，将多次插入操作的扩容开销分摊（保证常数时间复杂度）</p><h6 id="②删除"><a href="#②删除" class="headerlink" title="②删除"></a>②删除</h6><p>除了list大部分顺序容器（vector、deque）删除元素使得所指向的迭代器和其之后的迭代器均失效（一旦空间重新配置，迭代器失效），但是返回下一个有效迭代器</p><p>remove&#x2F;pop_back&#x2F;erase都可以删除，但是remove不会改变size大小（都不会改变capacity）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="built_in">remove</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), <span class="number">2</span>); </span><br><span class="line"><span class="comment">// vec内容变为 &#123;1, 3, 4, 4&#125;，size仍为4！</span></span><br></pre></td></tr></table></figure><h6 id="③释放空间"><a href="#③释放空间" class="headerlink" title="③释放空间"></a>③释放空间</h6><p>只增不减，clear只清空元素，内存不回收，可以用swap释放多余内存或清空</p><h5 id="（2）deque"><a href="#（2）deque" class="headerlink" title="（2）deque"></a>（2）deque</h5><p>双端队列，随机访问迭代器（不是普通指针，复杂度比vector高，当前元素、缓冲区第一个元素、缓冲区最后一个元素、map的node（map是一小块连续空间，每个元素称为一个节点，每个node是一个指针，指向另一个比较大的连续空间，称为缓冲区，数据就存在缓冲区中））</p><p>删除同时释放内存使用deque，deque是双向开口（可以在常数时间内对头部进行操作）的连续线性空间，没有容量概念（动态分段连续空间）、空间保留功能</p><p>最大任务是维护整体的连续性</p><h5 id="（3）list"><a href="#（3）list" class="headerlink" title="（3）list"></a>（3）list</h5><p>环形（链表的头节点（哨兵节点）的 prev指向尾节点，尾节点的next指向头节点）双向链表，内存空间不连续，可以高效插入、删除，随机访问效率低；迭代器使用后还可以使用；可以使用反向迭代器</p><h6 id="①迭代器"><a href="#①迭代器" class="headerlink" title="①迭代器"></a>①迭代器</h6><p>插入操作：迭代器不会失效（新节点不影响现有节点指针）</p><p>删除操作：仅被删除元素的迭代器失效，其他迭代器仍有效。</p><h6 id="②使用场景"><a href="#②使用场景" class="headerlink" title="②使用场景"></a>②使用场景</h6><p>频繁插入删除，无需随机访问，如LRU缓存</p><h5 id="（4）slist"><a href="#（4）slist" class="headerlink" title="（4）slist"></a>（4）slist</h5><p>单向链表，操作可能不如list灵活，但是占用空间小、操作快</p><p>只能在链表头插入元素，其它位置插入只能插入到指定位置之前</p><p>不支持反向遍历、插入&#x2F;删除时间复杂度为O(n)-&gt;寻找前驱</p><h4 id="2、关联容器（无序）"><a href="#2、关联容器（无序）" class="headerlink" title="2、关联容器（无序）"></a>2、关联容器（无序）</h4><p>unordered_set和unordered_map的底层是哈希表</p><p>unoredered_set仅存储键值，unordered_map每一个元素是一个键值(key-value)对</p><h5 id="（1）哈希表（散列表）的基本原理"><a href="#（1）哈希表（散列表）的基本原理" class="headerlink" title="（1）哈希表（散列表）的基本原理"></a>（1）哈希表（散列表）的基本原理</h5><p>通过哈希函数将键映射到一个固定大小的数据（桶数组）中的某个位置</p><p>哈希函数：将键转换为一个整数，理想情况下应该均匀分布键，减少冲突（不同键映射到同一个桶）</p><p>桶数组：哈希表维护一个桶数组，每个桶可以</p><p>迭代器只提供前进操作，不提供后退操作</p><h6 id="①哈希冲突"><a href="#①哈希冲突" class="headerlink" title="①哈希冲突"></a>①哈希冲突</h6><p>链地址法&#x2F;开链法（hashmap&#x2F;unordered_map是这个，底层是哈希表，前向迭代器）</p><p>开放地址法（线性探测（依次向后）、二次探测（步长1^2,2^2,3^2）、伪随机探测（步长随机））</p><p>再散列（冲突时使用另一种哈希再计算，直到不冲突）</p><p>公共溢出区（计算结果相同就放入公共溢出区）</p><h6 id="②实现细节（组件：哈希函数、桶数组、冲突解决策略）"><a href="#②实现细节（组件：哈希函数、桶数组、冲突解决策略）" class="headerlink" title="②实现细节（组件：哈希函数、桶数组、冲突解决策略）"></a>②实现细节（组件：哈希函数、桶数组、冲突解决策略）</h6><p>A.数据结构</p><p>桶数组（vector<list>）</p><p>哈希函数</p><p>负载（装载）因子（元素&#x2F;桶，如果超过阈值要扩容）</p><p>B.主要操作</p><p>插入删除查找（更适合查询，因为插入可能会扩容，修改可能需要重新哈希，删除需要处理冲突）</p><p>扩容：更大的桶数组（O(n)）</p><h6 id="③哈希表遍历效率低"><a href="#③哈希表遍历效率低" class="headerlink" title="③哈希表遍历效率低"></a>③哈希表遍历效率低</h6><p>稀疏存储、内存不连续、冲突处理</p><p>维护所有元素双链表O(n)遍历但是额外内存</p><p>密集存储使用连续内存，删除时复杂</p><p>分块哈希，将哈希表分为多个块，位图操作快速跳过空块，实现复杂</p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20250414112908162.png" alt="image-20250414112908162" style="zoom:67%;" /><h4 id="3、关联容器（有序）"><a href="#3、关联容器（有序）" class="headerlink" title="3、关联容器（有序）"></a>3、关联容器（有序）</h4><h5 id="（1）组件"><a href="#（1）组件" class="headerlink" title="（1）组件"></a>（1）组件</h5><p>红黑树（有序）或哈希表（无序）</p><p>迭代器（双向迭代器：有序；前向迭代器：无序）</p><p>比较器（默认less）</p><h5 id="（2）set"><a href="#（2）set" class="headerlink" title="（2）set"></a>（2）set</h5><p>使用红黑树（根据元素值自动排序）实现，参数模板，set是value，双向迭代器（删除节点后不会影响其他节点迭代器）</p><h6 id="①红黑树特性"><a href="#①红黑树特性" class="headerlink" title="①红黑树特性"></a>①红黑树特性</h6><p>二叉排序树：左子树不空，则左子树上所有节点的值均小于或等于它根节点的值。右子树大于等于，查找时间O（logn）</p><p>每个节点不是黑色就是红色</p><p>根节点为黑色</p><p>如果节点为红色，子节点为黑色</p><p>任意节点到NULL的任何路径，黑色节点数相同</p><h6 id="②使用场景-1"><a href="#②使用场景-1" class="headerlink" title="②使用场景"></a>②使用场景</h6><p>去重+排序，如黑名单</p><h5 id="（2）map"><a href="#（2）map" class="headerlink" title="（2）map"></a>（2）map</h5><p>使用红黑树（根据键值自动排序）实现，参数模板，map是key+value，双向迭代器（删除节点后不会影响其他节点迭代器），迭代器不是constant也不是mutable（部分可变：key不能改，value可以改）</p><h6 id="①map插入"><a href="#①map插入" class="headerlink" title="①map插入"></a>①map插入</h6><p>[]&#x3D;；insert（pair&#x2F;value&#x2F;make_pair）</p><p>红黑树的独一无二插入（multimap和map只有插入时调用的函数不同“可重复插入”）</p><h6 id="②map查找"><a href="#②map查找" class="headerlink" title="②map查找"></a>②map查找</h6><p>[]将关键码作为下标查找，返回对应值，不存在则插入</p><p>find用关键码执行查找，返回迭代器，不存在则返回尾迭代器</p><h6 id="③使用场景"><a href="#③使用场景" class="headerlink" title="③使用场景"></a>③使用场景</h6><p>需要有序键值对，如字典</p><h5 id="（3）set和map区别"><a href="#（3）set和map区别" class="headerlink" title="（3）set和map区别"></a>（3）set和map区别</h5><h4 id="4、容器适配器"><a href="#4、容器适配器" class="headerlink" title="4、容器适配器"></a>4、容器适配器</h4><p>修改某种接口，形成另一种风貌</p><p>无迭代器</p><h5 id="（1）stack-queue"><a href="#（1）stack-queue" class="headerlink" title="（1）stack&#x2F;queue"></a>（1）stack&#x2F;queue</h5><p>stack&#x2F;queue底层一般用list或者deque实现，封闭一端</p><h5 id="（2）priority-queue"><a href="#（2）priority-queue" class="headerlink" title="（2）priority_queue"></a>（2）priority_queue</h5><p>priority_queue底层用heap（vector）</p><h5 id="（3）堆"><a href="#（3）堆" class="headerlink" title="（3）堆"></a>（3）堆</h5><p>不是容器，是priority_queue的底层实现机制，使用数组vector和一组heap算法实现堆（完全二叉树）</p><h6 id="①pop-heap"><a href="#①pop-heap" class="headerlink" title="①pop_heap"></a>①pop_heap</h6><p>将堆顶元素移动到序列末尾（下溯），不会删除，需要pop_back()</p><h6 id="②push-heap"><a href="#②push-heap" class="headerlink" title="②push_heap"></a>②push_heap</h6><p>需要先将元素插入到序列末尾push_back，然后调用push_heap进行上溯</p><h6 id="③sort"><a href="#③sort" class="headerlink" title="③sort"></a>③sort</h6><p>不断pop_head，将堆变为有序，不会清空树，需要make_heap才能使用堆操作</p><h6 id="④make-heap"><a href="#④make-heap" class="headerlink" title="④make_heap"></a>④make_heap</h6><p>将现有结构调整为堆结构（Floyd算法采用自底向上的调整方式，从最后一个非叶子节点开始，逐步向前进行下溯（sift down操作）</p><h3 id="（三）STL的两级空间配置器"><a href="#（三）STL的两级空间配置器" class="headerlink" title="（三）STL的两级空间配置器"></a>（三）STL的两级空间配置器</h3><h4 id="1、为什么需要二级空间配置器"><a href="#1、为什么需要二级空间配置器" class="headerlink" title="1、为什么需要二级空间配置器"></a>1、为什么需要二级空间配置器</h4><p>动态开辟内存时，会在堆上申请，频繁在堆上开辟释放内存，会在堆上造成很多外部碎片，当找不到合适内存时就进行空间合并。当开辟内存时如果小于128bytes，就使用二级空间配置器（默认）</p><h4 id="2、一级空间配置器"><a href="#2、一级空间配置器" class="headerlink" title="2、一级空间配置器"></a>2、一级空间配置器</h4><p>函数：allocate、deallocate、reallocate；以malloc&#x2F;free&#x2F;realloc等C涵执行实际的内存分配（free后，内存由glibc（ptmalloc）管理（可能放入bin中），但STL一级配置器对此毫不知情）不维护链表</p><h4 id="3、二级空间配置器"><a href="#3、二级空间配置器" class="headerlink" title="3、二级空间配置器"></a>3、二级空间配置器</h4><p>维护16条链表（8~128字节），看相应尺寸的链表是否为空，不为空就从free_list中拔出，指针向后移动；为空先看内存池是否为空，不为空则分配20个节点大小，不够20个就看是否满足一个，如果一个也不满足，将内存池挂到对应free_list；二级空间配置器使用malloc从堆上申请内存，申请40块，一半用，一半内存池；malloc失败找更大的free_list；最终失败则回调一级空间配置器</p><h4 id="4、二级缺点"><a href="#4、二级缺点" class="headerlink" title="4、二级缺点"></a>4、二级缺点</h4><p>内部碎片</p><p>内存挂在自由链表，不会还给操作系统</p><h4 id="5、内存池"><a href="#5、内存池" class="headerlink" title="5、内存池"></a>5、内存池</h4><p>预分配的大块内存，由程序自行管理分配&#x2F;释放，避免频繁调用系统API。初始内存来自堆，但管理权属于STL，逻辑上独立</p><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><h4 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h4><p>选择排序：O(n^2)，不稳定</p><p>快速排序：O(nlogn)，不稳定</p><p>空间复杂度：<em>O</em>(log<em>n</em>)，即递归使用栈空间的空间代价的期望为 <em>O</em>(log<em>n</em>)</p><p>希尔排序：O(nlog^2n)，不稳定</p><p>堆排序：O(nlogn)，不稳定</p><p>空间复杂度：<em>O</em>(log<em>n</em>)，即递归使用栈空间的空间代价。</p><p>归并排序：O(nlogn)，稳定</p><p>冒泡排序：O(n^2)，稳定</p><p>插入排序：O(n^2)，稳定</p><p>基数排序：O(nk)，稳定</p><p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20250401102328208.png" alt="image-20250401102328208"></p><h5 id="（1）递归快排"><a href="#（1）递归快排" class="headerlink" title="（1）递归快排"></a>（1）递归快排</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">function2</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> start, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (start &gt;= end) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> idx = start;</span><br><span class="line"><span class="type">int</span> l = start + <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> r = end;</span><br><span class="line"><span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line"><span class="keyword">while</span> (l &lt;= r &amp;&amp; nums[l] &lt;= nums[idx]) &#123;</span><br><span class="line">l++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (l &lt;= r &amp;&amp; nums[r] &gt;= nums[idx]) &#123;</span><br><span class="line">r--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (l &lt; r) &#123;</span><br><span class="line"><span class="built_in">swap</span>(nums[l], nums[r]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">swap</span>(nums[idx], nums[r]);</span><br><span class="line"><span class="built_in">function2</span>(nums, start, r<span class="number">-1</span>);</span><br><span class="line"><span class="built_in">function2</span>(nums, r + <span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;nums= &#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">7</span>&#125;;</span><br><span class="line"><span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line"><span class="built_in">function2</span>(nums,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; i : nums) &#123;</span><br><span class="line">cout &lt;&lt; i&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-非递归排序"><a href="#2-非递归排序" class="headerlink" title="(2)非递归排序"></a>(2)非递归排序</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fun1</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;nums,<span class="type">int</span> l,<span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> idx = l;</span><br><span class="line"><span class="type">int</span> start = l<span class="number">+1</span>;</span><br><span class="line"><span class="type">int</span> end = r;</span><br><span class="line"><span class="keyword">while</span> (start &lt;= end) &#123;</span><br><span class="line"><span class="keyword">while</span> (start &lt;= end &amp;&amp; nums[start] &lt;= nums[idx]) &#123;</span><br><span class="line">start++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (start &lt;= end &amp;&amp; nums[end] &gt;= nums[idx]) &#123;</span><br><span class="line">end--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (start &lt; end) &#123;</span><br><span class="line"><span class="built_in">swap</span>(nums[start], nums[end]);</span><br><span class="line">start++;</span><br><span class="line">end--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">swap</span>(nums[idx], nums[end]);</span><br><span class="line"><span class="keyword">return</span> end;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun2</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">queue &lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;q;</span><br><span class="line"><span class="type">int</span> l = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">q.<span class="built_in">push</span>(&#123; l,r &#125;);</span><br><span class="line"><span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line"><span class="keyword">auto</span> f = q.<span class="built_in">front</span>();</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="type">int</span> p=<span class="built_in">fun1</span>(nums, f.first, f.second);</span><br><span class="line"><span class="keyword">if</span> (f.first &lt; p - <span class="number">1</span>) &#123;</span><br><span class="line">q.<span class="built_in">push</span>(&#123; f.first,p - <span class="number">1</span> &#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (p + <span class="number">1</span> &lt; f.second) &#123;</span><br><span class="line">q.<span class="built_in">push</span>(&#123; p + <span class="number">1</span>,f.second &#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;nums = &#123; <span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">7</span> &#125;;</span><br><span class="line"><span class="built_in">fun2</span>(nums);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; i : nums) &#123;</span><br><span class="line">cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++数据结构(六)：变量类型</title>
      <link href="/my_tech_blog.github.io/2025/11/09/C++%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_6/"/>
      <url>/my_tech_blog.github.io/2025/11/09/C++%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_6/</url>
      
        <content type="html"><![CDATA[<h1 id="C-数据结构（六）：变量类型"><a href="#C-数据结构（六）：变量类型" class="headerlink" title="C++数据结构（六）：变量类型"></a>C++数据结构（六）：变量类型</h1><h2 id="一、分类1"><a href="#一、分类1" class="headerlink" title="一、分类1"></a>一、分类1</h2><h3 id="（一）结构体"><a href="#（一）结构体" class="headerlink" title="（一）结构体"></a>（一）结构体</h3><h4 id="1、对齐问题"><a href="#1、对齐问题" class="headerlink" title="1、对齐问题"></a>1、对齐问题</h4><p>第一个成员的地址和结构体地址相同，按照size最大的成员进行对齐，可以使用alignof&#x2F;əˈlaɪn&#x2F;算出对齐方式，可以使用alignas指定对齐方式（若小于自然对齐的最小单位，则失效，指定对齐单位为1则失效，使用#pragma pack（push,1)&#x2F;ˈpræɡmə pæk pʊʃ wʌn&#x2F;）</p><p>按照声明的顺序进行内存分配；每个变量相对于起始位置的偏移量必须是该变量类型大小的整数倍，不是整数倍空出内存，直到是整数倍为止；整个结构体的大小必须是结构体中size最大的成员的整数倍</p><p>#pragma pack（push,1)：偏移量是n和当前变量大小中较小值的整数倍；整体大小是n和最大变量中较小值的整数倍；n必须为1，2，4，8……其他值就按照默认分配</p><h4 id="2、和class的区别"><a href="#2、和class的区别" class="headerlink" title="2、和class的区别"></a>2、和class的区别</h4><p>struct默认成员共有，也默认共有继承</p><h4 id="3、和C中struct的区别"><a href="#3、和C中struct的区别" class="headerlink" title="3、和C中struct的区别"></a>3、和C中struct的区别</h4><p>C中struct是自定义数据类型，没有权限设置，只能封装不能隐藏，没有成员函数，需要typedef才能不使用struct定义对象；C++中是抽象数据类型，有成员函数</p><h4 id="4、如何获得结构成员相对于结构开头的字节偏移量"><a href="#4、如何获得结构成员相对于结构开头的字节偏移量" class="headerlink" title="4、如何获得结构成员相对于结构开头的字节偏移量"></a>4、如何获得结构成员相对于结构开头的字节偏移量</h4><p>使用&lt;stddef.h&gt;中的offsetof</p><h4 id="5、结构体变量比较是否相等"><a href="#5、结构体变量比较是否相等" class="headerlink" title="5、结构体变量比较是否相等"></a>5、结构体变量比较是否相等</h4><p>重载“&#x3D;&#x3D;”：元素一个一个比</p><h3 id="（二）类"><a href="#（二）类" class="headerlink" title="（二）类"></a>（二）类</h3><h4 id="1、构造函数与析构函数"><a href="#1、构造函数与析构函数" class="headerlink" title="1、构造函数与析构函数"></a>1、构造函数与析构函数</h4><h5 id="（1）析构函数、构造函数可否抛出异常"><a href="#（1）析构函数、构造函数可否抛出异常" class="headerlink" title="（1）析构函数、构造函数可否抛出异常"></a>（1）析构函数、构造函数可否抛出异常</h5><p>构造函数可以，失败时通过异常中断构造</p><p>析构函数不可以，必须保证不泄露</p><h5 id="（2）什么时候调用构造、析构（虚构）函数"><a href="#（2）什么时候调用构造、析构（虚构）函数" class="headerlink" title="（2）什么时候调用构造、析构（虚构）函数"></a>（2）什么时候调用构造、析构（虚构）函数</h5><p>对象不存在，没有用别的对象初始化，在创建一个新对象时使用构造函数</p><p>对象生命周期结束，被销毁时；delete指向对象的指针；对象i是对象o的成员，o析构，i也析构</p><p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20250414112004448.png" alt="image-20250414112004448"></p><h5 id="（3）什么时候会自动生成默认构造函数"><a href="#（3）什么时候会自动生成默认构造函数" class="headerlink" title="（3）什么时候会自动生成默认构造函数"></a>（3）什么时候会自动生成默认构造函数</h5><p>无显式构造函数 + 所有成员可默认构造（成员对象有默认构造函数，不能有const（C++11 及以后：允许在声明时直接初始化（类内初始化），但仍需保证所有构造函数不会覆盖该初始化）、引用（必本质是别名，必须在初始化列表初始化））</p><h5 id="（4）什么情况下合成构造函数"><a href="#（4）什么情况下合成构造函数" class="headerlink" title="（4）什么情况下合成构造函数"></a>（4）什么情况下合成构造函数</h5><p>没有构造函数、有成员对象、成员对象有默认构造函数</p><p>没有构造函数、有一个有默认构造函数的基类</p><p>带有虚函数的类：虚表指针是在构造函数中初始化</p><p>带有虚基类的类</p><h5 id="（5）什么时候合成拷贝构造函数"><a href="#（5）什么时候合成拷贝构造函数" class="headerlink" title="（5）什么时候合成拷贝构造函数"></a>（5）什么时候合成拷贝构造函数</h5><p>没有拷贝构造函数、有类类型成员变量、该类有拷贝构造函数</p><p>没有拷贝构造函数、基类有拷贝构造函数</p><p>没有拷贝构造函数、声明或继承了虚函数</p><p>没有拷贝构造函数，有虚基类</p><p>有三种情况会以一个对象的内容作为另一个对象的初值：X xx&#x3D;x（初始化）；对象作为函数形参；函数传回一个类对象</p><h5 id="（6）什么是trival-destructor"><a href="#（6）什么是trival-destructor" class="headerlink" title="（6）什么是trival destructor"></a>（6）什么是trival destructor</h5><p>没有自定义析构函数，系统自动生成</p><h4 id="2、如果有一个空类，它会默认添加哪些函数"><a href="#2、如果有一个空类，它会默认添加哪些函数" class="headerlink" title="2、如果有一个空类，它会默认添加哪些函数"></a>2、如果有一个空类，它会默认添加哪些函数</h4><p>缺省构造函数；拷贝构造函数；析构函数；赋值运算符</p><h5 id="（1）如何禁止程序自动生成拷贝构造函数"><a href="#（1）如何禁止程序自动生成拷贝构造函数" class="headerlink" title="（1）如何禁止程序自动生成拷贝构造函数"></a>（1）如何禁止程序自动生成拷贝构造函数</h5><p>手动重写写为private-&gt;类的成员函数和friend函数还是可以调用private函数，如果这个函数只生命不定义会产生连接错误-&gt;可以定义一个基类，将基类的拷贝构造函数和拷贝赋值函数定义为private</p><h5 id="（2）为什么拷贝构造函数必须传引用不能传值"><a href="#（2）为什么拷贝构造函数必须传引用不能传值" class="headerlink" title="（2）为什么拷贝构造函数必须传引用不能传值"></a>（2）为什么拷贝构造函数必须传引用不能传值</h5><p>值传递：对于类类型传递时，要先调用该类的拷贝构造函数初始化形参-&gt;会一直递归</p><p>引用传递：不会调用拷贝构造函数</p><h4 id="3、初始化"><a href="#3、初始化" class="headerlink" title="3、初始化"></a>3、初始化</h4><p>explicit防止编译器进行隐式类型转换或复制初始化。它的主要作用是避免意外的隐式转换.</p><h5 id="（1）直接初始化"><a href="#（1）直接初始化" class="headerlink" title="（1）直接初始化"></a>（1）直接初始化</h5><p>直接调用与实参相符的构造函数（可能是构造函数也可能是拷贝构造函数）（（））</p><p>赋值初始化：函数体内（所有数据成员分配内存后）（赋值右侧是一个表达式（例如函数返回值或类型转换），则可能会产生临时对象，降低效率），对与类对象会比初始化列表多调用一次默认构造函数</p><p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20250315190507844.png" alt="image-20250315190507844"></p><p>列表初始化：初始化列表（分配内存时，函数体未执行），只进行一次赋值</p><h6 id="①必须成员列表初始化"><a href="#①必须成员列表初始化" class="headerlink" title="①必须成员列表初始化"></a>①必须成员列表初始化</h6><p>引用、常量、调用基类构造函数，而他有参数、调用成员类构造函数，而他有参数。</p><h6 id="②成员初始化列表做了什么"><a href="#②成员初始化列表做了什么" class="headerlink" title="②成员初始化列表做了什么"></a>②成员初始化列表做了什么</h6><p>编译器会一一操作初始化列表（在类中成员的声明顺序），在任何显式用户代码之前执行。</p><h5 id="（2）拷贝初始化"><a href="#（2）拷贝初始化" class="headerlink" title="（2）拷贝初始化"></a>（2）拷贝初始化</h5><p>先创建一个临时对象（可以跳过），再调用拷贝构造函数进行初始化（&#x3D;）</p><h5 id="（3）和赋值的区别"><a href="#（3）和赋值的区别" class="headerlink" title="（3）和赋值的区别"></a>（3）和赋值的区别</h5><p> 在复杂的变量类型中，赋值是调用重载的&#x3D;号</p><h5 id="（4）构造函数"><a href="#（4）构造函数" class="headerlink" title="（4）构造函数"></a>（4）构造函数</h5><p><u>①默认</u></p><p><u>②初始化（有参数和参数列表）</u></p><p><u>③拷贝</u></p><p>什么时候会调用拷贝函数？</p><p>用一个实例去初始化另一个（&#x3D;）；函数的参数是类的对象（非引用传递）；返回值是类对象（A&amp;fun() ；没有形参-&gt;值；有形参-&gt;引用）</p><p>深层复制</p><p>参数是左值引用</p><p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20250313165628205.png" alt="image-20250313165628205"></p><p><u>④移动（move和右值引用）</u></p><p>将原来指针置空，防止析构函数回收空间</p><p>对于指针使用浅层复制</p><p>参数是右值引用或将亡值引用，move语句将左值变为将亡值</p><p><u>⑤转换</u></p><p>只有一个形参且该形参不是该类对象</p><h5 id="（5）构造函数、拷贝构造函数、赋值操作符的区别"><a href="#（5）构造函数、拷贝构造函数、赋值操作符的区别" class="headerlink" title="（5）构造函数、拷贝构造函数、赋值操作符的区别"></a>（5）构造函数、拷贝构造函数、赋值操作符的区别</h5><p>构造函数：对象不存在，没有用别的对象初始化，在创建一个新对象时使用构造函数</p><p>拷贝构造函数：对象不存在，用别的对象初始化，会生成新的类对象</p><p>赋值操作符：对象存在，用别的对象给它赋值，属于重载“&#x3D;”，两侧都是已经存在的对象。果原来有内存分配需要先释放，需要检查对象是否相同，分配新资源，返回引用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">student s1=s;<span class="comment">//拷贝</span></span><br><span class="line"></span><br><span class="line">s1=s;<span class="comment">//赋值</span></span><br></pre></td></tr></table></figure><h5 id="（6）代码"><a href="#（6）代码" class="headerlink" title="（6）代码"></a>（6）代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span>* data;<span class="comment">//深拷贝和浅拷贝不同</span></span><br><span class="line"><span class="type">int</span> size = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="type">int</span> b;</span><br><span class="line"><span class="built_in">MyClass</span>():<span class="built_in">a</span>(<span class="number">0</span>),<span class="built_in">b</span>(<span class="number">0</span>),<span class="built_in">data</span>(<span class="literal">nullptr</span>),<span class="built_in">size</span>(<span class="number">0</span>)&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;默认构造&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">MyClass</span>(<span class="type">int</span> _a,<span class="type">int</span> _b,<span class="type">int</span> _size):<span class="built_in">a</span>(_a),<span class="built_in">b</span>(_b),<span class="built_in">size</span>(_size)&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;带参数的构造函数&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">data = <span class="keyword">new</span> <span class="type">int</span>[size];<span class="comment">//为什么不是(size),vector是使用()吗</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; size;i++) &#123;</span><br><span class="line">data[i] = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">data = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//深拷贝和浅拷贝，需要new吗</span></span><br><span class="line"><span class="comment">/*MyClass(const MyClass&amp; other) :a(other.a), b(other.b),size(other.size),data(other.data) &#123;</span></span><br><span class="line"><span class="comment">cout &lt;&lt; &quot;浅拷贝构造函数&quot;&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="built_in">MyClass</span>(<span class="type">const</span> MyClass&amp; other) :<span class="built_in">a</span>(other.a), <span class="built_in">b</span>(other.b), <span class="built_in">size</span>(other.size) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;深拷贝构造函数&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">if</span> (other.data != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">data = <span class="keyword">new</span> <span class="type">int</span>[size];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; size;++i) &#123;</span><br><span class="line">data[i] = other.data[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">data = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//赋值不是构造</span></span><br><span class="line">MyClass&amp; <span class="keyword">operator</span>=(<span class="type">const</span> MyClass&amp; other) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123;</span><br><span class="line"><span class="keyword">delete</span>[]data;</span><br><span class="line">a = other.a;</span><br><span class="line">b = other.b;</span><br><span class="line">size = other.size;</span><br><span class="line"><span class="keyword">if</span> (other.data != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">data = <span class="keyword">new</span> <span class="type">int</span>[size];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; size;++i) &#123;</span><br><span class="line">data[i] = other.data[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">data = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;赋值&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//移动</span></span><br><span class="line"><span class="comment">//noexcept告诉编译器这个函数不会抛出异常，有助于优化</span></span><br><span class="line"><span class="built_in">MyClass</span>(MyClass&amp;&amp;other)<span class="keyword">noexcept</span>:<span class="built_in">a</span>(other.a),<span class="built_in">b</span>(other.b),<span class="built_in">data</span>(other.data),<span class="built_in">size</span>(other.size)&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;移动构造函数&quot;</span>&lt;&lt;endl;</span><br><span class="line">other.data = <span class="literal">nullptr</span>;</span><br><span class="line">other.size = <span class="number">0</span>;</span><br><span class="line">other.a = <span class="number">0</span>;</span><br><span class="line">other.b = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">MyClass&amp; <span class="keyword">operator</span>=(MyClass&amp;&amp; other)<span class="keyword">noexcept</span> &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;移动赋值函数&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123;</span><br><span class="line"><span class="keyword">delete</span>[]data;</span><br><span class="line">a = other.a;</span><br><span class="line">b = other.b;</span><br><span class="line">data = other.data;</span><br><span class="line">size = other.size;</span><br><span class="line">other.data = <span class="literal">nullptr</span>;</span><br><span class="line">other.size = <span class="number">0</span>;</span><br><span class="line">a = <span class="number">0</span>;</span><br><span class="line">b = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//显示</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a=&quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;b=&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;size=&quot;</span> &lt;&lt; size &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;data:&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; size;++i) &#123;</span><br><span class="line">cout &lt;&lt; data[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//析构</span></span><br><span class="line">~<span class="built_in">MyClass</span>() &#123;</span><br><span class="line"><span class="keyword">delete</span>[]data;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;析构函数&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">MyClass <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">MyClass</span>(<span class="number">100</span>, <span class="number">200</span>, <span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun1</span><span class="params">(MyClass a)</span> </span>&#123;</span><br><span class="line">a.<span class="built_in">display</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun2</span><span class="params">(MyClass&amp;a)</span> </span>&#123;</span><br><span class="line">a.<span class="built_in">display</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//默认构造</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;=========================================obj1:&quot;</span> &lt;&lt; endl;</span><br><span class="line">MyClass obj1;</span><br><span class="line">obj<span class="number">1.</span><span class="built_in">display</span>();</span><br><span class="line"><span class="comment">//带参构造</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;=========================================obj2:&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="function">MyClass <span class="title">obj2</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span></span>;</span><br><span class="line">obj<span class="number">2.</span><span class="built_in">display</span>();</span><br><span class="line"><span class="comment">//浅拷贝构造</span></span><br><span class="line"><span class="comment">//深拷贝构造</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;=========================================obj3:&quot;</span> &lt;&lt; endl;</span><br><span class="line">MyClass obj3 = obj3;</span><br><span class="line">obj<span class="number">3.</span><span class="built_in">display</span>();</span><br><span class="line"><span class="comment">//移动构造</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;=========================================obj4:&quot;</span> &lt;&lt; endl;</span><br><span class="line">MyClass obj4 = <span class="built_in">create</span>();</span><br><span class="line">obj<span class="number">4.</span><span class="built_in">display</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;=========================================obj4_2:&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="function">MyClass <span class="title">obj4_2</span><span class="params">(std::move(obj4))</span></span>;</span><br><span class="line">obj4_<span class="number">2.</span><span class="built_in">display</span>();</span><br><span class="line"><span class="comment">//赋值</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;=========================================obj5:&quot;</span> &lt;&lt; endl;</span><br><span class="line">MyClass obj5;</span><br><span class="line">obj5 = obj4_2;</span><br><span class="line">obj<span class="number">5.</span><span class="built_in">display</span>();</span><br><span class="line"><span class="comment">//移动赋值</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;=========================================obj6:&quot;</span> &lt;&lt; endl;</span><br><span class="line">MyClass obj6;</span><br><span class="line">obj6 = std::<span class="built_in">move</span>(obj5);</span><br><span class="line">obj<span class="number">6.</span><span class="built_in">display</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;=========================================fun1:&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="built_in">fun1</span>(obj1);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;=========================================fun2:&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="built_in">fun2</span>(obj1);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;析构&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h4 id="4、C-的抽象类"><a href="#4、C-的抽象类" class="headerlink" title="4、C++的抽象类"></a>4、C++的抽象类</h4><p>含有没有定义的纯虚函数，所以不能实例化</p><h5 id="（1）纯虚函数与虚函数的区别"><a href="#（1）纯虚函数与虚函数的区别" class="headerlink" title="（1）纯虚函数与虚函数的区别"></a>（1）纯虚函数与虚函数的区别</h5><p>没有函数体，函数指针会被存在虚函数表中，值为0（虚函数是函数的具体地址）</p><h5 id="（2）作用"><a href="#（2）作用" class="headerlink" title="（2）作用"></a>（2）作用</h5><p>避免直接实例化无意义的基类</p><p>实现多态，提供代码的共享实现</p><p>解耦设计（耦（Coupling）：指模块&#x2F;组件间的依赖关系和关联程度；）</p><p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20250411150841700.png" alt="image-20250411150841700"></p><p>模板方法模式：定义算法框架</p><p>定义接口规范</p><h4 id="5、this指针"><a href="#5、this指针" class="headerlink" title="5、this指针"></a>5、this指针</h4><p>是类的指针，指向对象的首地址，是非静态成员函数的隐含形参（函数的第一个参数：成员函数隐式接收this指针（编译器自动处理）。成员函数的隐式参数），对个各成员的访问通过this</p><h5 id="（1）用途"><a href="#（1）用途" class="headerlink" title="（1）用途"></a>（1）用途</h5><p>返回类对象本身return *this;；形参与成员变量名区分</p><h5 id="（2）特点"><a href="#（2）特点" class="headerlink" title="（2）特点"></a>（2）特点</h5><p>全局函数。静态函数不能使用this</p><p>是非静态成员函数的第一个传入参数，在函数开始前构造，结束后清除（成员函数外无法获得该this指针）</p><p>传递效率比较高（根据编译器，可能在栈、也可能是寄存器，甚至是全局变量），一个数在汇编级别中只可能是立即数、内存、寄存器</p><h5 id="（3）如何传递类中的函数"><a href="#（3）如何传递类中的函数" class="headerlink" title="（3）如何传递类中的函数"></a>（3）如何传递类中的函数</h5><p>大多数编译器通过ecx（寄数寄存器）寄存器传递this指针</p><p>编译器会把对象首地址放入ecx</p><h5 id="（4）delete-this"><a href="#（4）delete-this" class="headerlink" title="（4）delete this"></a>（4）delete this</h5><h6 id="①成员函数中调用"><a href="#①成员函数中调用" class="headerlink" title="①成员函数中调用"></a>①成员函数中调用</h6><p>在类对象的内存空间中，包括数据成员和虚函数指针，不包括代码，类的成员函数单独放在代码段中，在调用成员函数时，有一个隐含的this指针传入，告诉函数是哪个对象调用的，当delete this，释放内存，此时还可以调用与this无关的内容，如成员函数，但是不可以使用数据成员和虚函数，否则会出现不可预期的问题</p><p>内存不是马上回收，还是可以访问的，所以当获取数据成员得到未初始化的随机数；虚函数表，指针无效可能性高，系统崩溃</p><h6 id="②析构函数中调用"><a href="#②析构函数中调用" class="headerlink" title="②析构函数中调用"></a>②析构函数中调用</h6><p>delete的本质是为将被释放的内存调用一个或多个析构函数，然后释放内存，所以在析构函数中使用delete this，会造成无限递归，堆栈溢出，系统崩溃</p><h5 id="（5）当调用成员变量，堆栈会发生什么变化"><a href="#（5）当调用成员变量，堆栈会发生什么变化" class="headerlink" title="（5）当调用成员变量，堆栈会发生什么变化"></a>（5）当调用成员变量，堆栈会发生什么变化</h5><p>this指针先入栈，函数参数从右向左依次入栈，最后返回地址入栈</p><h5 id="（6）成员函数里memeset（this，0，sizeof-this-）会发生什么"><a href="#（6）成员函数里memeset（this，0，sizeof-this-）会发生什么" class="headerlink" title="（6）成员函数里memeset（this，0，sizeof(*this)）会发生什么"></a>（6）成员函数里memeset（this，0，sizeof(*this)）会发生什么</h5><p>初始化为0</p><p>类含有虚函数表、C++类型的对象不行</p><h4 id="6、计算对象个数"><a href="#6、计算对象个数" class="headerlink" title="6、计算对象个数"></a>6、计算对象个数</h4><p>static-&gt;类定义结束后初始化-&gt;构造函数+1-&gt;拷贝函数+1-&gt;赋值函数+1-&gt;析构函数-1</p><h3 id="（四）指针和引用"><a href="#（四）指针和引用" class="headerlink" title="（四）指针和引用"></a>（四）指针和引用</h3><p>指针是一个变量，存储的是地址，引用是一个变量的别名，没有分配空间（看编译器）；指针可以先定义后初始化，且可以为NULL、可以改变，引用不可以；在作为参数传递，改变指针的指向不会改变实参，通过解引用可以改变实参；指针可以多级，引用不可以</p><h4 id="1、-在传递参数时，什么时候使用指针，什么时候使用引用"><a href="#1、-在传递参数时，什么时候使用指针，什么时候使用引用" class="headerlink" title="1、 在传递参数时，什么时候使用指针，什么时候使用引用"></a>1、 在传递参数时，什么时候使用指针，什么时候使用引用</h4><p>当需要返回函数内部变量时使用指针；当是类对象时使用引用，这是C++对象传递的标准方式；当对栈空间敏感时使用引用（例如递归），因为引用不需要创建临时变量，所以开销更小；当需要改变实参时使用引用</p><h5 id="（1）值传递、指针传递、引用传递"><a href="#（1）值传递、指针传递、引用传递" class="headerlink" title="（1）值传递、指针传递、引用传递"></a>（1）值传递、指针传递、引用传递</h5><p>值传递：传值（大型数据消耗大）；有一个形参向函数栈拷贝数据的过程</p><p>指针传递：传值，地址值（需要通过指针间接访问数据）；有一个形参向函数栈拷贝数据的过程</p><p>引用传递：传地址（间接寻址）；存在数据拷贝过程，但是是针对地址的，为该数据的地址起了别名</p><p>指针传递、引用传递效率比值传递高；从编译角度上来讲，符号表记录变量名称和地址，指针变量在符号表中的值是指针地址，而引用在符号表中的值是引用对象的地址，符号表不可更改</p><h6 id="①引用传递好处"><a href="#①引用传递好处" class="headerlink" title="①引用传递好处"></a>①引用传递好处</h6><p>可以对实参进行修改；提高了函数调用和运行的效率（没有了传值和生成副本的时间和消耗）；</p><p>引用传递返回值：在内存中不产生被返回值的副本</p><p>引用传递返回的限制：不能返回局部变量的引用；不能返回函数内部new分配的内存的引用；可以返回类成员的引用，但是最好是const</p><h4 id="2、指针"><a href="#2、指针" class="headerlink" title="2、指针"></a>2、指针</h4><h5 id="（1）区别指针"><a href="#（1）区别指针" class="headerlink" title="（1）区别指针"></a>（1）区别指针</h5><p>用括号括起来的是单个指针</p><p>int *p[10]指针数组：数组内每个元素都是指针（sizeof(p)&#x3D;10 *sizeof(int *)&#x3D;10 *4&#x2F;8）</p><p>int （*p)[10]数组指针：指向一个数组的一个指针（sizeof(int *)）</p><p>int *p（int)函数：返回值是指针</p><p>int （*p)（int)函数指针：指向一个带有int参数、返回值为int的函数</p><p>指针的字节大小和机器位数有关，32位则4字节， 64位8字节</p><h6 id="①函数指针"><a href="#①函数指针" class="headerlink" title="①函数指针"></a>①函数指针</h6><p>函数的类型由返回值和它的参数决定，与它的名称无关，必须有括号(*p)</p><p>一个函数名就是一个指针，指向函数的代码。函数调用可以通过函数名，也可以通过指向函数的指针来调用。函数指针还允许将函数作为变元传递给其他函数</p><p>两种赋值方式：指针名&#x3D;函数名；指针名&#x3D;&amp;函数名</p><h6 id="②为什么有函数指针"><a href="#②为什么有函数指针" class="headerlink" title="②为什么有函数指针"></a>②为什么有函数指针</h6><p>函数与数据类似，也有自己的地址，我们行为在同一个函数中通过使用相同的形参在不同的时间产生不同的效果。</p><h5 id="（2）指针所占的字节数"><a href="#（2）指针所占的字节数" class="headerlink" title="（2）指针所占的字节数"></a>（2）指针所占的字节数</h5><p>32位编译器则4字节，64位编译器则8字节</p><h5 id="（3）指针常量和常量指针"><a href="#（3）指针常量和常量指针" class="headerlink" title="（3）指针常量和常量指针"></a>（3）指针常量和常量指针</h5><p>指针常量int *const p本身是常量</p><p>常量指针const int *p（int const *p)指向常量</p><h5 id="（4）a和-a的区别"><a href="#（4）a和-a的区别" class="headerlink" title="（4）a和&amp;a的区别"></a>（4）a和&amp;a的区别</h5><p>int a[10]和int （*p)[10]&#x3D;&amp;a（数组名和指针（指向数组首元素的指针），sizeof(a)&#x3D;10 *sizeof(int)，sizeof(int)与机器位数无关&#x3D;4）</p><p>a的数组名，是数组首元素地址，a+1则是在地址上加一个int（4字节)，*（a+1)&#x3D;a[1]</p><p>&amp;a是数组指针，+1是加整个数组长度（4*10个字节)，指向数组之后的第一个元素</p><h6 id="①数组名和指针（指向数组首元素的指针）"><a href="#①数组名和指针（指向数组首元素的指针）" class="headerlink" title="①数组名和指针（指向数组首元素的指针）"></a>①数组名和指针（指向数组首元素的指针）</h6><p>二者均可以通过偏移量进行元素访问；但是数组名是常量指针，不能进行自加、自减；当数组名作为形参传递给函数时，就变成指针了，可以自加，但是不能通过sizeof计算数组大小了</p><h6 id="②指针加减"><a href="#②指针加减" class="headerlink" title="②指针加减"></a>②指针加减</h6><p>指针每移动一位，实际跨越的内存间隔是指针类型的长度</p><p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20250315215049323.png" alt="image-20250315215049323"></p><h5 id="（5）悬空指针和野指针"><a href="#（5）悬空指针和野指针" class="headerlink" title="（5）悬空指针和野指针"></a>（5）悬空指针和野指针</h5><p>悬空指针：指向的内存被释放（引入智能指针）</p><p>野指针：没有及时初始化</p><h5 id="（6）智能指针"><a href="#（6）智能指针" class="headerlink" title="（6）智能指针"></a>（6）智能指针</h5><p>share_ptr：引用计数</p><p>unique_ptr：对象的独占所有权</p><p>weak_ptr：观察share_ptr管理的资源，但是不会增加引用计数</p><p>问题</p><p>shared_ptr会相互引用，导致引用计数无法归零，内存无法释放；使用weak_ptr打破循环引用</p><p>需要维护引用计数，存在额外的性能开销；不需要共享所有权时优先使用unique_ptr</p><p>share_ptr的引用计数是线程安全的，但指向的对象不是；使用互斥锁保护共享资源</p><h6 id="①线程安全"><a href="#①线程安全" class="headerlink" title="①线程安全"></a>①线程安全</h6><p>正确安全地进行多线程访问，无序额外的同步机制</p><p>互斥锁；原子操作；线程局部存储；使用不可变对象；实现线程安全的数据结构</p><h4 id="3、引用"><a href="#3、引用" class="headerlink" title="3、引用"></a>3、引用</h4><h5 id="（1）从汇编层解释引用"><a href="#（1）从汇编层解释引用" class="headerlink" title="（1）从汇编层解释引用"></a>（1）从汇编层解释引用</h5><p>本质是常量指针，通过内存地址访问数据。引用是将x的值加载到寄存器，而指针是将x的地址脚趾到寄存器</p><h4 id="4、深拷贝和浅拷贝"><a href="#4、深拷贝和浅拷贝" class="headerlink" title="4、深拷贝和浅拷贝"></a>4、深拷贝和浅拷贝</h4><p>指针变量本身是需要分配内存的，但指针所指向的内存（即指针存储的地址对应的内存）是否需要分配，取决于具体的用法和上下文。</p><h5 id="（1）深拷贝"><a href="#（1）深拷贝" class="headerlink" title="（1）深拷贝"></a>（1）深拷贝</h5><p>不仅拷贝值，还开辟一块新的空间存放新的值</p><h5 id="（2）浅拷贝"><a href="#（2）浅拷贝" class="headerlink" title="（2）浅拷贝"></a>（2）浅拷贝</h5><p>只是拷贝了一个指针，没有开辟新的地址，与原来指针指向同一个地址；原来内存释放会导致悬空指针</p><h2 id="二、分类2"><a href="#二、分类2" class="headerlink" title="二、分类2"></a>二、分类2</h2><h3 id="全局变量和局部变量的区别"><a href="#全局变量和局部变量的区别" class="headerlink" title="全局变量和局部变量的区别"></a>全局变量和局部变量的区别</h3><p>生命周期不同</p><p>使用方式不同：各个部分都可以使用；局部使用</p><p>存储位置不同（操作系统和编译器如何区分两者）：全局数据段，在程序开始时被加载；堆栈</p><h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><h3 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h3><h3 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h3>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 变量类型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++数据结构(五)：关键字</title>
      <link href="/my_tech_blog.github.io/2025/11/09/C++%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_5/"/>
      <url>/my_tech_blog.github.io/2025/11/09/C++%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_5/</url>
      
        <content type="html"><![CDATA[<h1 id="C-数据结构（五）：关键字"><a href="#C-数据结构（五）：关键字" class="headerlink" title="C++数据结构（五）：关键字"></a>C++数据结构（五）：关键字</h1><p>static和const；override和final；extern；public&#x2F;private&#x2F;protect；volatile&#x2F;mutable&#x2F;explicit</p><h2 id="一、static"><a href="#一、static" class="headerlink" title="一、static"></a>一、static</h2><p>所有对象共有的；可以直接使用类名调用；在对象构建之前，与类（类变量，普通称为实例变量）一起构建，仅在类加载时执行；生命周期与类相同（普通成员变量与对象相同）；地址在方法区的静态区（普通在堆内存的对象中，是对象的特有数据）；（静态方法只能访问静态变量，静态函数中没有this，main函数是静态的）</p><p>不考虑类：隐藏，不加的全局变量具有全局可见性，但是加了之后就只能在当前文件中使用；初始化为0；保持变量持久，生命周期和程序相同，函数中的静态变量始终存在且只进行一次初始化，但是退出函数后就不能使用了</p><p>考虑类：</p><p>成员变量：只与类关联，不于对象关联，只有一份拷贝；先于对象存在，必须在类外初始化，初始化可以不加static关键字；可以被非static成员函数访问</p><p>成员函数：没有this指针；只能访问静态成员；不能被声明为const、虚函数、volatile(不能被编译器优化，可以被编译器未知因素更改，确保每次访问都从内存中读取最新的值)；可以被非静态成员访问</p><h3 id="1、与全局变量区别"><a href="#1、与全局变量区别" class="headerlink" title="1、与全局变量区别"></a>1、与全局变量区别</h3><p>存储方式相同，都是静态存储；</p><p>作用域是整个源程序</p><h3 id="2、与普通函数区别"><a href="#2、与普通函数区别" class="headerlink" title="2、与普通函数区别"></a>2、与普通函数区别</h3><p>作用域不同，在内存中只有一份</p><h3 id="3、与普通成员区别"><a href="#3、与普通成员区别" class="headerlink" title="3、与普通成员区别"></a>3、与普通成员区别</h3><p>生命周期；共享方式；定义位置（普通位于堆栈，static在静态全局区）初始化位置；默认实参（可以使用静态成员作为默认实参）</p><h2 id="二、const"><a href="#二、const" class="headerlink" title="二、const"></a>二、const</h2><h3 id="1、关键字的特点"><a href="#1、关键字的特点" class="headerlink" title="1、关键字的特点"></a>1、关键字的特点</h3><p>不考虑类：隐藏；必须在定义时初始化，之后不可更改；const形参可以接收const或非const的实参；当指针传递、引用传递，可以使用const保护实参</p><p>考虑类：</p><p>成员变量：必须在构造函数初始化列表进行初始化；</p><p>成员函数：const对象不可以调用非const成员函数；可以被非const对象调用；不不可以改变被mutable修饰之外的变量；有时候返回值需为const类型，以使其返回值不为左值（放止对返回值修改）</p><h3 id="2、底层const与顶层const"><a href="#2、底层const与顶层const" class="headerlink" title="2、底层const与顶层const"></a>2、底层const与顶层const</h3><p>顶层const：本身是常量（指针常量）</p><p>底层const：指向常量（常量指针）</p><p>（底层const不能赋值给非底层const，const_cast只能修改(移除)底层const）</p><h2 id="三、override"><a href="#三、override" class="headerlink" title="三、override"></a>三、override</h2><p>该函数重写的父类虚函数</p><h2 id="四、final"><a href="#四、final" class="headerlink" title="四、final"></a>四、final</h2><p>不希望某个类被继承或者不希望某个虚函数被重写</p><h2 id="五、extern"><a href="#五、extern" class="headerlink" title="五、extern"></a>五、extern</h2><p>声明，表示定义在其它文件中</p><p>在C++中调用C的语言代码，extern”C”{}</p><h3 id="1、定义和声明"><a href="#1、定义和声明" class="headerlink" title="1、定义和声明"></a>1、定义和声明</h3><h4 id="（1）变量定义和声明"><a href="#（1）变量定义和声明" class="headerlink" title="（1）变量定义和声明"></a>（1）变量定义和声明</h4><p>extern是显式声明，只是告诉编译器变量声明的位置和类型，并不分配内存空间，可以多次声明；</p><p>不加extern（如int x;）是定义，分配内存，仅能定义一次</p><h4 id="（2）函数的定义和声明"><a href="#（2）函数的定义和声明" class="headerlink" title="（2）函数的定义和声明"></a>（2）函数的定义和声明</h4><p>声明：一般在头文件里，向编译器说明函数存在</p><p>定义：源文件，函数体</p><h2 id="六、public-private-protect"><a href="#六、public-private-protect" class="headerlink" title="六、public&#x2F;private&#x2F;protect"></a>六、public&#x2F;private&#x2F;protect</h2><p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20250313154926360.png" alt="image-20250313154926360"></p><p>内部访问：派生类中成员函数对基类进行访问</p><p>外部访问：派生类外（private继承，派生类的派生类无法访问基类的任何成员）</p><h2 id="七、volatile"><a href="#七、volatile" class="headerlink" title="七、volatile"></a>七、volatile</h2><p>允许变量被某些编译器未知的因素更改，不能被编译器优化，每次都从内存（寄存器×）中读取最新的结果</p><p>易变的变量，多线程中共同使用的变量；中断程序中对修改供其它程序检测的变量；存储器映射的硬件寄存器（每次对它的读写可能都有不同意义）</p><p>如果一个类对象被修饰，只能调用其中被修饰的成员函数；如果一个类对象被声明为 ，则它的成员变量也会被视为；可以用const_cast移除</p><h2 id="八、mutable"><a href="#八、mutable" class="headerlink" title="八、mutable"></a>八、mutable</h2><p>在const中可以修改的</p><h2 id="九、explic"><a href="#九、explic" class="headerlink" title="九、explic"></a>九、explic</h2><p>不能隐式类型转换</p><h2 id="十、宏定义"><a href="#十、宏定义" class="headerlink" title="十、宏定义"></a>十、宏定义</h2><p>定义常量及书写复杂的内容，不分配内存，但是直接替换会生成多个备份</p><h3 id="1、和函数有什么区别"><a href="#1、和函数有什么区别" class="headerlink" title="1、和函数有什么区别"></a>1、和函数有什么区别</h3><p>宏定义是在预处理阶段进行处理（文本替换），结尾没有分号，没有返回值、类型；函数在编译阶段被编译为汇编代码，再通过汇编阶段转换为机器指令，运行时需要跳转到具体函数，函数声明需要加分号。占用代码段空间，可以通过undef取消定义然后进行重定义，只要是之前预定义的宏，在以后的程序中都可以使用</p><h3 id="2、和typedef有什么区别"><a href="#2、和typedef有什么区别" class="headerlink" title="2、和typedef有什么区别"></a>2、和typedef有什么区别</h3><p>（typedef可以修饰struct，C中创建对象就不需要写struct了，C++本来就不用）</p><p>typedef对类型进行重命名，需要进行类型检查，是语句末尾要加分号，在编译的一部分，在编译时有效，有作用域</p><h3 id="3、和const的区别"><a href="#3、和const的区别" class="headerlink" title="3、和const的区别"></a>3、和const的区别</h3><p>const进行类型计算，在编译和运行时起作用，需要分配内存，可以进行常量折叠，占用数据段空间，不能重定义</p><h3 id="4、online内联函数区别"><a href="#4、online内联函数区别" class="headerlink" title="4、online内联函数区别"></a>4、online内联函数区别</h3><p>在编译时进行参数类型检查（直接将函数代码嵌入到目标代码），有返回值，可以重载，没有歧义</p><p>作为类的接口函数读写私有成员和保护成员可以提高效率（内联函数的主要目的是减少函数调用的开销）</p><h4 id="（1）为什么不把所有函数写成内联函数"><a href="#（1）为什么不把所有函数写成内联函数" class="headerlink" title="（1）为什么不把所有函数写成内联函数"></a>（1）为什么不把所有函数写成内联函数</h4><p>函数体内代码长，内存消耗大；体内有循环，函数执行时间比函数调用大</p><h4 id="（2）构造函数、析构函数、虚函数是否可以声明为内联函数"><a href="#（2）构造函数、析构函数、虚函数是否可以声明为内联函数" class="headerlink" title="（2）构造函数、析构函数、虚函数是否可以声明为内联函数"></a>（2）构造函数、析构函数、虚函数是否可以声明为内联函数</h4><p>理论上可以</p><p>构造函数和析构函数声明为内联函数是没有意义的（包含隐式操作编译器会忽略）</p><p>当指向派生类的指针调用内联虚函数不会展开（动态绑定），对象本身调用虚函数可能会内联展开（无动态需求）</p><h3 id="5、ifdef和endif"><a href="#5、ifdef和endif" class="headerlink" title="5、ifdef和endif"></a>5、ifdef和endif</h3><p>条件编译；防止多次包含头文件的“重定义”问题</p><h2 id="十一、构造函数的几种关键字"><a href="#十一、构造函数的几种关键字" class="headerlink" title="十一、构造函数的几种关键字"></a>十一、构造函数的几种关键字</h2><p>default：显式要求编译器生成合成构造函数，防止在调用时相关构造函数类型没有定义</p><p>delete：可以删除构造函数、赋值运算符等</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 关键字 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++数据结构(四)：从代码到程序</title>
      <link href="/my_tech_blog.github.io/2025/11/09/C++%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_4/"/>
      <url>/my_tech_blog.github.io/2025/11/09/C++%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_4/</url>
      
        <content type="html"><![CDATA[<h1 id="C-数据结构（四）：从代码到程序"><a href="#C-数据结构（四）：从代码到程序" class="headerlink" title="C++数据结构（四）：从代码到程序"></a>C++数据结构（四）：从代码到程序</h1><h2 id="一、C-从代码到可执行程序经历了什么"><a href="#一、C-从代码到可执行程序经历了什么" class="headerlink" title="一、C++从代码到可执行程序经历了什么"></a>一、C++从代码到可执行程序经历了什么</h2><h3 id="1、预处理-预编译"><a href="#1、预处理-预编译" class="headerlink" title="1、预处理&#x2F;预编译"></a>1、预处理&#x2F;预编译</h3><p>处理宏定义、预编译指令（头文件的包含是递归的）、保留编译器指令，添加行号和文件标识、删除所有注释</p><p>生成.i、.ii</p><h3 id="2、编译"><a href="#2、编译" class="headerlink" title="2、编译"></a>2、编译</h3><p>词法分析、语法分析、语义分析、优化、目标代码生成、目标代码分析</p><p>生成汇编代码文件.s</p><h3 id="3、汇编"><a href="#3、汇编" class="headerlink" title="3、汇编"></a>3、汇编</h3><p>变为机器码文件.o、.obj（可重定位目标文件，并不是可执行文件，可执行文件在链接后生成）</p><h4 id="（1）可重定位目标文件"><a href="#（1）可重定位目标文件" class="headerlink" title="（1）可重定位目标文件"></a>（1）可重定位目标文件</h4><p>可重定位目标文件是链接过程的输入</p><p>可与其它可重定位目标文件链接，创建一个可执行目标文件</p><h3 id="4、链接"><a href="#4、链接" class="headerlink" title="4、链接"></a>4、链接</h3><p>将不同源文件生成的目标文件进行链接，生成可以执行的程序</p><p>可以通过检查依赖项或者查看文件大小，静态无依赖且文件较大</p><h4 id="（1）静态链接（-a-lib）"><a href="#（1）静态链接（-a-lib）" class="headerlink" title="（1）静态链接（.a&#x2F;.lib）"></a>（1）静态链接（.a&#x2F;.lib）</h4><p>在形成进行可执行程序时链接，以目标文件为单位</p><p>在编译链接可执行文件时，将程序运行所需要的所有目标文件（如库直接插入到代码）链接</p><p>缺点：（空间浪费）内存消耗大，可能存在多个副本；（更新困难）当代码库文件修改了，需要重新编译链接形成可执行文件</p><p>优点：运行速度快</p><p>用途：完全独立运行</p><h4 id="（2）动态链接（-so-dll）"><a href="#（2）动态链接（-so-dll）" class="headerlink" title="（2）动态链接（.so&#x2F;.dll）"></a>（2）动态链接（.so&#x2F;.dll）</h4><p>在生成可执行程序时链接，在运行时由动态链接器加载所需动态库到内存</p><p>把程序按照模块进行拆分，在程序运行时才将它们进行链接</p><p>优点：共享库，不会存在多个副本；更新方便：只需要替换原来的目标文件</p><p>缺点：性能有损失；如果转发需要携带动态链接库，没有运行库无法运行</p><p>用途：灵活升级功能、依赖系统通用库、多个程序共享一库</p><p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20250318215856125.png" alt="image-20250318215856125"></p><h3 id="5、程序"><a href="#5、程序" class="headerlink" title="5、程序"></a>5、程序</h3><h4 id="（1）可执行目标文件"><a href="#（1）可执行目标文件" class="headerlink" title="（1）可执行目标文件"></a>（1）可执行目标文件</h4><p>可以直接在内存中执行</p><ul><li><strong>Windows</strong>：<strong>严重依赖文件后缀名</strong>来判断一个文件是否为可执行文件。(.exe)</li><li><strong>Linux</strong>：<strong>不依赖文件后缀名</strong>，而是通过文件的<strong>权限属性</strong>来判断。(<strong>ELF</strong>：这是现代 Linux 系统中最主流的可执行文件格式；可执行的Shell脚本)</li></ul><h4 id="（2）共享目标文件（动态链接库-so、-dll）"><a href="#（2）共享目标文件（动态链接库-so、-dll）" class="headerlink" title="（2）共享目标文件（动态链接库.so、.dll）"></a>（2）共享目标文件（动态链接库.so、.dll）</h4><p>特殊可重定位目标文件，客栈运行时被动态加载进内存并链接</p><h3 id="6、运行"><a href="#6、运行" class="headerlink" title="6、运行"></a>6、运行</h3><p>操作系统将可执行文件加载到内存并运行</p><h3 id="7、问题"><a href="#7、问题" class="headerlink" title="7、问题"></a>7、问题</h3><h4 id="（1）将字符串“hello-world”从开始到打印到屏幕的全过程"><a href="#（1）将字符串“hello-world”从开始到打印到屏幕的全过程" class="headerlink" title="（1）将字符串“hello world”从开始到打印到屏幕的全过程"></a>（1）将字符串“hello world”从开始到打印到屏幕的全过程</h4><p>用户告诉操作系统需要运行程序-&gt;操作系统：查看程序是否是可执行文件；读取程首部信息，得到程序的数据和代码在可执行文件中位置并计算出对应磁盘块地址-&gt;操作系统：新建进程，将可执行文件映射到进程-&gt;操作系统：设置cpu上下文环境，跳到程序开始-&gt;执行第一条指令，缺页异常-&gt;操作系统分配物理页，将代码从磁盘读到内存，继续执行-&gt;执行puts函数（系统调用），在显示器显示字符串-&gt;操作系统：找到要进行显示的设备，将字符串传给负责该设备的进程-&gt;操作系统：进程告诉设备的系统窗口，要显示字符串，系统窗口检查这是一个合法操作，将字符串转化为像素，将像素写入设备的存储映像区-&gt;视频硬件将像素转换成显示器可接受和一组数据控制数据信号-&gt;显示器解释信号，激发液晶屏-&gt;看到</p><h4 id="（2）什么在编译时得到，什么在运行时得到"><a href="#（2）什么在编译时得到，什么在运行时得到" class="headerlink" title="（2）什么在编译时得到，什么在运行时得到"></a>（2）什么在编译时得到，什么在运行时得到</h4><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20250313113640796.png" alt="image-20250313113640796" style="zoom:50%;" /><h2 id="二、main"><a href="#二、main" class="headerlink" title="二、main"></a>二、main</h2><h3 id="1、什么操作在main函数之前、之后进行"><a href="#1、什么操作在main函数之前、之后进行" class="headerlink" title="1、什么操作在main函数之前、之后进行"></a>1、什么操作在main函数之前、之后进行</h3><p>宏定义包含在预处理阶段（宏、头文件包含（#include）、条件编译（#ifdef）），不在程序运行的编译阶段</p><h4 id="（1）前"><a href="#（1）前" class="headerlink" title="（1）前"></a>（1）前</h4><p>栈指针、类、全局变量（全局变量、静态全局变量、全局对象的构造函数；加载初始值.data和初始化.bss）、main的参数（argv、argc）的传递会在main函数之前进行；静态变量分配内存</p><h4 id="（2）后"><a href="#（2）后" class="headerlink" title="（2）后"></a>（2）后</h4><p>全局对象的析构函数会在main函数之后进行</p><h4 id="（3）问题"><a href="#（3）问题" class="headerlink" title="（3）问题"></a>（3）问题</h4><h5 id="①在main函数中定义static变量，是先运行main函数还是先初始化static变量"><a href="#①在main函数中定义static变量，是先运行main函数还是先初始化static变量" class="headerlink" title="①在main函数中定义static变量，是先运行main函数还是先初始化static变量"></a>①在main函数中定义static变量，是先运行main函数还是先初始化static变量</h5><p>如果是类的static成员或在main函数前定义的（全局静态变量），是在main函数执行前完成；但是如果是在main函数中定义的static（局部静态变量）对象，会先进入main再进行初始化，但是在程序启动时（main函数执行之前，运行时）分配内存（静态存储区）。</p><h3 id="2、程序在执行int-main-int-argc-char-argv-时的内存结构"><a href="#2、程序在执行int-main-int-argc-char-argv-时的内存结构" class="headerlink" title="2、程序在执行int main(int argc,char*argv[])时的内存结构"></a>2、程序在执行int main(int argc,char*argv[])时的内存结构</h3><p>程序在命令下运行时，需要输入argc个参数，每个参数都是以char类型输入的，依次存储在数组argv[]中，第一个参数为程序的名称</p><h3 id="3、main函数的返回值"><a href="#3、main函数的返回值" class="headerlink" title="3、main函数的返回值"></a>3、main函数的返回值</h3><p>必须是int才能传递给程序激活值（如操作系统）表示程序正常退出</p><h4 id="（1）非main函数将临时变量作为返回值"><a href="#（1）非main函数将临时变量作为返回值" class="headerlink" title="（1）非main函数将临时变量作为返回值"></a>（1）非main函数将临时变量作为返回值</h4><p>当函数退出，临时变量出栈被销毁，但是返回值被临时存储到寄存器中与临时变量的生命周期没有关系</p><h2 id="三、压栈"><a href="#三、压栈" class="headerlink" title="三、压栈"></a>三、压栈</h2><h3 id="1、C-函数调用的压栈过程"><a href="#1、C-函数调用的压栈过程" class="headerlink" title="1、C++函数调用的压栈过程"></a>1、C++函数调用的压栈过程</h3><h4 id="（1）根据程序main调用fun运行print-f-f"><a href="#（1）根据程序main调用fun运行print-f-f" class="headerlink" title="（1）根据程序main调用fun运行print(f(),f())"></a>（1）根据程序main调用fun运行print(f(),f())</h4><p>从main开始执行-&gt;编译器将操作系统的运行状态、main函数的返回地址、main函数的参数、main函数的变量（先定义先入栈）进行依次压栈；</p><p>调用fun函数-&gt;fun的参数（从右往左）、fun的返回地址、main的栈底地址和栈顶地址（栈顶地址（SP）是由硬件自动管理的，通常不需要显式保存）、fun函数的变量依次压栈</p><p>调用f函数-&gt;f函数的参数（从右往左）、f函数的返回地址、f函数的变量依次压栈（printf中调用两次，如果是常数从右往左压栈，但是如果是表达式则求值顺序不确定，这里是从左往右）</p><ul><li><strong>运行状态</strong>：通常由调用约定决定是否需要显式保存寄存器状态，而不是直接压栈。</li></ul><h4 id="（2）文字描述"><a href="#（2）文字描述" class="headerlink" title="（2）文字描述"></a>（2）文字描述</h4><p>栈空间分配存储空间</p><p>从实参的存储空间复制到形参空间</p><p>进行运算</p><h2 id="四、内存"><a href="#四、内存" class="headerlink" title="四、内存"></a>四、内存</h2><h3 id="1、内存分区-内存管理"><a href="#1、内存分区-内存管理" class="headerlink" title="1、内存分区&#x2F;内存管理"></a>1、内存分区&#x2F;内存管理</h3><p>栈</p><p>堆</p><p>全局&#x2F;静态数据区：全局变量和静态变量（包括初始化和未初始化）</p><p>常量区</p><p>代码区</p><h4 id="（1）栈和堆的区别"><a href="#（1）栈和堆的区别" class="headerlink" title="（1）栈和堆的区别"></a>（1）栈和堆的区别</h4><p>栈存在静态分配（编译器分配）和动态分配（alloc），编译器自动释放，空间是连续的，向栈底扩展（从内存的高地址向低地址生长），系统提供，速度快；</p><p>堆是程序员自己申请的，需要自己释放，只有动态分配，空间是不连续的，会生成碎片，向高地址扩展，是C&#x2F;C++函数库，效率低</p><h5 id="①哪个快一点"><a href="#①哪个快一点" class="headerlink" title="①哪个快一点"></a>①哪个快一点</h5><p>栈更快。栈是操作系统在底层提供支持，有专门的寄存器和执行指令；堆是C&#x2F;C++函数库提供的，且需要访问两次内存（一次访问指针，一次找到指针所指的地址）</p><h5 id="②哪个建立对象更快"><a href="#②哪个建立对象更快" class="headerlink" title="②哪个建立对象更快"></a>②哪个建立对象更快</h5><p>堆需要调用函数</p><p>访问堆的一个单元要经历两次访存，栈只进行一次</p><h3 id="2、类的对象存储空间"><a href="#2、类的对象存储空间" class="headerlink" title="2、类的对象存储空间"></a>2、类的对象存储空间</h3><p>非静态成员数据类型大小之和（包括基类）+编译器额外加入的成员变量（如指向虚函数表的指针）+为了边缘对齐优化加入的padding（成员函数不占用对象内存（放在代码区包括静态函数））</p><h4 id="（1）空类"><a href="#（1）空类" class="headerlink" title="（1）空类"></a>（1）空类</h4><p>空类（无非静态数据成员）的对象size&#x3D;1，当作为基类size&#x3D;0，有虚函数大小根据虚函数指针确定</p><p>空类同样可以实例化，类对象大小和类大小相同，但是地址不同，类指针大小等于指针大小（4字节）</p><h3 id="3、内存池"><a href="#3、内存池" class="headerlink" title="3、内存池"></a>3、内存池</h3><p>内存分配方式，避免new、malloc由于内存分配大小不确定导致的内存碎片，封装malloc、free在真正使用内存前先分配一定数量的、大小相等的内存块</p><h3 id="4、动态内存申请（malloc-calloc-new）"><a href="#4、动态内存申请（malloc-calloc-new）" class="headerlink" title="4、动态内存申请（malloc, calloc, new）"></a>4、动态内存申请（malloc, calloc, new）</h3><p>都是在堆</p><h4 id="（1）分配虚拟内存空间和物理内存空间"><a href="#（1）分配虚拟内存空间和物理内存空间" class="headerlink" title="（1）分配虚拟内存空间和物理内存空间"></a>（1）分配虚拟内存空间和物理内存空间</h4><h5 id="①malloc"><a href="#①malloc" class="headerlink" title="①malloc"></a>①malloc</h5><p>手动计算内存大小</p><p>malloc&#x2F;ˈmælɒk&#x2F;动态申请内存时（没有进行初始化），操作系统会分配虚拟内存（虚拟内存通过页表映射到物理内存），但是并没有分配物理内存，当程序访问虚拟内存时，会触发“缺页”异常，于是才会进行物理内存的分配，这种分配方式称为“按需分页”</p><p>brk、mmap、munmap系统调用</p><p>brk将堆顶指针向高地址移动，扩大程序在运行时的堆大小（小于128k），mmap在进程的虚拟内存地址空间中找一块空闲的虚拟内存，获得一块可以操作的堆内存（大于128k）。</p><p>在第一次访问已分配的虚拟地址空间时，发生缺页中断，操作系统负责分配物理内存，建立虚拟内存和物理内存之间的映射关系</p><h5 id="②new"><a href="#②new" class="headerlink" title="②new"></a>②new</h5><p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20250315181709938.png" alt="image-20250315181709938"></p><h5 id="③calloc"><a href="#③calloc" class="headerlink" title="③calloc"></a>③calloc</h5><p>Calloc&#x2F;ˈkælɒk&#x2F;动态申请内存时，会直接进行初始化为0，所以会直接分配虚拟内存和物理内存，这也导致分配过程较慢</p><p>省去了人为计算空间</p><h5 id="④realloc"><a href="#④realloc" class="headerlink" title="④realloc"></a>④realloc</h5><p>给动态分配的空间分配额外的空间，用于扩充</p><h4 id="（2）malloc-free和new-delete的区别"><a href="#（2）malloc-free和new-delete的区别" class="headerlink" title="（2）malloc&#x2F;free和new&#x2F;delete的区别"></a>（2）malloc&#x2F;free和new&#x2F;delete的区别</h4><p>Malloc是C语言标准库函数，支持覆盖，需要库文件，不调用构造函数，不是类型安全的，返回的是void类型的指针，需要强制类型转换，需要计算内存分配大小，动态申请和释放，无法强制要求构造和析构</p><p>new是C++操作符（关键字），支持重载，自动调用构造函数，是类型安全的，返回具体类型的指针，自动分配内存大小（无需指出所需内存大小），new封装了malloc可以使用free但是仅仅是析构，没有释放内存</p><h4 id="（3）new、delete是如何实现的"><a href="#（3）new、delete是如何实现的" class="headerlink" title="（3）new、delete是如何实现的"></a>（3）new、delete是如何实现的</h4><p>复杂结构，New通过调用标准库函数分配内存，在分配的内存上调用对象的构造函数进行初始化，最后返回指向这个新创建对象的指针；</p><p>简单类型，new[]计算好大小后调用operate new</p><p>复杂类型：Delete调用析构函数，然后调用标准库函数释放内存</p><p>简单类型：delete默认调用free</p><h4 id="（4）为什么要有new-delete"><a href="#（4）为什么要有new-delete" class="headerlink" title="（4）为什么要有new&#x2F;delete"></a>（4）为什么要有new&#x2F;delete</h4><p>对非基本类型使用时，需要调用构造函数和析构函数，但是malloc是库函数，是已经编译的，不能把构造函数和析构函数强加（它在编译好的二进制库中（如 libc.so 或 msvcrt.dll），无法在运行时动态插入 C++ 的构造&#x2F;析构逻辑）</p><h4 id="（5）被free掉的空间是直接返还给内存吗"><a href="#（5）被free掉的空间是直接返还给内存吗" class="headerlink" title="（5）被free掉的空间是直接返还给内存吗"></a>（5）被free掉的空间是直接返还给内存吗</h4><p>不是，是先用双链表（尝试对小内存进行合并，避免碎片）存储，下一次需要分配空间时，会先从这些空间里查询是否有符合条件的空间</p><h4 id="（6）C-中有几种方式的new"><a href="#（6）C-中有几种方式的new" class="headerlink" title="（6）C++中有几种方式的new"></a>（6）C++中有几种方式的new</h4><h5 id="①explain"><a href="#①explain" class="headerlink" title="①explain"></a>①explain</h5><p>默认，失败返回bad_alloc异常</p><h5 id="②nothrow"><a href="#②nothrow" class="headerlink" title="②nothrow"></a>②nothrow</h5><p>失败返回NULL</p><h5 id="③placement"><a href="#③placement" class="headerlink" title="③placement"></a>③placement</h5><p>允许在一块已经成功分配的内存上重新构造对象或对象数组（反复使用一块较大的动态分配的内存），不分配内存</p><p>要显示调用析构函数，不要delete</p><h4 id="（7）delete-p、delete-p、allocator都有什么作用"><a href="#（7）delete-p、delete-p、allocator都有什么作用" class="headerlink" title="（7）delete p、delete[]p、allocator都有什么作用"></a>（7）delete p、delete[]p、allocator都有什么作用</h4><p>动态数组中[]里必须是整数，但可以不是常量，普通数组中必须是常数整数</p><p>new动态数组返回的并不是数组类型，而是一个元素类型的指针</p><p>delete[]按数组逆序的顺序进行销毁，调用数组中每个元素的析构函数；new时分配了4字节大小存储数组大小delete[]调出</p><p>allocator申请一部分内存，在需要时手动调用构造函数、析构函数</p><h4 id="（8）什么是内存泄露，如何检测与避免"><a href="#（8）什么是内存泄露，如何检测与避免" class="headerlink" title="（8）什么是内存泄露，如何检测与避免"></a>（8）什么是内存泄露，如何检测与避免</h4><p>堆内存泄露，使用后必须显式释放，否则这块内存就不能再被使用</p><p>后果：只发生一次小的内存泄露可能不被注意，但是当大量内存泄露，性能下降到内存逐渐用完，导致另一个程序失败</p><h5 id="①避免"><a href="#①避免" class="headerlink" title="①避免"></a>①避免</h5><p>计数：分配+1，释放-1-&gt;成对出现</p><p>基类析构函数声明为虚函数（否则静态绑定，使用基类指针删除派生类对象时，只会调用基类析构函数，不会调用派生类析构函数，可以是纯虚函数（变成抽象类，不能实例化））</p><p>数组要delete[]</p><p>遵循RAII原则，资源获取即初始化，资源释放即析构，通过对象的声明周期管理资源</p><p>智能指针，避免手动管理内存</p><h5 id="②检测工具"><a href="#②检测工具" class="headerlink" title="②检测工具"></a>②检测工具</h5><p>Linux用Valgrind&#x2F;ˈvælɡrɪnd&#x2F;；Windows用CRT库</p><h4 id="（9）类如何实现只能静态分配或动态分配"><a href="#（9）类如何实现只能静态分配或动态分配" class="headerlink" title="（9）类如何实现只能静态分配或动态分配"></a>（9）类如何实现只能静态分配或动态分配</h4><h5 id="①静态"><a href="#①静态" class="headerlink" title="①静态"></a>①静态</h5><p>把new、delete重载为private</p><h5 id="②动态"><a href="#②动态" class="headerlink" title="②动态"></a>②动态</h5><p>把构造、析构设为protected然后再用子类动态创建</p><h5 id="③建立类的对象有两种方式"><a href="#③建立类的对象有两种方式" class="headerlink" title="③建立类的对象有两种方式"></a>③建立类的对象有两种方式</h5><p>静态：编译器在栈上分配内存</p><p>动态：new（内存-&gt;构造函数）在堆</p><h3 id="5、大小端存储"><a href="#5、大小端存储" class="headerlink" title="5、大小端存储"></a>5、大小端存储</h3><p>大端存储：字数据的高字节位存储在低地址中</p><p>小端存储：字数据的低字节位存储在低地址中</p><p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20250313160530011.png" alt="image-20250313160530011"></p><h4 id="（1）如何判断？"><a href="#（1）如何判断？" class="headerlink" title="（1）如何判断？"></a>（1）如何判断？</h4><p>强制类型转换：int转化为char就只剩下低地址部分</p><p>unI&#x2F;On联合体：占用空间为字节长度最大值</p><p>通过位与操作屏蔽高位，保留最低两位：&amp;3</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 可执行程序 </tag>
            
            <tag> main </tag>
            
            <tag> 压栈 </tag>
            
            <tag> 内存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++数据结构(三)：面向对象三大特性</title>
      <link href="/my_tech_blog.github.io/2025/11/09/C++%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_3/"/>
      <url>/my_tech_blog.github.io/2025/11/09/C++%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_3/</url>
      
        <content type="html"><![CDATA[<h1 id="C-数据结构（三）：面向对象三大特性"><a href="#C-数据结构（三）：面向对象三大特性" class="headerlink" title="C++数据结构（三）：面向对象三大特性"></a>C++数据结构（三）：面向对象三大特性</h1><h2 id="一、继承"><a href="#一、继承" class="headerlink" title="一、继承"></a>一、继承</h2><h3 id="1、类之间的关系"><a href="#1、类之间的关系" class="headerlink" title="1、类之间的关系"></a>1、类之间的关系</h3><p>包含关系：成员属性</p><p>使用关系：成员函数，友元函数，传递参数</p><p>is-A：继承关系，具有传递性</p><h3 id="2、概念"><a href="#2、概念" class="headerlink" title="2、概念"></a>2、概念</h3><p>一个类继承了上一个类的属性和和方法，新的类包含上一个类的属性和方法，被称为子类或派生类，上一个类被称为父类或基类</p><h3 id="3、访问控制"><a href="#3、访问控制" class="headerlink" title="3、访问控制"></a>3、访问控制</h3><p>private、public、protected</p><h3 id="4、兼容性关系"><a href="#4、兼容性关系" class="headerlink" title="4、兼容性关系"></a>4、兼容性关系</h3><p>向上转型：派生类可以赋值给基类指针或引用，当使用基类指针或引用时，调用函数是基类的函数（静态绑定），虚函数则是派生类的函数（动态绑定）</p><h4 id="（1）静态类型、动态类型、静态绑定、动态绑定"><a href="#（1）静态类型、动态类型、静态绑定、动态绑定" class="headerlink" title="（1）静态类型、动态类型、静态绑定、动态绑定"></a>（1）静态类型、动态类型、静态绑定、动态绑定</h4><p>静态类型：对象在声明时采用的类型，在编译时已经确定</p><p>动态类型：指针或引用目前所指对象的类型，在运行期决定</p><p>静态绑定：绑定的是静态类型，所对应的函数或属性依赖与对象的静态类型，发生在编译期</p><p>动态绑定：动态类型，运行期（性能损失，但是多态性）</p><p>非虚函数一般是静态绑定，虚函数一般是动态绑定</p><p>引用可以使用动态绑定（虚函数）</p><h3 id="5、继承方式"><a href="#5、继承方式" class="headerlink" title="5、继承方式"></a>5、继承方式</h3><p>实现继承：派生类继承基类的实现，可以直接使用基类的功能</p><p>接口继承：只继承基类的接口（纯虚函数&#x3D;0），必须实现基类接口</p><p>可视继承：GUI框架，派生类继承基类的界面布局和控件</p><h3 id="6、继承种类"><a href="#6、继承种类" class="headerlink" title="6、继承种类"></a>6、继承种类</h3><h4 id="（1）多继承"><a href="#（1）多继承" class="headerlink" title="（1）多继承"></a>（1）多继承</h4><p>一个类作为派生类允许指定多个基类，称为多重继承</p><p>优点：可以调用多个基类接口</p><p>缺点：如果基类有共同基类，会导致二义性（菱形继承）</p><p>解决：全局符确定调用哪一份拷贝；虚拟继承，只有一份拷贝</p><h4 id="（2）菱形继承"><a href="#（2）菱形继承" class="headerlink" title="（2）菱形继承"></a>（2）菱形继承</h4><h4 id="（3）虚继承"><a href="#（3）虚继承" class="headerlink" title="（3）虚继承"></a>（3）虚继承</h4><p>用于解决菱形继承问题（Diamond Problem）的一种机制。当多个派生类继承自同一个基类，而这些派生类又被另一个类继承时，虚拟继承可以确保基类在最终派生类中只有一份实例，避免数据冗余和二义性。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">VirtualDerived1</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> Base &#123;&#125;;</span><br></pre></td></tr></table></figure><h3 id="7、组合与继承相比较"><a href="#7、组合与继承相比较" class="headerlink" title="7、组合与继承相比较"></a>7、组合与继承相比较</h3><p>组合一般优于继承，低耦合高内聚</p><h4 id="（1）继承"><a href="#（1）继承" class="headerlink" title="（1）继承"></a>（1）继承</h4><h5 id="①继承的优点"><a href="#①继承的优点" class="headerlink" title="①继承的优点"></a>①继承的优点</h5><p>子类可以重写父类的方法，实现对父类的扩展</p><h5 id="②继承的缺点"><a href="#②继承的缺点" class="headerlink" title="②继承的缺点"></a>②继承的缺点</h5><p>父类的内部细节对子类是可见的；子类从父类的继承方法在编译时就确定好了，无法在运行时更改；如果修改父类，子类必须做出对应修改，是一种高耦合，违背了面向对象的思想</p><h4 id="（2）组合（设计模式）"><a href="#（2）组合（设计模式）" class="headerlink" title="（2）组合（设计模式）"></a>（2）组合（设计模式）</h4><p>组合就是设计类时把要组合的类的对象加入到类中作为成员变量</p><h5 id="①组合的优点"><a href="#①组合的优点" class="headerlink" title="①组合的优点"></a>①组合的优点</h5><p>通过所包含的对象去调用其方法，所包含对象的细节对当前类是不可见的；可以在运行时动态的绑定所包含的对象，可以通过set方法给所包含的对象赋值；是低耦合关系，如果修改所包含对象类，不需要修改当前类的代码</p><h5 id="②组合的缺点"><a href="#②组合的缺点" class="headerlink" title="②组合的缺点"></a>②组合的缺点</h5><p>可能会产生过多对象；为了能够组合多个对象，必须仔细对接口进行定义</p><h3 id="8、问题"><a href="#8、问题" class="headerlink" title="8、问题"></a>8、问题</h3><h4 id="（1）基类为什么必须定义而非声明"><a href="#（1）基类为什么必须定义而非声明" class="headerlink" title="（1）基类为什么必须定义而非声明"></a>（1）基类为什么必须定义而非声明</h4><p>派生类包含并可以使用基类成员，为了使用必须知道是什么</p><h4 id="（2）构造函数和析构函数调用顺序"><a href="#（2）构造函数和析构函数调用顺序" class="headerlink" title="（2）构造函数和析构函数调用顺序"></a>（2）构造函数和析构函数调用顺序</h4><p>派生类对象创建时先调用基类的构造函数，再调用派生类的构造函数（虚基类-&gt;基类（继承顺序）-&gt;对象的vptr被初始化-&gt;类类型的成员对象构造函数（成员对象在类中的定义顺序）-&gt;派生类构造函数：成员初始化列表：声明顺序决定、代码）；</p><p>销毁时，先调用派生类的析构函数再调用基类的析构函数</p><h2 id="二、封装"><a href="#二、封装" class="headerlink" title="二、封装"></a>二、封装</h2><p>数据和代码捆绑在一起，避免外界干扰和不确定性访问。</p><p>把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行隐藏</p><h2 id="三、多态"><a href="#三、多态" class="headerlink" title="三、多态"></a>三、多态</h2><p>向不同的对象发送同样消息，不同对象在接收时会产生不同的行为</p><p>允许将种类型的指针赋值给父类类型的指针</p><h3 id="1、编译时多态：重载、模板"><a href="#1、编译时多态：重载、模板" class="headerlink" title="1、编译时多态：重载、模板"></a>1、编译时多态：重载、模板</h3><h4 id="（1）模板"><a href="#（1）模板" class="headerlink" title="（1）模板"></a>（1）模板</h4><p><code>templace &lt;typename type1,typename type2&gt;</code></p><p><code>type1 Max(type1 a,type2 a)&#123;</code></p><p><code>return a&gt;b?a:b;&#125;</code>&#x2F;&#x2F;有bug-&gt;能转型，否则重载&gt;</p><h5 id="①模板类和模板函数的区别是什么"><a href="#①模板类和模板函数的区别是什么" class="headerlink" title="①模板类和模板函数的区别是什么"></a>①模板类和模板函数的区别是什么</h5><p>类模板必须显式实例化（编译时生成具体类），程序员显式指定类型，必须<T>：类的结构（成员变量、内存布局）完全依赖类型参数，必须显式指定。</p><p>函数模板可以隐式或显示调用（实例化是编译器在处理函数调用时自动完成的（除非显式指定）），不必<T>：函数的参数和返回值类型可通过调用上下文推导，减少冗余代码。</p><h5 id="②为什么模板类一般都放在h文件中-模板和实现可不可以不写在一个文件里"><a href="#②为什么模板类一般都放在h文件中-模板和实现可不可以不写在一个文件里" class="headerlink" title="②为什么模板类一般都放在h文件中&#x2F;模板和实现可不可以不写在一个文件里"></a>②为什么模板类一般都放在h文件中&#x2F;模板和实现可不可以不写在一个文件里</h5><p>模板类很特殊，由template&lt;&gt;处理意味着在编译器不为它分配存储空间，一直处于等待状态一直等到被一个模板实例告知。模板类或函数的实现不能被编译成二进制代码，链接程序找不到地址。在编译器和连接器的某一处，有一处机制能去掉指定模板的重定义</p><p>在分离式编译的情况下，一个.cpp文件看不到其他.cpp文件，当发现未知符号，寄希望与连接器，为了能够让编译器看到完整的模板定义，放在h文件中</p><h3 id="2、运行时多态：覆盖（虚函数virtual）"><a href="#2、运行时多态：覆盖（虚函数virtual）" class="headerlink" title="2、运行时多态：覆盖（虚函数virtual）"></a>2、运行时多态：覆盖（虚函数virtual）</h3><h4 id="（1）虚表和虚基表指针"><a href="#（1）虚表和虚基表指针" class="headerlink" title="（1）虚表和虚基表指针"></a>（1）虚表和虚基表指针</h4><p>虚表（每个有虚函数的类（包括派生类）在编译期生成一个虚表，虚表是类级别的，所有同类对象共享同一虚表）：虚函数表的缩写，类中有virtual关键字修饰时，编译器会自动生成虚表（保存虚函数入口地址）；是全局共享，在编译时就构造完成，位于常量区，虚函数位于代码段</p><p>虚表指针（每个有虚函数的类的对象内部隐含一个 vptr（编译器自动插入），在对象的构造函数中，vptr 被赋值为当前类的虚表地址，是对象的一部分，随对象创建&#x2F;销毁而存在&#x2F;消失）：含有虚函数的类进行对象实例化时，对象地址的前四个字节存储的指向虚表的指针（对象内部的隐藏数据成员，构造函数初始化虚表指针，指向父类虚表或子类虚表）</p><p>通过this找到vptr-&gt;vptr找到vtable-&gt;从vtable找到函数地址-&gt;调用该地址函数</p><h4 id="（2）C-中类的虚函数数量对类的大小有什么影响？"><a href="#（2）C-中类的虚函数数量对类的大小有什么影响？" class="headerlink" title="（2）C++中类的虚函数数量对类的大小有什么影响？"></a>（2）C++中类的虚函数数量对类的大小有什么影响？</h4><p>类中虚函数会通过虚函数表实现，无论虚函数数量多少，类的大小只多一个虚函数表指针的大小。 </p><h4 id="（3）哪些函数不能是虚函数"><a href="#（3）哪些函数不能是虚函数" class="headerlink" title="（3）哪些函数不能是虚函数"></a>（3）哪些函数不能是虚函数</h4><p>构造函数、静态成员函数、内联函数、友元函数（不属于类的成员函数，不能被继承，没有虚函数的说法）、普通函数（不属于类的成员函数、不能被继承，没有虚函数的说法）</p><h5 id="③构造函数可以是虚函数吗"><a href="#③构造函数可以是虚函数吗" class="headerlink" title="③构造函数可以是虚函数吗"></a>③构造函数可以是虚函数吗</h5><p>不可以，若构造函数为虚函数，调用时它的虚表指针需要指向虚表，但此时对象尚未构造完成，虚指针未初始化</p><p>存储空间：构造函数是虚函数就需要通过虚表调用，查虚表需要vptr，但vptr需要构造函数初始化（构造函数调用第一件事就是初始化虚表指针）</p><h5 id="④构造函数和析构函数可以调用虚函数吗"><a href="#④构造函数和析构函数可以调用虚函数吗" class="headerlink" title="④构造函数和析构函数可以调用虚函数吗"></a>④构造函数和析构函数可以调用虚函数吗</h5><p>不提倡：在构造和析构期间不要调用虚函数，因为这类调用不会下降至派生类。</p><p>不使用动态联编。</p><p>构造函数：基类构造函数执行时，派生类尚未构造，此时虚表指针（vptr）指向基类的虚表，因此调用的永远是基类版本。</p><p>调用基类的虚函数时，析构函数已将子类数据成员销毁，此时vptr已指回基类虚表</p><h5 id="⑤静态函数和常函数可以定义为虚函数吗"><a href="#⑤静态函数和常函数可以定义为虚函数吗" class="headerlink" title="⑤静态函数和常函数可以定义为虚函数吗"></a>⑤静态函数和常函数可以定义为虚函数吗</h5><p>static不能：static成员不属于任何类对象和实例，定义为虚函数没有意义；静态成员函数没有this指针，无法访问vptr</p><h4 id="（4）虚函数的代价"><a href="#（4）虚函数的代价" class="headerlink" title="（4）虚函数的代价"></a>（4）虚函数的代价</h4><p>虚函数表、虚表指针-&gt;空间；不能内联（在编译阶段进行替代），虚函数运行阶段才能确定是哪种函数</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++数据结构(二)：C++11</title>
      <link href="/my_tech_blog.github.io/2025/11/09/C++%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_2/"/>
      <url>/my_tech_blog.github.io/2025/11/09/C++%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_2/</url>
      
        <content type="html"><![CDATA[<h1 id="C-数据结构（二）：C-11"><a href="#C-数据结构（二）：C-11" class="headerlink" title="C++数据结构（二）：C++11"></a>C++数据结构（二）：C++11</h1><h2 id="C-11"><a href="#C-11" class="headerlink" title="C++11"></a>C++11</h2><p>C++11是里程碑式更新，现代C++起点</p><h3 id="1、nullptr代替了NULL"><a href="#1、nullptr代替了NULL" class="headerlink" title="1、nullptr代替了NULL"></a>1、nullptr代替了NULL</h3><p>NULL来自C语言，一般由宏定义实现，而nullptr是C++11的新增关键字</p><p>NULL被定义位整数0，nullptr可以明确区分整型和指针类型，并且可以根据环境自动转换成相应的指针类型，但不会被转换为任何整型，使用不会造成参数传递错误</p><h3 id="2、引入了auto和decltype实现了类型推导"><a href="#2、引入了auto和decltype实现了类型推导" class="headerlink" title="2、引入了auto和decltype实现了类型推导"></a>2、引入了auto和decltype实现了类型推导</h3><h4 id="（1）auto"><a href="#（1）auto" class="headerlink" title="（1）auto"></a>（1）auto</h4><p>auto让编译器根据初值进行类型推演，获取变量类型，所以auto修饰的变量必须拥有初值</p><p>基于范围的for循环</p><h4 id="（2）decltype（表达式）"><a href="#（2）decltype（表达式）" class="headerlink" title="（2）decltype（表达式）"></a>（2）decltype（表达式）</h4><p>选择并返回操作数的类型，编译器只分析表达式的类型，并不实际计算表达式的值，可先不赋值</p><h4 id="（3）decltpye（auto）"><a href="#（3）decltpye（auto）" class="headerlink" title="（3）decltpye（auto）"></a>（3）decltpye（auto）</h4><p>可以用来声明变量以及指示函数返回类型，在使用时会用“&#x3D;”后的表达式代替auto，再根据decltype确定类型</p><h3 id="3、类和结构体中的初始化列表"><a href="#3、类和结构体中的初始化列表" class="headerlink" title="3、类和结构体中的初始化列表"></a>3、类和结构体中的初始化列表</h3><h3 id="4、lambda表达式（匿名函数）"><a href="#4、lambda表达式（匿名函数）" class="headerlink" title="4、lambda表达式（匿名函数）"></a>4、lambda表达式（匿名函数）</h3><p>编写内嵌的匿名函数（没有函数名），可以用来替换独立函数或函数对象。</p><p>每当定义一个lambda函数，编译器会自动生成一个闭包类型的对象。运行时会返回一个闭包类型，其实是一个右值（可以绑定到左值，auto x&#x3D; [] ()&#x2F;&#x2F;priority_queue就需要绑定到左值使用匿名函数）。闭包可以通过传值或引用的方法捕捉其封装作用域内的变量，[]用于捕获，可使用尾置指针（尾置返回类型）来返回指定类型，可以忽略参数和返回值（-&gt;返回类型，当类型复杂或存在多条返回类型时，需显示指定），但是必须包含捕获列表（可以为空但是必须存在）和函数体</p><p>mutable允许修改按值捕获的变量（int x,[x]，可以改变x的副本）</p><h3 id="5、新的容器类型"><a href="#5、新的容器类型" class="headerlink" title="5、新的容器类型"></a>5、新的容器类型</h3><h4 id="（1）forward-list（单向链表）"><a href="#（1）forward-list（单向链表）" class="headerlink" title="（1）forward_list（单向链表）"></a>（1）forward_list（单向链表）</h4><p>list(双向链表)</p><h3 id="6、右值引用和移动语义"><a href="#6、右值引用和移动语义" class="headerlink" title="6、右值引用和移动语义"></a>6、右值引用和移动语义</h3><p>移动语义允许将资源从一个对象“转移”到另一个对象，而非传统拷贝，避免了不必要的深拷贝，右值语义绑定到临时对象，表明可“窃取”其资源。move将左值强制转换为右值引用，表明资源可以被移动</p><h4 id="（1）左值、右值定义"><a href="#（1）左值、右值定义" class="headerlink" title="（1）左值、右值定义"></a>（1）左值、右值定义</h4><p>左值是可以出现在赋值语句左侧的表达式，通常标识一个内存地址，可以取地址</p><p>右值是只能出现在赋值语句右边的表达式，通常表示一个临时值（将亡值（通过盗取其他变量获得内存空间的变量）或纯右值（临时变量和不与对象关联的字面量值））</p><h4 id="（2）左值引用和右值引用"><a href="#（2）左值引用和右值引用" class="headerlink" title="（2）左值引用和右值引用"></a>（2）左值引用和右值引用</h4><p>引用必须立即进行初始化</p><p>左值引用：可以绑定在左值void func(int&amp; x);（左值常引用可以用右值初始化）左值引用是引用类型，但它是一个左值，因为它引用的是一个持久存在的对象。</p><p>右值引用：可以绑定在右值void func(int&amp;&amp; x);</p><h4 id="（3）函数参数"><a href="#（3）函数参数" class="headerlink" title="（3）函数参数"></a>（3）函数参数</h4><p>int com(int a,int&amp;b,int&amp;&amp;c);</p><p>其中a是按值传递，可以接受左值或右值；b是左值引用，只能绑定到左值（具名对象）；c是右值引用，明确接受右值</p><h3 id="7、智能指针"><a href="#7、智能指针" class="headerlink" title="7、智能指针"></a>7、智能指针</h3><p>RAII（资源获取及初始化：在构造函数中分配资源，在析构函数中释放资源）的典型应用，用于自动管理动态内存</p><p>智能指针是一个类，用来存储指向动态分配对象的指针，用类对象来管理动态分配的资源，当类对象声明周期结束后，自动调用析构函数释放资源</p><h4 id="（1）shared-ptr"><a href="#（1）shared-ptr" class="headerlink" title="（1）shared_ptr"></a>（1）shared_ptr</h4><p>使用引用计数器，允许多个智能指针指向同一个对象，每当多一个指针指向该对象时，引用技术加一，减少一个指针则减一，当计数为0会自动释放动态内存分配的资源</p><p>内部的引用计数是线程安全的，但调用对象需要单独加锁</p><p>不能将指针直接赋值给智能指针，一个是类，一个是指针，可以使用构造函数传入指针初始化，可以使用make_share初始化</p><ul><li>需要多个对象共享同一资源时（如缓存、观察者模式）。</li></ul><h4 id="（2）unique-ptr"><a href="#（2）unique-ptr" class="headerlink" title="（2）unique_ptr"></a>（2）unique_ptr</h4><p>独享所有语义权，一个非空总是拥有它所指向的资源，不支持普通的拷贝和复制（不能用在STL标准容器中），支持移动</p><ul><li>明确资源唯一所有权的场景（如工厂模式返回的对象）。</li></ul><h4 id="（3）weak-ptr"><a href="#（3）weak-ptr" class="headerlink" title="（3）weak_ptr"></a>（3）weak_ptr</h4><p>弱引用，引用计数shared_ptr会造成引用成环（指针之间相互指），导致计数无法清零，weaker_ptr是为了配合shared_ptr引入的，当它指向由shared_ptr管理的对象时，只引用不计数，当引用计数的shared_ptr都被销毁时，无论是否有weak_ptr资源都会被释放，所以weak_ptr不保证它指向的内存一定是有效的，在使用之前要检查是否为空（使用lock转化为share_ptr），与普通指针相比，可以检测到所管理的对象是否已经被释放</p><p>提供了一个对管理对象的访问手段</p><ul><li>打破 <code>shared_ptr</code> 的循环引用（如双向链表、观察者模式）。</li></ul><h4 id="（4）auto-ptr"><a href="#（4）auto-ptr" class="headerlink" title="（4）auto_ptr"></a>（4）auto_ptr</h4><p>已经废弃</p><p>解决有异常抛出时发生内存泄露的问题。有拷贝语义，但是拷贝后源对象变无效，可能会引发严重的问题，unique_ptr无拷贝语义，但是有移动语义，这样的错误不会再发生，因为必须使用move进行转移</p><h4 id="（5）手写智能指针类需要实现哪些函数"><a href="#（5）手写智能指针类需要实现哪些函数" class="headerlink" title="（5）手写智能指针类需要实现哪些函数"></a>（5）手写智能指针类需要实现哪些函数</h4><p>构造函数、拷贝构造函数（复制构造函数）、拷贝赋值运算符、析构函数、移动函数</p><h3 id="8、并发支持"><a href="#8、并发支持" class="headerlink" title="8、并发支持"></a>8、并发支持</h3><p>线程、原子操作</p><h3 id="9、变长模板"><a href="#9、变长模板" class="headerlink" title="9、变长模板"></a>9、变长模板</h3>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> C++11 </tag>
            
            <tag> 现代C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++数据结构(一)：与其他编程语言对比</title>
      <link href="/my_tech_blog.github.io/2025/11/09/C++%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_1/"/>
      <url>/my_tech_blog.github.io/2025/11/09/C++%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_1/</url>
      
        <content type="html"><![CDATA[<h1 id="C-数据结构-一-：与其他编程语言的对比"><a href="#C-数据结构-一-：与其他编程语言的对比" class="headerlink" title="C++数据结构(一)：与其他编程语言的对比"></a>C++数据结构(一)：与其他编程语言的对比</h1><h2 id="一、C-语言特性"><a href="#一、C-语言特性" class="headerlink" title="一、C++语言特性"></a>一、C++语言特性</h2><p>C++是一种强类型语言，支持泛型编程，兼具高性能和面向对象特性。</p><h2 id="二、C-与C语言的区别"><a href="#二、C-与C语言的区别" class="headerlink" title="二、C++与C语言的区别"></a>二、C++与C语言的区别</h2><h3 id="1、编程范式"><a href="#1、编程范式" class="headerlink" title="1、编程范式"></a>1、编程范式</h3><ul><li><p>C语言：面向过程编程</p></li><li><p>C++：面向对象编程，支持类、继承、多态等特性</p><p><img src="/my_tech_blog.github.io/img/C++1.png" alt="C++与C语言对比图"></p></li></ul><h3 id="2、类型安全"><a href="#2、类型安全" class="headerlink" title="2、类型安全"></a>2、类型安全</h3><p>类型安全即内存安全，确保程序不会访问未授权的内存区域。</p><ul><li>C语言：局部上下文类型安全；存在不安全操作如<code>printf</code>、<code>malloc</code>（返回<code>void*</code>）</li><li>C++：更强的类型安全；<code>new</code>（返回固定类型）、<code>dynamic_cast</code>、模板等特性</li></ul><h5 id="①-new-delete-与-malloc-free-的区别"><a href="#①-new-delete-与-malloc-free-的区别" class="headerlink" title="① new&#x2F;delete 与 malloc&#x2F;free 的区别"></a>① new&#x2F;delete 与 malloc&#x2F;free 的区别</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++方式</span></span><br><span class="line"><span class="type">int</span>* ptr = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">42</span>);</span><br><span class="line"><span class="keyword">delete</span> ptr;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C方式</span></span><br><span class="line"><span class="type">int</span>* ptr = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">*ptr = <span class="number">42</span>;</span><br><span class="line"><span class="built_in">free</span>(ptr);</span><br></pre></td></tr></table></figure><p>区别：</p><ul><li><code>new/delete</code>是运算符，<code>malloc/free</code>是函数</li><li><code>new</code>自动计算大小，<code>malloc</code>需要手动计算</li><li><code>new</code>会调用构造函数，<code>delete</code>会调用析构函数</li></ul><h3 id="3、string替代char"><a href="#3、string替代char" class="headerlink" title="3、string替代char*"></a>3、string替代char*</h3><p><code>std::string</code>对<code>char*</code>进行了封装，包含字符数组、长度等信息，支持动态扩展。</p><p>动态扩展机制：当空间不足时，申请原空间两倍的新空间，拷贝原内容并添加新内容。</p><p>字符串函数对比：</p><ul><li><p><code>strcpy</code> vs<code>memcpy</code>vs<code>sprintf</code> </p><p>strcpy的两个操作对象均为字符串，不需要指定长度，到’\0’，容易溢出；(strncpy：复制前n个字符，不能重叠，且必须有n个字符的空间)</p><p>memcpy的两个对象就是两个任意可操作的内存地址（内存块间的拷贝），第三个参数决定复制长度</p><p>sprintf的源操作对象是多种数据类型，目的操作对象是字符串</p><p>执行效率：memecpy&gt;strcpy&gt;sprintf</p></li><li><p><code>strlen</code> vs <code>sizeof</code></p><p>strlen是函数，在运行时得到，只能对结尾是‘\0’的字符串使用；sizeof是运算符，在编译时得到，无法使用于动态内存分配，可以对任何类型进行使用</p></li><li><p><code>strncpy</code> vs <code>snprintf</code></p></li></ul><p>  <code>strncpy</code> </p><p>  目标&gt;指定&gt;源长：将源长全部拷贝+‘\0’</p><p>  指定&lt;源长：拷贝指定长，不+’\0’</p><p>  指定长&gt;目标：运行时错误</p><h3 id="4、异常处理"><a href="#4、异常处理" class="headerlink" title="4、异常处理"></a>4、异常处理</h3><p>C++提供完整的异常处理机制：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;错误信息&quot;</span>);</span><br><span class="line">&#125; <span class="built_in">catch</span> (<span class="type">const</span> std::exception&amp; e) &#123;</span><br><span class="line">    std::cout &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="（1）异常"><a href="#（1）异常" class="headerlink" title="（1）异常"></a>（1）异常</h4><p>数组下标越界；除数为0；动态分配空间时空间不足</p><h4 id="（2）try检查-throw抛出-catch捕获"><a href="#（2）try检查-throw抛出-catch捕获" class="headerlink" title="（2）try检查&#x2F;throw抛出&#x2F;catch捕获"></a>（2）try检查&#x2F;throw抛出&#x2F;catch捕获</h4><p>catch(…)捕获任何异常</p><h4 id="（3）函数异常声明列表"><a href="#（3）函数异常声明列表" class="headerlink" title="（3）函数异常声明列表"></a>（3）函数异常声明列表</h4><p>int fun throw(){};</p><h4 id="（4）标准异常类"><a href="#（4）标准异常类" class="headerlink" title="（4）标准异常类"></a>（4）标准异常类</h4><p>exceptI&#x2F;On派生：</p><p>bad_typeid；bad_alloc；bad_cast；out_of_range（数组下标越界）</p><h4 id="（5）问题"><a href="#（5）问题" class="headerlink" title="（5）问题"></a>（5）问题</h4><h5 id="①C-如何处理多个异常"><a href="#①C-如何处理多个异常" class="headerlink" title="①C++如何处理多个异常"></a>①C++如何处理多个异常</h5><p>多重catch块和异常层次结构</p><h5 id="②异常情况"><a href="#②异常情况" class="headerlink" title="②异常情况"></a>②异常情况</h5><p>语法（编译）错误：可以被编译器发现并定位。如：变量未定义、括号不匹配、关键字拼写错误</p><p>运行时错误：数组下标越界、系统内存不足</p><h5 id="③怎么快速定位错误出现的地方"><a href="#③怎么快速定位错误出现的地方" class="headerlink" title="③怎么快速定位错误出现的地方"></a>③怎么快速定位错误出现的地方</h5><p>简单错误双击错误列表的错误项；复杂错误使用生成输出窗口、调试窗口</p><h6 id="段错误"><a href="#段错误" class="headerlink" title="段错误"></a>段错误</h6><p>访问空指针；访问已经释放的内存（悬空指针）；数组越界（可能是栈溢出可能是堆溢出）；栈溢出；访问只读内存</p><h6 id="堆溢出"><a href="#堆溢出" class="headerlink" title="堆溢出"></a>堆溢出</h6><p>动态内存分配错误（写入数据超过分配、内存大小计算错误）</p><p>数组越界</p><p>字符串操作不当（strcpy&#x2F;strcat不安全）</p><p>内存管理错误（释放后使用、多次释放、内存泄露导致空间耗尽）</p><h6 id="属于段错误的堆溢出"><a href="#属于段错误的堆溢出" class="headerlink" title="属于段错误的堆溢出"></a>属于段错误的堆溢出</h6><p>访问未分配的堆内存、溢出破坏堆管理结构、溢出到收保护的页、溢出导致无效的指针解引用、对齐错误的访问</p><h6 id="不会立即导致段错误的堆溢出"><a href="#不会立即导致段错误的堆溢出" class="headerlink" title="不会立即导致段错误的堆溢出"></a>不会立即导致段错误的堆溢出</h6><p>溢出到已分配的内存块（未越界到受保护区域）、覆盖管理结构但未触发检查、溢出但未跨页内存页边界、覆盖函数指针或对象数据、整数溢出导致堆分配过小</p><h3 id="5、输入输出流"><a href="#5、输入输出流" class="headerlink" title="5、输入输出流"></a>5、输入输出流</h3><p>C++使用控制态的输入输出流：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">std::cin &gt;&gt; variable;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;输出内容&quot;</span> &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><h4 id="（1）printf函数的实现原理"><a href="#（1）printf函数的实现原理" class="headerlink" title="（1）printf函数的实现原理"></a>（1）printf函数的实现原理</h4><p>printf函数 在处理参数的时候是从右向左处理的，其参数从右向左依次压入栈（计算后（求值顺序不确定））中，存放在栈中从高到低的地址里面，然后再格式化输出，输出时从低地址到高地址输出。</p><h4 id="（2）cout和printf有什么区别"><a href="#（2）cout和printf有什么区别" class="headerlink" title="（2）cout和printf有什么区别"></a>（2）cout和printf有什么区别</h4><p>cout&lt;&lt;是std::ostream的全局对象，后面可以跟不同的数据类型是因为已经进行了重载，是行缓冲输出，flush立即强迫缓冲输出、可利用endl刷新缓冲区（不可以\n）</p><p>printf是行缓冲输出（可以利用\n），不是无缓冲输出</p><h3 id="6、函数重载和模板"><a href="#6、函数重载和模板" class="headerlink" title="6、函数重载和模板"></a>6、函数重载和模板</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数重载</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">double</span> x)</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">max</span><span class="params">(T a, T b)</span> </span>&#123; <span class="keyword">return</span> a &gt; b ? a : b; &#125;</span><br></pre></td></tr></table></figure><h4 id="（1）重载（编译时多态）"><a href="#（1）重载（编译时多态）" class="headerlink" title="（1）重载（编译时多态）"></a>（1）重载（编译时多态）</h4><p>水平关系，同一范围，函数名相同，形参类型、数量不同</p><h5 id="①重载运算符"><a href="#①重载运算符" class="headerlink" title="①重载运算符"></a>①重载运算符</h5><p>只能重载已经存在的运算符，优先级和结合律和原来相同，不能改变运算符操作数个数</p><p>两种重载方式：成员函数；非成员函数。成员函数比非成员函数少一个参数，一元运算符必须是成员函数（[]（最好同时定义常量版本和非常量版本，通常返回引用）、-&gt;、&amp;），成员函数this绑定到左侧运算符对象</p><p>当既是一元运算符又是二元运算符，凭借参数的个数判断到底是那种运算符</p><h5 id="②重载函数的匹配原则"><a href="#②重载函数的匹配原则" class="headerlink" title="②重载函数的匹配原则"></a>②重载函数的匹配原则</h5><p>名字查找；确定候选函数；最佳匹配</p><h4 id="（2）覆盖（运行时多态）"><a href="#（2）覆盖（运行时多态）" class="headerlink" title="（2）覆盖（运行时多态）"></a>（2）覆盖（运行时多态）</h4><p>垂直关系，派生类中与基类函数同名、同返回值、同参数，基类中必须是虚函数</p><h4 id="（3）隐藏"><a href="#（3）隐藏" class="headerlink" title="（3）隐藏"></a>（3）隐藏</h4><p>垂直关系，派生类中与基类函数同名、同返回值、同参数，基类中不是虚函数&#x2F;派生类中与基类函数名相同，形参类型、数量不同</p><h4 id="（4）traits（特性萃取）技法"><a href="#（4）traits（特性萃取）技法" class="headerlink" title="（4）traits（特性萃取）技法"></a>（4）traits（特性萃取）技法</h4><p>模板编程的重要技术，广泛使用traits来获取类型相关信息并实现泛型算法：类型信息获取、算法优化、接口统一</p><p>type_traits特性（默认构造函数、拷贝构造函数、赋值运算符、析构函数（如果有一个空类会自动生成））</p><h3 id="7、关键字"><a href="#7、关键字" class="headerlink" title="7、关键字"></a>7、关键字</h3><h4 id="（1）C-98引入的四种类型转换（强制类型转换中四种显式类型转换）"><a href="#（1）C-98引入的四种类型转换（强制类型转换中四种显式类型转换）" class="headerlink" title="（1）C++98引入的四种类型转换（强制类型转换中四种显式类型转换）"></a>（1）C++98引入的四种类型转换（强制类型转换中四种显式类型转换）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">const_cast</span>&lt;T&gt;()    <span class="comment">// 去除const/volatile属性</span></span><br><span class="line"><span class="built_in">dynamic_cast</span>&lt;T&gt;()  <span class="comment">// 用于多态类型的向下转换</span></span><br><span class="line"><span class="built_in">static_cast</span>&lt;T&gt;()   <span class="comment">// 编译时类型转换</span></span><br><span class="line"><span class="built_in">reinterpret_cast</span>&lt;T&gt;() <span class="comment">// 底层重新解释</span></span><br></pre></td></tr></table></figure><h5 id="①reinterpret-cast"><a href="#①reinterpret-cast" class="headerlink" title="①reinterpret_cast"></a>①reinterpret_cast</h5><p>无关类型；不类型检查</p><h5 id="②const-cast"><a href="#②const-cast" class="headerlink" title="②const_cast"></a>②const_cast</h5><p>const、volatile</p><h5 id="③static-cast"><a href="#③static-cast" class="headerlink" title="③static_cast"></a>③static_cast</h5><p>没有类型检查，上行转换安全，下行转换；基本类型转换；表达式转成void；空指针-&gt;目标类型空指针；不能const、volatile</p><h6 id="比C语言中的转换强在哪里"><a href="#比C语言中的转换强在哪里" class="headerlink" title="比C语言中的转换强在哪里"></a>比C语言中的转换强在哪里</h6><p>更加安全；更加明显，能一眼看出是什么类型转换为什么类型，容易找出错误；可以清楚的辨别代码中每个显示的强制转换；可读性更好，能体现程序员的意图</p><h5 id="④dynamic-cast"><a href="#④dynamic-cast" class="headerlink" title="④dynamic_cast"></a>④dynamic_cast</h5><p>有类型检查，上行同static_cast，下行更安全（需要基类有虚函数），不安全会返回空指针</p><h5 id="⑥隐式类型转换"><a href="#⑥隐式类型转换" class="headerlink" title="⑥隐式类型转换"></a>⑥隐式类型转换</h5><p>不需要用户干预，编译器私下进行的类型转换行为</p><p>基本数据类型：小-&gt;大；自定义对象：子-&gt;父；构造函数：只接收一个参数（通过explicit禁止）</p><h3 id="8、引用"><a href="#8、引用" class="headerlink" title="8、引用"></a>8、引用</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>&amp; ref = a;  <span class="comment">// 引用，ref是a的别名</span></span><br></pre></td></tr></table></figure><h3 id="9、变量定义"><a href="#9、变量定义" class="headerlink" title="9、变量定义"></a>9、变量定义</h3><ul><li>C语言：变量必须定义在作用域开头</li><li>C++：变量可以在任何位置定义</li></ul><h2 id="三、C-与Python的区别"><a href="#三、C-与Python的区别" class="headerlink" title="三、C++与Python的区别"></a>三、C++与Python的区别</h2><h3 id="1、语言特性对比"><a href="#1、语言特性对比" class="headerlink" title="1、语言特性对比"></a>1、语言特性对比</h3><table><thead><tr><th align="left">特性</th><th align="left">Python解释语言</th><th align="left">C++编译语言</th></tr></thead><tbody><tr><td align="left">执行方式</td><td align="left">解释执行</td><td align="left">编译执行</td></tr><tr><td align="left">跨平台性</td><td align="left">天然跨平台</td><td align="left">需要针对平台编译</td></tr><tr><td align="left">库函数</td><td align="left">丰富</td><td align="left">相对较少但高效</td></tr><tr><td align="left">效率</td><td align="left">较低</td><td align="left">很高</td></tr><tr><td align="left">代码结构</td><td align="left">缩进</td><td align="left">花括号</td></tr><tr><td align="left">类型系统</td><td align="left">动态类型</td><td align="left">静态强类型</td></tr></tbody></table><h2 id="四、C-与Java的区别"><a href="#四、C-与Java的区别" class="headerlink" title="四、C++与Java的区别"></a>四、C++与Java的区别</h2><h3 id="1、垃圾回收-GC"><a href="#1、垃圾回收-GC" class="headerlink" title="1、垃圾回收(GC)"></a>1、垃圾回收(GC)</h3><h5 id="①-什么是GC"><a href="#①-什么是GC" class="headerlink" title="① 什么是GC"></a>① 什么是GC</h5><p>垃圾回收器在程序运行时自动识别和清理不再使用的对象，避免内存泄漏。</p><h5 id="②-为什么C-没有垃圾回收"><a href="#②-为什么C-没有垃圾回收" class="headerlink" title="② 为什么C++没有垃圾回收"></a>② 为什么C++没有垃圾回收</h5><ul><li>垃圾回收带来额外的空间和时间开销</li><li>需要维护引用计数和标记信息</li><li>单独的GC线程在空闲时进行回收操作</li><li>垃圾回收会使C++不适合底层系统编程</li></ul><h5 id="③-C-的替代方案"><a href="#③-C-的替代方案" class="headerlink" title="③ C++的替代方案"></a>③ C++的替代方案</h5><ul><li>手动内存管理</li><li>智能指针（RAII机制）</li></ul><h3 id="2、Java并发三大特性"><a href="#2、Java并发三大特性" class="headerlink" title="2、Java并发三大特性"></a>2、Java并发三大特性</h3><ul><li>原子性：操作不可中断</li><li>可见性：一个线程的修改对其他线程可见</li><li>有序性：程序执行顺序符合预期</li></ul><h3 id="3、元编程工具对比"><a href="#3、元编程工具对比" class="headerlink" title="3、元编程工具对比"></a>3、元编程工具对比</h3><p>代码操作代码，在编译或运行时动态生成、修改或分析代码逻辑</p><p>如：编译时元编程（C++的模板）；运行时元编程（Java反射）</p><ul><li>Java：原生支持自定义注解</li><li>C++：依赖属性或宏模拟元编程</li><li>Python：通过装饰器实现元编程</li></ul><p></p><h3 id="4、反射"><a href="#4、反射" class="headerlink" title="4、反射"></a>4、反射</h3><p>程序在运行时检查、修改自身结构或行为的能力</p><p>C++无原生反射：C++强调零成本抽象（不引入运行时开销）；静态类型系统和模板机制已足够强大，反射可能破坏编译期优化。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>C++在性能和控制力方面具有独特优势，适合系统编程、游戏开发、高性能计算等场景。理解C++与其他语言的区别有助于我们根据项目需求选择合适的编程语言。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 编程语言 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
