<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>数据库（一）：SQL | 技术博客</title><meta name="author" content="JT"><meta name="copyright" content="JT"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="数据库（一）：SQL一、数据类型（一）类型1、NULL（1）存储NULL 值列表：允许为空的字段，每个列对应有一个bit存储是否为空，为1则空 （二）比较1、varchar和char（1）概念varchar：变长字符串，长度是数据长度+1或2字节（数据长度） char：定长字符串，长度固定，用空格填充 （2）区别 存储方式：英文和汉字都两个字节；英文一个字节，汉字两个字节 二、函数（二）比较1、N">
<meta property="og:type" content="article">
<meta property="og:title" content="数据库（一）：SQL">
<meta property="og:url" content="https://jt159-code.github.io/my_tech_blog.github.io/2025/11/09/%E6%95%B0%E6%8D%AE%E5%BA%93_1/index.html">
<meta property="og:site_name" content="技术博客">
<meta property="og:description" content="数据库（一）：SQL一、数据类型（一）类型1、NULL（1）存储NULL 值列表：允许为空的字段，每个列对应有一个bit存储是否为空，为1则空 （二）比较1、varchar和char（1）概念varchar：变长字符串，长度是数据长度+1或2字节（数据长度） char：定长字符串，长度固定，用空格填充 （2）区别 存储方式：英文和汉字都两个字节；英文一个字节，汉字两个字节 二、函数（二）比较1、N">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://jt159-code.github.io/my_tech_blog.github.io/img/butterfly-icon.png">
<meta property="article:published_time" content="2025-11-08T16:05:01.000Z">
<meta property="article:modified_time" content="2025-11-23T08:48:12.250Z">
<meta property="article:author" content="JT">
<meta property="article:tag" content="SQL">
<meta property="article:tag" content="数据类型">
<meta property="article:tag" content="函数">
<meta property="article:tag" content="键">
<meta property="article:tag" content="执行">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://jt159-code.github.io/my_tech_blog.github.io/img/butterfly-icon.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "数据库（一）：SQL",
  "url": "https://jt159-code.github.io/my_tech_blog.github.io/2025/11/09/%E6%95%B0%E6%8D%AE%E5%BA%93_1/",
  "image": "https://jt159-code.github.io/my_tech_blog.github.io/img/butterfly-icon.png",
  "datePublished": "2025-11-08T16:05:01.000Z",
  "dateModified": "2025-11-23T08:48:12.250Z",
  "author": [
    {
      "@type": "Person",
      "name": "JT",
      "url": "https://jt159-code.github.io/my_tech_blog.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/my_tech_blog.github.io/img/favicon.png"><link rel="canonical" href="https://jt159-code.github.io/my_tech_blog.github.io/2025/11/09/%E6%95%B0%E6%8D%AE%E5%BA%93_1/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/my_tech_blog.github.io/css/index.css?v=5.5.2"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/my_tech_blog.github.io/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '数据库（一）：SQL',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><style>
  /* 全局字体大小调整 */
  body {
    font-size: 16px;
    line-height: 1.7;
  }
  
  /* 文章内容字体调整 */
  .article-content {
    font-size: 16px;
    line-height: 1.8;
  }
  
  /* 标题字体大小调整 */
  h1 {
    font-size: 2.2em;
  }
  h2 {
    font-size: 1.8em;
  }
  h3 {
    font-size: 1.5em;
  }
  h4 {
    font-size: 1.3em;
  }
  h5 {
    font-size: 1.1em;
  }
  h6 {
    font-size: 1em;
  }
  
  /* 代码块样式 - 去除高亮，使用简单样式 */
  pre, code {
    background: #f8f9fa !important;
    color: #333 !important;
    border: 1px solid #e9ecef !important;
    font-size: 15px !important;
  }
  
  /* 侧边栏目录样式调整 */
  #aside-content .toc-content {
    font-size: 14px;
  }
  #aside-content .toc-content .toc-item {
    margin: 4px 0;
  }
</style>
<meta name="generator" content="Hexo 7.3.0"></head><body><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/my_tech_blog.github.io/./img/bg.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/my_tech_blog.github.io/"><span class="site-name">技术博客</span></a><a class="nav-page-title" href="/my_tech_blog.github.io/"><span class="site-name">数据库（一）：SQL</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">数据库（一）：SQL</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-11-08T16:05:01.000Z" title="发表于 2025-11-09 00:05:01">2025-11-09</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-11-23T08:48:12.250Z" title="更新于 2025-11-23 16:48:12">2025-11-23</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/my_tech_blog.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="数据库（一）：SQL"><a href="#数据库（一）：SQL" class="headerlink" title="数据库（一）：SQL"></a>数据库（一）：SQL</h1><h2 id="一、数据类型"><a href="#一、数据类型" class="headerlink" title="一、数据类型"></a>一、数据类型</h2><h3 id="（一）类型"><a href="#（一）类型" class="headerlink" title="（一）类型"></a>（一）类型</h3><h4 id="1、NULL"><a href="#1、NULL" class="headerlink" title="1、NULL"></a>1、NULL</h4><h5 id="（1）存储"><a href="#（1）存储" class="headerlink" title="（1）存储"></a>（1）存储</h5><p>NULL 值列表：允许为空的字段，每个列对应有一个bit存储是否为空，为1则空</p>
<h3 id="（二）比较"><a href="#（二）比较" class="headerlink" title="（二）比较"></a>（二）比较</h3><h4 id="1、varchar和char"><a href="#1、varchar和char" class="headerlink" title="1、varchar和char"></a>1、varchar和char</h4><h5 id="（1）概念"><a href="#（1）概念" class="headerlink" title="（1）概念"></a>（1）概念</h5><p>varchar：变长字符串，长度是数据长度+1或2字节（数据长度）</p>
<p>char：定长字符串，长度固定，用空格填充</p>
<h5 id="（2）区别"><a href="#（2）区别" class="headerlink" title="（2）区别"></a>（2）区别</h5><p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20250324113356840.png" alt="image-20250324113356840"></p>
<p>存储方式：英文和汉字都两个字节；英文一个字节，汉字两个字节</p>
<h2 id="二、函数"><a href="#二、函数" class="headerlink" title="二、函数"></a>二、函数</h2><h3 id="（二）比较-1"><a href="#（二）比较-1" class="headerlink" title="（二）比较"></a>（二）比较</h3><h4 id="1、NOW（）和CURRENT-DATE（）"><a href="#1、NOW（）和CURRENT-DATE（）" class="headerlink" title="1、NOW（）和CURRENT_DATE（）"></a>1、NOW（）和CURRENT_DATE（）</h4><h5 id="（1）NOW（）"><a href="#（1）NOW（）" class="headerlink" title="（1）NOW（）"></a>（1）NOW（）</h5><p>年月日-时分秒</p>
<h5 id="（2）CURRENT-DATE（）"><a href="#（2）CURRENT-DATE（）" class="headerlink" title="（2）CURRENT_DATE（）"></a>（2）CURRENT_DATE（）</h5><p>年月日</p>
<h4 id="2、Drop-Delete-Truncate"><a href="#2、Drop-Delete-Truncate" class="headerlink" title="2、Drop&#x2F;Delete&#x2F;Truncate"></a>2、Drop&#x2F;Delete&#x2F;Truncate</h4><h5 id="（1）Drop"><a href="#（1）Drop" class="headerlink" title="（1）Drop"></a>（1）Drop</h5><p>DDL</p>
<p>删除表，包括所有依赖、索引、权限</p>
<h5 id="（2）Delete"><a href="#（2）Delete" class="headerlink" title="（2）Delete"></a>（2）Delete</h5><p>DML</p>
<p>table或view，删除表中的部分数据，不删除任何依赖，作为事务记录存入日志，需要提交执行可以回滚恢复（通常提交后无法回滚，但是可以设置），执行速度快</p>
<h5 id="（3）Truncate"><a href="#（3）Truncate" class="headerlink" title="（3）Truncate"></a>（3）Truncate</h5><p>DDL</p>
<p>只能对table，删除表中所有数据，但是保持行列名、索引等，自增长序号会从头开始，比delete（等于没有where的Delete）快</p>
<h2 id="三、SQL"><a href="#三、SQL" class="headerlink" title="三、SQL"></a>三、SQL</h2><h3 id="（一）连接"><a href="#（一）连接" class="headerlink" title="（一）连接"></a>（一）连接</h3><h4 id="1、内连接"><a href="#1、内连接" class="headerlink" title="1、内连接"></a>1、内连接</h4><p>两边的表只有匹配才会显示</p>
<h4 id="2、外连接"><a href="#2、外连接" class="headerlink" title="2、外连接"></a>2、外连接</h4><p>驱动表中不匹配的也显示，匹配表中仅显示匹配数据</p>
<p>左外连接：左边的表是驱动表</p>
<p>全外连接：连接表中不匹配的数据全部显示</p>
<h4 id="3、交叉连接"><a href="#3、交叉连接" class="headerlink" title="3、交叉连接"></a>3、交叉连接</h4><p>笛卡尔效应，数据数量是连接表中数据数量的乘积</p>
<h4 id="4、自连接"><a href="#4、自连接" class="headerlink" title="4、自连接"></a>4、自连接</h4><p>一个表与自身（赋予一个其它的表名）连接</p>
<h3 id="（二）慢查询"><a href="#（二）慢查询" class="headerlink" title="（二）慢查询"></a>（二）慢查询</h3><h4 id="1、什么是慢查询"><a href="#1、什么是慢查询" class="headerlink" title="1、什么是慢查询"></a>1、什么是慢查询</h4><p>执行时间超过预设阈值的数据库查询操作</p>
<p>全表查询、未使用索引的join、复杂子查询</p>
<h4 id="2、什么导致慢查询"><a href="#2、什么导致慢查询" class="headerlink" title="2、什么导致慢查询"></a>2、什么导致慢查询</h4><p>索引（索引设置不当、索引失效）</p>
<p>SQL写法（使用select*、复杂子查询、使用函数操作字段）</p>
<p>数据问题（单表数据量过大）</p>
<p>系统资源（内存不足、锁竞争、磁盘I&#x2F;O瓶颈）</p>
<p>配置不当（缓冲区大小设置不合理）</p>
<h4 id="3、怎么找慢查询原因"><a href="#3、怎么找慢查询原因" class="headerlink" title="3、怎么找慢查询原因"></a>3、怎么找慢查询原因</h4><p>定位：启用监控工具（记录执行时间超过阈值的SQL语句）、分析工具使用</p>
<ul>
<li>每条慢查询的执行次数、平均&#x2F;最大时间、扫描行数。</li>
<li>可能的关键问题（如全表扫描、临时表、文件排序）。</li>
</ul>
<p>分析：分析执行计划</p>
<h4 id="4、怎么优化"><a href="#4、怎么优化" class="headerlink" title="4、怎么优化"></a>4、怎么优化</h4><p>索引：添加组合索引，使用覆盖索引</p>
<p>SQL：重写子查询避免join</p>
<p>数据量：水平分表</p>
<p>架构：读写分离、引入缓存</p>
<h3 id="（三）视图和游标"><a href="#（三）视图和游标" class="headerlink" title="（三）视图和游标"></a>（三）视图和游标</h3><h4 id="1、视图"><a href="#1、视图" class="headerlink" title="1、视图"></a>1、视图</h4><h5 id="不存储数据"><a href="#不存储数据" class="headerlink" title="不存储数据"></a>不存储数据</h5><p>视图是虚拟的表（不存储任何数据），与包含数据的表不一样，视图只包含使用时动态检索数据的查询（只是一个查询的定义，数据仍然在底层表中），不包含任何列和数据。</p>
<h5 id="动态生成数据"><a href="#动态生成数据" class="headerlink" title="动态生成数据"></a>动态生成数据</h5><p>视图是一种动态生成的虚拟表，视图只包含使用时动态检索数据的查询（只是一个查询的定义，数据仍然在底层表中），通常是有一个表或者多个表的行或列的子集（基于一个或多个表的查询结果生成），具有和物理表相同的功能</p>
<h5 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h5><p>可以简化sql操作，简化表，保护数据；可以和普通的表一样操作</p>
<p>不能进行索引，大部分情况下不能改变，基于单个表&amp;&amp;未使用联结子查询分组聚集函数&amp;&amp;未使用DISTINCT（删除重复行）或 UNI&#x2F;ON（合并查询结果集，去重）</p>
<h4 id="2、游标"><a href="#2、游标" class="headerlink" title="2、游标"></a>2、游标</h4><p>对查询出的结果作为一个有效单元处理</p>
<h3 id="（四）其他定义"><a href="#（四）其他定义" class="headerlink" title="（四）其他定义"></a>（四）其他定义</h3><h4 id="1、什么是存储过程？用什么来调用？"><a href="#1、什么是存储过程？用什么来调用？" class="headerlink" title="1、什么是存储过程？用什么来调用？"></a>1、什么是存储过程？用什么来调用？</h4><p>是一个预编译SQL对象，比单纯的SQL语句执行要快</p>
<p>可以用一个命令对象调用，可以供外部程序调用</p>
<h2 id="三、键"><a href="#三、键" class="headerlink" title="三、键"></a>三、键</h2><p>数据库中主键、超键、候选键、外键</p>
<h5 id="（1）超键"><a href="#（1）超键" class="headerlink" title="（1）超键"></a>（1）超键</h5><p>数据库中唯一标识行的属性集</p>
<h5 id="（2）候选键"><a href="#（2）候选键" class="headerlink" title="（2）候选键"></a>（2）候选键</h5><p>最小的超键，没有多余属性的超键，是主键的候选者</p>
<h5 id="（3）候选键"><a href="#（3）候选键" class="headerlink" title="（3）候选键"></a>（3）候选键</h5><p>从候选键中选择的一个键，表的唯一标识符</p>
<h5 id="（4）外键"><a href="#（4）外键" class="headerlink" title="（4）外键"></a>（4）外键</h5><p>被引用表中的主键或候选键，维护数据（引用）完整性</p>
<h2 id="四、MySQL构造"><a href="#四、MySQL构造" class="headerlink" title="四、MySQL构造"></a>四、MySQL构造</h2><h3 id="（一）服务层"><a href="#（一）服务层" class="headerlink" title="（一）服务层"></a>（一）服务层</h3><p>连接器、查询缓存、分析器、优化器、执行器</p>
<h3 id="（二）存储引擎"><a href="#（二）存储引擎" class="headerlink" title="（二）存储引擎"></a>（二）存储引擎</h3><p>数据库管理系统的核心之一，负责数据的存储、管理、访问、索引支持</p>
<h4 id="1、InnoDB"><a href="#1、InnoDB" class="headerlink" title="1、InnoDB"></a>1、InnoDB</h4><p>MySQL数据库中最常用的存储引擎之一，事务型存储引擎</p>
<p>如果有主键使用主键为索引，否则使用第一个没有空的属性为索引，否则使用自增ID为聚簇索引，其余索引为二级索引（存储主键值）</p>
<p>默认使用B+树索引</p>
<h5 id="（1）Innodb为什么用自增ID为主键"><a href="#（1）Innodb为什么用自增ID为主键" class="headerlink" title="（1）Innodb为什么用自增ID为主键"></a>（1）Innodb为什么用自增ID为主键</h5><p>保证新数据总是插入到表的末尾，如果一页写满，会自动开辟新的一页，避免了随机插入导致的数据页分裂和频繁的磁盘I&#x2F;O操作</p>
<h4 id="2、MyISAM"><a href="#2、MyISAM" class="headerlink" title="2、MyISAM"></a>2、MyISAM</h4><p>适合特定的密集型读场景，不支持事务</p>
<p>没有聚簇索引，所有索引都是二级索引（存储数据物理地址）</p>
<h4 id="3、MyIASM和InnoDB实现B树索引方式的区别是什么"><a href="#3、MyIASM和InnoDB实现B树索引方式的区别是什么" class="headerlink" title="3、MyIASM和InnoDB实现B树索引方式的区别是什么"></a>3、MyIASM和InnoDB实现B树索引方式的区别是什么</h4><p>MyIASM：非聚簇索引（索引和数据分离）</p>
<p>B+树叶节点存储地址，先在B+树搜索索引，如果key存在，则提取出地址，根据地址找到数据</p>
<p>InnoDB：聚簇索引（存储在一起）</p>
<p>主索引（索引的key是主键）树叶节点的data域保存了完整的数据；不建议使用过长或非单调的字段作为主键，避免主索引频繁分列</p>
<p>其余索引称为辅助索引，data存储主键的值</p>
<h5 id="（1）覆盖索引和回表"><a href="#（1）覆盖索引和回表" class="headerlink" title="（1）覆盖索引和回表"></a>（1）覆盖索引和回表</h5><p>回表：通过辅助索引查询数据时，要先找到主键值，再根据主键值索引查找完整的数据行-&gt;增加额外的I&#x2F;O操作</p>
<p>覆盖索引：索引包含查询需要的所有列（主索引是覆盖索引，辅助索引可能是覆盖索引），避免回表操作</p>
<h4 id="4、区别"><a href="#4、区别" class="headerlink" title="4、区别"></a>4、区别</h4><p>InnoDB：事务型（提供ACID特性）；实现了重复读（通过多版本控制并发和间隙锁防止幻读）；支持行级锁（对某一行数据进行加锁，不能同时修改该行）；聚簇索引；不存储总行数</p>
<p>可靠性要求高或者要求事务、查询和更新都频繁</p>
<p>MyIASM：不支持事务；仅支持表级锁；非聚簇索引；存储总行数</p>
<p>不要求事务，插入不频繁，查询频繁</p>
<h4 id="5、事务"><a href="#5、事务" class="headerlink" title="5、事务"></a>5、事务</h4><h4 id="6、锁"><a href="#6、锁" class="headerlink" title="6、锁"></a>6、锁</h4><h4 id="7、索引"><a href="#7、索引" class="headerlink" title="7、索引"></a>7、索引</h4><h2 id="五、事务-锁-索引"><a href="#五、事务-锁-索引" class="headerlink" title="五、事务+锁+索引"></a>五、事务+锁+索引</h2><h3 id="事务四大特性（ACID）"><a href="#事务四大特性（ACID）" class="headerlink" title="事务四大特性（ACID）"></a>事务四大特性（ACID）</h3><h4 id="1、原子性"><a href="#1、原子性" class="headerlink" title="1、原子性"></a>1、原子性</h4><p>一个事务中的操作要不然全部完成，要不然不完成，不会结束在中间某个环节。如果发生错误，会恢复到事务执行前的状态</p>
<h5 id="（1）如何保证原子性"><a href="#（1）如何保证原子性" class="headerlink" title="（1）如何保证原子性"></a>（1）如何保证原子性</h5><p>恢复机制是通过回滚日志Innodb的undo log（事务修改之前的数据状态）实现的，所有事务进行时都会记录在日志，当事务提交后就无法回滚了</p>
<h5 id="（2）为什么要有数据回滚机制"><a href="#（2）为什么要有数据回滚机制" class="headerlink" title="（2）为什么要有数据回滚机制"></a>（2）为什么要有数据回滚机制</h5><p>当发生错误可以通过回滚修复；当整个系统崩溃，用户再次启动数据库可以通过查询日志回滚日志用于撤销未提交的事务，确保数据的一致性，所以先写回滚日志再写数据库</p>
<h4 id="2、一致性"><a href="#2、一致性" class="headerlink" title="2、一致性"></a>2、一致性</h4><p>在事务开始之前和事务结束之后，数据库的完整性（符合预设规则）没有被破坏</p>
<h5 id="（1）如何实现一致性"><a href="#（1）如何实现一致性" class="headerlink" title="（1）如何实现一致性"></a>（1）如何实现一致性</h5><p>数据库层面，通过原子性、隔离性、持久性保证一致性</p>
<p>应用层面，利用程序判断数据是否有效，决定回滚还是提交</p>
<h4 id="3、隔离性"><a href="#3、隔离性" class="headerlink" title="3、隔离性"></a>3、隔离性</h4><p>多个事务并发时，事务内部的操作与其它事务是隔离的</p>
<p>允许多个并发事务同事对数据进行读写的能力，放置交叉执行导致数据不一致</p>
<h5 id="（1）数据隔离级别"><a href="#（1）数据隔离级别" class="headerlink" title="（1）数据隔离级别"></a>（1）数据隔离级别</h5><p>多个事务并发时，如何控制事务间的可见性和影响；在数据一致性和并发性能之间权衡</p>
<p>未提交读：一个事务可以读取到另一个事务未提交的数据</p>
<p>提交读：一个事务只能读取另一个事务已经提交的数据</p>
<p>重复读：一个事务在执行期间看到的数据保持一致，即使其它事务修改了数据（MySQL的默认）</p>
<p>可串行化读：所有事务串行进行，完全隔离</p>
<h5 id="（2）特点"><a href="#（2）特点" class="headerlink" title="（2）特点"></a>（2）特点</h5><p>脏读：读取到未提交的数据，可能会回滚</p>
<p>不可重复读：多次读的结果不同</p>
<p>幻读：多次读取的返回行数不同（可能有插入）；InnoDB通过多版本并发控制（MVCC）和间隙锁避免</p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20250313204135468.png" alt="image-20250313204135468"></p>
<h5 id="（3）Read-View"><a href="#（3）Read-View" class="headerlink" title="（3）Read View"></a>（3）Read View</h5><p>类似数据快照</p>
<p>读提交在每个语句执行前都会生成一个Read View，而可重复读是启动事务时生成一个Read View，整个事务期间都使用这个Read View</p>
<img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20250503172250788.png" alt="image-20250503172250788" style="zoom:50%;" />

<h5 id="（4）可重复读避免幻读"><a href="#（4）可重复读避免幻读" class="headerlink" title="（4）可重复读避免幻读"></a>（4）可重复读避免幻读</h5><h6 id="快照读：普通select（MVCC多版本并发控制）"><a href="#快照读：普通select（MVCC多版本并发控制）" class="headerlink" title="快照读：普通select（MVCC多版本并发控制）"></a>快照读：普通select（MVCC多版本并发控制）</h6><p>通过版本链控制并发事务访问同一个记录，从聚簇索引中读取该行的最新数据版本，通过 Read View 判断该版本是否可见，如果不可见，则通过 roll_pointer 找到上一个版本重复判断</p>
<img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20250503172421200.png" alt="image-20250503172421200" style="zoom:67%;" />



<img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20250503172003028.png" alt="image-20250503172003028" style="zoom:33%;" />

<h6 id="当前读：for-updata（记录锁-间隙锁）"><a href="#当前读：for-updata（记录锁-间隙锁）" class="headerlink" title="当前读：for updata（记录锁+间隙锁）"></a>当前读：for updata（记录锁+间隙锁）</h6><p>当执行select ……for update时，会加上next-key lock，当有事务在锁范围内插入，会阻塞</p>
<h4 id="4、持久性"><a href="#4、持久性" class="headerlink" title="4、持久性"></a>4、持久性</h4><p>事务处理结束之后，修改就是永久的，即使系统故障页不会丢失</p>
<h5 id="（1）如何保证持久性"><a href="#（1）如何保证持久性" class="headerlink" title="（1）如何保证持久性"></a>（1）如何保证持久性</h5><p>MySQL是先从磁盘中读取数据到内存，然后在内存中进行数据修改，如果此时宕机，内存中的数据就会丢失。为了解决这个问题，在写入内存时，也记录在InnoDB的redo log（存储物理日志（页修改），事务执行过程中写入）重写日志中</p>
<p>在事务提交时，必须确保该事务的所有修改对应的redo log已经物理写入磁盘（组提交），当系统宕机，会利用重写日志恢复，再通过uodo log和binlog（存储逻辑日志（SQL语句），事务提交时写入）决定是回滚还是提交事务</p>
<h6 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h6><p>重写日志刷盘比数据页（磁盘中）刷盘快：体积小，只记录在哪一页修改了什么；一直往末位加，是顺序I&#x2F;O，不是随机I&#x2F;O</p>
<h4 id="5、三大日志"><a href="#5、三大日志" class="headerlink" title="5、三大日志"></a>5、三大日志</h4><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20250503192235460.png" alt="image-20250503192235460" style="zoom:80%;" />

<h5 id="（1）redo"><a href="#（1）redo" class="headerlink" title="（1）redo"></a>（1）redo</h5><p>持久性</p>
<h5 id="（2）uodo"><a href="#（2）uodo" class="headerlink" title="（2）uodo"></a>（2）uodo</h5><p>回滚、MVCC</p>
<h5 id="（3）bin"><a href="#（3）bin" class="headerlink" title="（3）bin"></a>（3）bin</h5><p>主从复制</p>
<h5 id="（4）UPdate过程"><a href="#（4）UPdate过程" class="headerlink" title="（4）UPdate过程"></a>（4）UPdate过程</h5><p>undo-redo（prepare）-binlog-redo（commit）</p>
<img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20250503192011843.png" alt="image-20250503192011843" style="zoom:50%;" />

<h5 id="（5）崩溃恢复过程"><a href="#（5）崩溃恢复过程" class="headerlink" title="（5）崩溃恢复过程"></a>（5）崩溃恢复过程</h5><p>检查redo中prepare但是没有commit，查看binlog中有（重做）无（回滚）</p>
<h4 id="6、链路中数据不一致的主要原因是什么"><a href="#6、链路中数据不一致的主要原因是什么" class="headerlink" title="6、链路中数据不一致的主要原因是什么"></a>6、链路中数据不一致的主要原因是什么</h4><p>网络延迟或丢包（重试）；并发操作；缓存不一致（日志或回滚）；事务未隔离；分布式系统一致性（CAP最多只能满足两个：一致性、可用性、must分区容错性</p>
<h5 id="（1）CAP"><a href="#（1）CAP" class="headerlink" title="（1）CAP"></a>（1）CAP</h5><p>所有节点在同一时刻看到的数据是完全相同的（强一致性）。</p>
<p>系统在任何请求下都能非错误响应（即使部分节点故障或网络分区）。</p>
<p>系统在网络分区（节点间通信中断）时仍能继续运行。</p>
<ul>
<li>金融系统 → CP（强一致，ZooKeeper默认）。</li>
<li>社交媒体 → AP（高可用）。</li>
<li>单机数据库-&gt;CA（云计算环境下P必须保留）</li>
</ul>
<p>最终一致性舍弃一致性，不保证立即一致</p>
<h3 id="（二）锁"><a href="#（二）锁" class="headerlink" title="（二）锁"></a>（二）锁</h3><h5 id="（1）全局锁"><a href="#（1）全局锁" class="headerlink" title="（1）全局锁"></a>（1）全局锁</h5><p>整个数据库处于只读状态</p>
<p>应用：全库逻辑备份</p>
<h5 id="（2）表级锁"><a href="#（2）表级锁" class="headerlink" title="（2）表级锁"></a>（2）表级锁</h5><p>不会造成死锁，容易冲突</p>
<p>表共享读锁：只阻塞写操作（在select之前给所有涉及的表）</p>
<p>表独占写锁：阻塞读操作和写操作（在增删改之前给相关表）</p>
<p>主表不适合使用MyISAM，如果有更新不能进行查询</p>
<h5 id="（3）行级锁"><a href="#（3）行级锁" class="headerlink" title="（3）行级锁"></a>（3）行级锁</h5><p>粒度小，并发度高；共享锁、排他锁</p>
<p>会死锁，冲突概率小</p>
<p>共享锁（S锁：读读共享，读写互斥）：两个事务可以锁同一个索引</p>
<p>排它锁（X锁：写写互斥，读写互斥）：insert、delete、updata</p>
<p>需要有索引，不然会变成表锁</p>
<h6 id="记录锁"><a href="#记录锁" class="headerlink" title="记录锁"></a>记录锁</h6><p>锁住一条记录</p>
<h6 id="间隙锁"><a href="#间隙锁" class="headerlink" title="间隙锁"></a>间隙锁</h6><p>锁定一个范围，不包含记录本身</p>
<p>普通间隙锁可共存，不冲突；插入意向锁与间隙锁冲突，会阻塞，导致冲突</p>
<h6 id="Next-Key-锁（记录锁-间隙锁）"><a href="#Next-Key-锁（记录锁-间隙锁）" class="headerlink" title="Next-Key 锁（记录锁+间隙锁）"></a>Next-Key 锁（记录锁+间隙锁）</h6><p>锁定一个范围且锁定记录本身</p>
<h3 id="（三）索引"><a href="#（三）索引" class="headerlink" title="（三）索引"></a>（三）索引</h3><h4 id="1、为什么使用索引"><a href="#1、为什么使用索引" class="headerlink" title="1、为什么使用索引"></a>1、为什么使用索引</h4><p>唯一性索引可以保证数据唯一性</p>
<p>加快数据检索速度（WHERE）：将无序数据变为相对有序数据（可能会降低增删改效率：维护成本、页分裂）</p>
<p>将随机I&#x2F;O转换为顺序I&#x2F;O</p>
<p>帮助服务器避免排序和临时表</p>
<p>加速表与表之间的联系，数据完整性</p>
<h5 id="（1）什么时候需要建立数据库索引"><a href="#（1）什么时候需要建立数据库索引" class="headerlink" title="（1）什么时候需要建立数据库索引"></a>（1）什么时候需要建立数据库索引</h5><p>频繁使用、缩小查询范围、需要排序；唯一、不为空、经常被查询、取值离散大、索引字段小</p>
<h5 id="（2）不宜"><a href="#（2）不宜" class="headerlink" title="（2）不宜"></a>（2）不宜</h5><p>不经常使用、特殊的数据类型</p>
<h4 id="2、为什么数据库索引采用B-树"><a href="#2、为什么数据库索引采用B-树" class="headerlink" title="2、为什么数据库索引采用B+树"></a>2、为什么数据库索引采用B+树</h4><p>B+树只要遍历叶子节点（叶子节点通过指针连接形成有序链表）就可以实现全部遍历（方便扫库），B树需要进行中序遍历，方便进行范围查询（用于检索满足某个范围内条件的所有数据），适合大规模数据</p>
<p>B+树的非叶子节点只存储键值和指针，不存储数据，每个节点可以存储更多的键值，树的高度低，减少了I&#x2F;O访问次数，存储利用率更高</p>
<h5 id="（1）为什么不使用哈希"><a href="#（1）为什么不使用哈希" class="headerlink" title="（1）为什么不使用哈希"></a>（1）为什么不使用哈希</h5><p>哈希查询速度快，适合等值查询</p>
<p>只能用于精确查询，不能用于范围查询；扩展时需要重新哈希所有数据，开销大；哈希冲突；无序性</p>
<p>从内存角度上来说，数据库的索引一般在磁盘，数据量大时没有办法一次性装入内存，B+树可以装入一个子树</p>
<p>业务场景，范围查询</p>
<h5 id="（2）为什么不使用B树"><a href="#（2）为什么不使用B树" class="headerlink" title="（2）为什么不使用B树"></a>（2）为什么不使用B树</h5><p>非叶子节点存储数据，树的高度高，增加磁盘I&#x2F;O次数；数据分布在所有节点中，范围查询需要遍历多个节点（B+树叶子节点使用链表连接）；没有冗余节点，插入和删除效率比B+树低（B+树大多数只调整叶子节点，B树可能会分裂合并）</p>
<h5 id="（3）为什么不使用红黑树（自平衡二叉树）"><a href="#（3）为什么不使用红黑树（自平衡二叉树）" class="headerlink" title="（3）为什么不使用红黑树（自平衡二叉树）"></a>（3）为什么不使用红黑树（自平衡二叉树）</h5><p>二叉树高度高，磁盘I&#x2F;O多；不适合范围查询；节点大小不固定，无法充分利用磁盘空间</p>
<h5 id="（4）为什么不使用二叉搜索树"><a href="#（4）为什么不使用二叉搜索树" class="headerlink" title="（4）为什么不使用二叉搜索树"></a>（4）为什么不使用二叉搜索树</h5><p>不平衡：可能会退化为链表；高度高；不适合范围查询；不适合磁盘存储</p>
<p>复杂度、高度</p>
<h5 id="（5）怎么构建"><a href="#（5）怎么构建" class="headerlink" title="（5）怎么构建"></a>（5）怎么构建</h5><p>构造：通过插入实现</p>
<p>插入：从根节点开始，递归查找合适的叶子节点，找到叶子节点进行插入，如果叶子节点的值超过了m-1，那么进行上溢，叶子节点分裂，中间节点上提，父节点上溢则递归，如果根节点分裂则创建一个新的根节点</p>
<p>删除：从根节点开始，递归查找节点，删除节点，如果节点个数小于m&#x2F;2，向兄弟节点借，如果不富余则合并，如果内部节点下溢，则递归处理，如果根节点为空则删除根节点，子节点成为新的根节点</p>
<p>查询：</p>
<p>单值查询<em>O</em>(log<em>m**n</em>)：从根节点开始，递归查找叶子节点</p>
<p>范围查询<em>O</em>(log<em>m**n</em>+k)：找到起始键值所在的叶子节点，通过叶子节点的链表遍历到结束键值</p>
<h5 id="（6）增加B-树的路数可以降低树的高度，那么是否可以无限增加树的路数"><a href="#（6）增加B-树的路数可以降低树的高度，那么是否可以无限增加树的路数" class="headerlink" title="（6）增加B+树的路数可以降低树的高度，那么是否可以无限增加树的路数"></a>（6）增加B+树的路数可以降低树的高度，那么是否可以无限增加树的路数</h5><p>不可以</p>
<p>变成了一个有序数组，数据量过大无法一次性装入内存</p>
<h4 id="3、索引类型"><a href="#3、索引类型" class="headerlink" title="3、索引类型"></a>3、索引类型</h4><p>普通索引：进加速查询；唯一索引：加速+列值（可以有null）唯一；主键索引：加速+唯一（不可以有null）+表中只有一个；组合索引：多列值，组合试试，效率大于索引合并；索引合并：多个单列索引组合搜索</p>
<p>两种主要数据结构是哈希和B+</p>
<p>①哈希索引：巨大多数需求为单条索引，支持等值查询，不支持范围查询</p>
<p>②BTree索引：默认索引，支持范围查询和排序</p>
<p>③全文索引（倒排索引）：只有MyIASM支持，全文查询，支持模糊查询</p>
<p>④空间索引（R-Tree）：地理数据查询，优势在范围查找</p>
<h5 id="（1）按数据类型"><a href="#（1）按数据类型" class="headerlink" title="（1）按数据类型"></a>（1）按数据类型</h5><p>B+树、HASH、Full-text、R树</p>
<h5 id="（2）按物理存储"><a href="#（2）按物理存储" class="headerlink" title="（2）按物理存储"></a>（2）按物理存储</h5><p>聚簇索引（主键索引）、二级索引（辅助索引）</p>
<h5 id="（3）字段特性"><a href="#（3）字段特性" class="headerlink" title="（3）字段特性"></a>（3）字段特性</h5><p>主键（只能有一个）、唯一（建立在UNIOUE上，可以有多个，允许有空值）、普通、前缀（字符型字段前几个字符）</p>
<h5 id="（4）字段个数"><a href="#（4）字段个数" class="headerlink" title="（4）字段个数"></a>（4）字段个数</h5><p>单列、联合（在多列上，最左匹配原则）</p>
<h4 id="4、索引使用注意事项"><a href="#4、索引使用注意事项" class="headerlink" title="4、索引使用注意事项"></a>4、索引使用注意事项</h4><p>索引失效-&gt;全表扫描</p>
<p>不要在列上使用函数、进行运算、否定操作符（!&#x3D;、not in、&lt;&gt;、or连接where）-&gt;索引失效</p>
<p>多个单列索引并不是最佳选择，可以使用复合索引（最左前缀原则：查询中使用复合索引的第一个字段）</p>
<p>覆盖索引：定义一个索引包含额外的列</p>
<p>范围查询对多列查询的影响：范围查询的右侧的列无法使用索引</p>
<p>不包含NULL</p>
<p>查询左右两侧类型不匹配会发生隐式类型转换，索引失效</p>
<p>like语句（模糊查询：like”v%”可以使用索引，like”%v%”执行全表扫描）</p>
<img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20250413154501046.png" alt="image-20250413154501046" style="zoom:80%;" />

<img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20250414103355878.png" alt="image-20250414103355878" style="zoom:80%;" />

<p>在经常使用的列上建立索引</p>
<p>特大表建议使用逻辑索引</p>
<p>与业务无关使用逻辑主键（InnoDB的自增主键）</p>
<p>删除长时间未用的索引</p>
<p>limit offset查询缓存时，可以所以索引</p>
<h5 id="（1）适用索引"><a href="#（1）适用索引" class="headerlink" title="（1）适用索引"></a>（1）适用索引</h5><p>唯一</p>
<p>Where</p>
<p>Group by；order by</p>
<h5 id="（2）不适用"><a href="#（2）不适用" class="headerlink" title="（2）不适用"></a>（2）不适用</h5><p>Where；Group；Order用不到</p>
<p>大量重复数据</p>
<p>表数据太少</p>
<p>经常更新</p>
<h5 id="（3）优化索引"><a href="#（3）优化索引" class="headerlink" title="（3）优化索引"></a>（3）优化索引</h5><p>前缀索引</p>
<p>覆盖索引</p>
<p>主键最好自增</p>
<p>索引最好非空</p>
<p>防止索引失效：最左匹配（查询顺序）；函数或&lt;&gt;（改为范围或等值）；LIKE以通配符开头（尽量使用右模糊）；隐式转换（确保类型一致）；OR使用不当（使用UNION ALL）</p>
<h4 id="5、为什么不每一列都创建索引"><a href="#5、为什么不每一列都创建索引" class="headerlink" title="5、为什么不每一列都创建索引"></a>5、为什么不每一列都创建索引</h4><p>占据空间</p>
<p>创建索引和维护索引（索引需要动态维护，数据改变）要耗费时间</p>
<h4 id="6、B-树是怎么存储的"><a href="#6、B-树是怎么存储的" class="headerlink" title="6、B+树是怎么存储的"></a>6、B+树是怎么存储的</h4><p>叶子节点存放数据，非叶子节点只存放索引，每个节点的索引是按主键顺序存放的，每一层父节点的索引值都会出现在子节点的索引值中，所以所有索引都存放在叶子节点中，叶子节点有两个指针，形成双向链表</p>
<h5 id="（1）从数据页的角度看B-树"><a href="#（1）从数据页的角度看B-树" class="headerlink" title="（1）从数据页的角度看B+树"></a>（1）从数据页的角度看B+树</h5><p>InnoDB是按照数据页为单位来读写的，每个数据页通过双向链表组织起来，数据页内包含用户记录，记录之间通过单链表连接。</p>
<p>每个节点都是一个数据页，非叶子节点存放目录项，叶子节点存放数据</p>
<h2 id="六、执行"><a href="#六、执行" class="headerlink" title="六、执行"></a>六、执行</h2><h3 id="（二）MySQL是怎样执行一条SQL的"><a href="#（二）MySQL是怎样执行一条SQL的" class="headerlink" title="（二）MySQL是怎样执行一条SQL的"></a>（二）MySQL是怎样执行一条SQL的</h3><p>客户端请求-&gt;连接器验证用户身份，给予权限-&gt;查询缓存，有则直接返回，没有进行下一步操作-&gt;分析器，分析SQL语句词法分析和语法分析-&gt;优化器，查询最好的执行方案-&gt;执行器，查看是否有权限，有则执行，有才去使用这个引擎提供的接口-&gt;存储引擎返回结果，如果开启了查询缓存则会缓存查询结果</p>
<img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20250503153749869.png" alt="image-20250503153749869" style="zoom:67%;" /></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://jt159-code.github.io/my_tech_blog.github.io">JT</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://jt159-code.github.io/my_tech_blog.github.io/2025/11/09/%E6%95%B0%E6%8D%AE%E5%BA%93_1/">https://jt159-code.github.io/my_tech_blog.github.io/2025/11/09/%E6%95%B0%E6%8D%AE%E5%BA%93_1/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://jt159-code.github.io/my_tech_blog.github.io" target="_blank">技术博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/my_tech_blog.github.io/tags/SQL/">SQL</a><a class="post-meta__tags" href="/my_tech_blog.github.io/tags/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/">数据类型</a><a class="post-meta__tags" href="/my_tech_blog.github.io/tags/%E5%87%BD%E6%95%B0/">函数</a><a class="post-meta__tags" href="/my_tech_blog.github.io/tags/%E9%94%AE/">键</a><a class="post-meta__tags" href="/my_tech_blog.github.io/tags/%E6%89%A7%E8%A1%8C/">执行</a></div><div class="post-share"><div class="social-share" data-image="/my_tech_blog.github.io/img/butterfly-icon.png" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/my_tech_blog.github.io/2025/11/09/%E6%95%B0%E6%8D%AE%E5%BA%93_2/" title="数据库（二）：数据库"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">数据库（二）：数据库</div></div><div class="info-2"><div class="info-item-1">数据库（二）：数据库一、关系数据库与非关系数据库（一）关系数据库基于关系模型，使用表存储数据，表之间通过关系连接 1、特点容易理解 支持复杂查询 更新开销小 可以保持数据一致性 2、MySQL和SQLite的区别：MySQL是服务器-客户端模型；支持多用户高并发 SQLite是无服务器，直接读写文件；仅支持单线程写入 （二）非关系数据库不依赖关系模型，适用于非结构化或半结构化数据，NoSQL 1、特点不需要进行SQL层解析，读写效率高 基于键值对，易扩展 可以支持多种数据类型的存储 2、分类内容性数据库、文档型数据库 3、场景日志、地理位置存储、大数据、高可用 4、例子Redis、Hbase 二、性能（一）高扩展性能够通过增加资源来提升处理能力，以应对不断增长的工作负载和客户需求 （二）高可用在预定时间内持续提供服务，尽量减少停机时间 （三）高性能快速处理大量请求或数据，响应时间短，吞吐量高 （四）高并发同时处理用户的大量请求 1、实现方案缓存 索引 主从读写分类 拆分表 分布式架构 2、数据库并发代来的问题脏读：读取到未提交的数据，可能会回滚 不可重复读（修改）：多次读的结果不...</div></div></div></a><a class="pagination-related" href="/my_tech_blog.github.io/2025/11/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_7/" title="操作系统（七）："><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">操作系统（七）：</div></div><div class="info-2"><div class="info-item-1">操作系统（八）一、定义（一）局部性原理（1）时间局部性如果一条指令被执行（一个数据被访问），那么大概率有可能被再次执行（访问） （2）空间局部性但程序访问了某个存储单元，不久后，其附近的存储单元也可能被访问（很多数据、指令都是在内存中顺序存储的） （3）如何应对局部性原理快表：缓存最近使用的页表项,加速虚拟地址到物理地址的转换，避免每次访问内存都查询页表。（TLB是MMU的缓存，加速转换过程） 高速缓冲技术：近期会频繁访问的数据放入更高速的存储器中（外存（磁盘、磁带）-内存-高速缓冲-寄存器） （二）虚拟技术把一个物理实体转化为多个逻辑实体 时分复用技术：多进程和多线程 空分复用技术：虚拟内存 （三）系统并发和并行（1）并发宏观上在一段时间内能同时运行多个程序 操作系统进入线程和进程 （2）并行同一时刻能运行多个指令 需要硬件支持：多流水、多核处理器、分布式计算系统 （3）服务器高并发的解决方案应用数据与静态资源分离：静态资源服务器 静态页面展示 集群和分布式：多个服务器 反向代理：访问服务器时，服务器通过别的服务器获取资源或返回结果给客户端   （四）共享系统中资源可以被多个并...</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/my_tech_blog.github.io/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/my_tech_blog.github.io/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">JT</div><div class="author-info-description">专注于技术分享和学习</div><div class="site-data"><a href="/my_tech_blog.github.io/archives/"><div class="headline">文章</div><div class="length-num">32</div></a><a href="/my_tech_blog.github.io/tags/"><div class="headline">标签</div><div class="length-num">51</div></a><a href="/my_tech_blog.github.io/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9ASQL"><span class="toc-number">1.</span> <span class="toc-text">数据库（一）：SQL</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.1.</span> <span class="toc-text">一、数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E4%B8%80%EF%BC%89%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.1.1.</span> <span class="toc-text">（一）类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81NULL"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">1、NULL</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E5%AD%98%E5%82%A8"><span class="toc-number">1.1.1.1.1.</span> <span class="toc-text">（1）存储</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E4%BA%8C%EF%BC%89%E6%AF%94%E8%BE%83"><span class="toc-number">1.1.2.</span> <span class="toc-text">（二）比较</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81varchar%E5%92%8Cchar"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">1、varchar和char</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E6%A6%82%E5%BF%B5"><span class="toc-number">1.1.2.1.1.</span> <span class="toc-text">（1）概念</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E5%8C%BA%E5%88%AB"><span class="toc-number">1.1.2.1.2.</span> <span class="toc-text">（2）区别</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.</span> <span class="toc-text">二、函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E4%BA%8C%EF%BC%89%E6%AF%94%E8%BE%83-1"><span class="toc-number">1.2.1.</span> <span class="toc-text">（二）比较</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81NOW%EF%BC%88%EF%BC%89%E5%92%8CCURRENT-DATE%EF%BC%88%EF%BC%89"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">1、NOW（）和CURRENT_DATE（）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89NOW%EF%BC%88%EF%BC%89"><span class="toc-number">1.2.1.1.1.</span> <span class="toc-text">（1）NOW（）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%882%EF%BC%89CURRENT-DATE%EF%BC%88%EF%BC%89"><span class="toc-number">1.2.1.1.2.</span> <span class="toc-text">（2）CURRENT_DATE（）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81Drop-Delete-Truncate"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">2、Drop&#x2F;Delete&#x2F;Truncate</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89Drop"><span class="toc-number">1.2.1.2.1.</span> <span class="toc-text">（1）Drop</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%882%EF%BC%89Delete"><span class="toc-number">1.2.1.2.2.</span> <span class="toc-text">（2）Delete</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%883%EF%BC%89Truncate"><span class="toc-number">1.2.1.2.3.</span> <span class="toc-text">（3）Truncate</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81SQL"><span class="toc-number">1.3.</span> <span class="toc-text">三、SQL</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E4%B8%80%EF%BC%89%E8%BF%9E%E6%8E%A5"><span class="toc-number">1.3.1.</span> <span class="toc-text">（一）连接</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E5%86%85%E8%BF%9E%E6%8E%A5"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">1、内连接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E5%A4%96%E8%BF%9E%E6%8E%A5"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">2、外连接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E4%BA%A4%E5%8F%89%E8%BF%9E%E6%8E%A5"><span class="toc-number">1.3.1.3.</span> <span class="toc-text">3、交叉连接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81%E8%87%AA%E8%BF%9E%E6%8E%A5"><span class="toc-number">1.3.1.4.</span> <span class="toc-text">4、自连接</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E4%BA%8C%EF%BC%89%E6%85%A2%E6%9F%A5%E8%AF%A2"><span class="toc-number">1.3.2.</span> <span class="toc-text">（二）慢查询</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E6%85%A2%E6%9F%A5%E8%AF%A2"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">1、什么是慢查询</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E4%BB%80%E4%B9%88%E5%AF%BC%E8%87%B4%E6%85%A2%E6%9F%A5%E8%AF%A2"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">2、什么导致慢查询</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E6%80%8E%E4%B9%88%E6%89%BE%E6%85%A2%E6%9F%A5%E8%AF%A2%E5%8E%9F%E5%9B%A0"><span class="toc-number">1.3.2.3.</span> <span class="toc-text">3、怎么找慢查询原因</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81%E6%80%8E%E4%B9%88%E4%BC%98%E5%8C%96"><span class="toc-number">1.3.2.4.</span> <span class="toc-text">4、怎么优化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E4%B8%89%EF%BC%89%E8%A7%86%E5%9B%BE%E5%92%8C%E6%B8%B8%E6%A0%87"><span class="toc-number">1.3.3.</span> <span class="toc-text">（三）视图和游标</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E8%A7%86%E5%9B%BE"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">1、视图</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%8D%E5%AD%98%E5%82%A8%E6%95%B0%E6%8D%AE"><span class="toc-number">1.3.3.1.1.</span> <span class="toc-text">不存储数据</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E7%94%9F%E6%88%90%E6%95%B0%E6%8D%AE"><span class="toc-number">1.3.3.1.2.</span> <span class="toc-text">动态生成数据</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%94%A8%E9%80%94"><span class="toc-number">1.3.3.1.3.</span> <span class="toc-text">用途</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E6%B8%B8%E6%A0%87"><span class="toc-number">1.3.3.2.</span> <span class="toc-text">2、游标</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E5%9B%9B%EF%BC%89%E5%85%B6%E4%BB%96%E5%AE%9A%E4%B9%89"><span class="toc-number">1.3.4.</span> <span class="toc-text">（四）其他定义</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%EF%BC%9F%E7%94%A8%E4%BB%80%E4%B9%88%E6%9D%A5%E8%B0%83%E7%94%A8%EF%BC%9F"><span class="toc-number">1.3.4.1.</span> <span class="toc-text">1、什么是存储过程？用什么来调用？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E9%94%AE"><span class="toc-number">1.4.</span> <span class="toc-text">三、键</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E8%B6%85%E9%94%AE"><span class="toc-number">1.4.0.0.1.</span> <span class="toc-text">（1）超键</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E5%80%99%E9%80%89%E9%94%AE"><span class="toc-number">1.4.0.0.2.</span> <span class="toc-text">（2）候选键</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E5%80%99%E9%80%89%E9%94%AE"><span class="toc-number">1.4.0.0.3.</span> <span class="toc-text">（3）候选键</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%884%EF%BC%89%E5%A4%96%E9%94%AE"><span class="toc-number">1.4.0.0.4.</span> <span class="toc-text">（4）外键</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81MySQL%E6%9E%84%E9%80%A0"><span class="toc-number">1.5.</span> <span class="toc-text">四、MySQL构造</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E4%B8%80%EF%BC%89%E6%9C%8D%E5%8A%A1%E5%B1%82"><span class="toc-number">1.5.1.</span> <span class="toc-text">（一）服务层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E4%BA%8C%EF%BC%89%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="toc-number">1.5.2.</span> <span class="toc-text">（二）存储引擎</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81InnoDB"><span class="toc-number">1.5.2.1.</span> <span class="toc-text">1、InnoDB</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89Innodb%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8%E8%87%AA%E5%A2%9EID%E4%B8%BA%E4%B8%BB%E9%94%AE"><span class="toc-number">1.5.2.1.1.</span> <span class="toc-text">（1）Innodb为什么用自增ID为主键</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81MyISAM"><span class="toc-number">1.5.2.2.</span> <span class="toc-text">2、MyISAM</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81MyIASM%E5%92%8CInnoDB%E5%AE%9E%E7%8E%B0B%E6%A0%91%E7%B4%A2%E5%BC%95%E6%96%B9%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.5.2.3.</span> <span class="toc-text">3、MyIASM和InnoDB实现B树索引方式的区别是什么</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95%E5%92%8C%E5%9B%9E%E8%A1%A8"><span class="toc-number">1.5.2.3.1.</span> <span class="toc-text">（1）覆盖索引和回表</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81%E5%8C%BA%E5%88%AB"><span class="toc-number">1.5.2.4.</span> <span class="toc-text">4、区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E3%80%81%E4%BA%8B%E5%8A%A1"><span class="toc-number">1.5.2.5.</span> <span class="toc-text">5、事务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6%E3%80%81%E9%94%81"><span class="toc-number">1.5.2.6.</span> <span class="toc-text">6、锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7%E3%80%81%E7%B4%A2%E5%BC%95"><span class="toc-number">1.5.2.7.</span> <span class="toc-text">7、索引</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E4%BA%8B%E5%8A%A1-%E9%94%81-%E7%B4%A2%E5%BC%95"><span class="toc-number">1.6.</span> <span class="toc-text">五、事务+锁+索引</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E5%9B%9B%E5%A4%A7%E7%89%B9%E6%80%A7%EF%BC%88ACID%EF%BC%89"><span class="toc-number">1.6.1.</span> <span class="toc-text">事务四大特性（ACID）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E5%8E%9F%E5%AD%90%E6%80%A7"><span class="toc-number">1.6.1.1.</span> <span class="toc-text">1、原子性</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%8E%9F%E5%AD%90%E6%80%A7"><span class="toc-number">1.6.1.1.1.</span> <span class="toc-text">（1）如何保证原子性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89%E6%95%B0%E6%8D%AE%E5%9B%9E%E6%BB%9A%E6%9C%BA%E5%88%B6"><span class="toc-number">1.6.1.1.2.</span> <span class="toc-text">（2）为什么要有数据回滚机制</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-number">1.6.1.2.</span> <span class="toc-text">2、一致性</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-number">1.6.1.2.1.</span> <span class="toc-text">（1）如何实现一致性</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E9%9A%94%E7%A6%BB%E6%80%A7"><span class="toc-number">1.6.1.3.</span> <span class="toc-text">3、隔离性</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E6%95%B0%E6%8D%AE%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-number">1.6.1.3.1.</span> <span class="toc-text">（1）数据隔离级别</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E7%89%B9%E7%82%B9"><span class="toc-number">1.6.1.3.2.</span> <span class="toc-text">（2）特点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%883%EF%BC%89Read-View"><span class="toc-number">1.6.1.3.3.</span> <span class="toc-text">（3）Read View</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%884%EF%BC%89%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E9%81%BF%E5%85%8D%E5%B9%BB%E8%AF%BB"><span class="toc-number">1.6.1.3.4.</span> <span class="toc-text">（4）可重复读避免幻读</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%BF%AB%E7%85%A7%E8%AF%BB%EF%BC%9A%E6%99%AE%E9%80%9Aselect%EF%BC%88MVCC%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%EF%BC%89"><span class="toc-number">1.6.1.3.4.1.</span> <span class="toc-text">快照读：普通select（MVCC多版本并发控制）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%BD%93%E5%89%8D%E8%AF%BB%EF%BC%9Afor-updata%EF%BC%88%E8%AE%B0%E5%BD%95%E9%94%81-%E9%97%B4%E9%9A%99%E9%94%81%EF%BC%89"><span class="toc-number">1.6.1.3.4.2.</span> <span class="toc-text">当前读：for updata（记录锁+间隙锁）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81%E6%8C%81%E4%B9%85%E6%80%A7"><span class="toc-number">1.6.1.4.</span> <span class="toc-text">4、持久性</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%8C%81%E4%B9%85%E6%80%A7"><span class="toc-number">1.6.1.4.1.</span> <span class="toc-text">（1）如何保证持久性</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%A5%BD%E5%A4%84"><span class="toc-number">1.6.1.4.1.1.</span> <span class="toc-text">好处</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E3%80%81%E4%B8%89%E5%A4%A7%E6%97%A5%E5%BF%97"><span class="toc-number">1.6.1.5.</span> <span class="toc-text">5、三大日志</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89redo"><span class="toc-number">1.6.1.5.1.</span> <span class="toc-text">（1）redo</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%882%EF%BC%89uodo"><span class="toc-number">1.6.1.5.2.</span> <span class="toc-text">（2）uodo</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%883%EF%BC%89bin"><span class="toc-number">1.6.1.5.3.</span> <span class="toc-text">（3）bin</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%884%EF%BC%89UPdate%E8%BF%87%E7%A8%8B"><span class="toc-number">1.6.1.5.4.</span> <span class="toc-text">（4）UPdate过程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%885%EF%BC%89%E5%B4%A9%E6%BA%83%E6%81%A2%E5%A4%8D%E8%BF%87%E7%A8%8B"><span class="toc-number">1.6.1.5.5.</span> <span class="toc-text">（5）崩溃恢复过程</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6%E3%80%81%E9%93%BE%E8%B7%AF%E4%B8%AD%E6%95%B0%E6%8D%AE%E4%B8%8D%E4%B8%80%E8%87%B4%E7%9A%84%E4%B8%BB%E8%A6%81%E5%8E%9F%E5%9B%A0%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.6.1.6.</span> <span class="toc-text">6、链路中数据不一致的主要原因是什么</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89CAP"><span class="toc-number">1.6.1.6.1.</span> <span class="toc-text">（1）CAP</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E4%BA%8C%EF%BC%89%E9%94%81"><span class="toc-number">1.6.2.</span> <span class="toc-text">（二）锁</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E5%85%A8%E5%B1%80%E9%94%81"><span class="toc-number">1.6.2.0.1.</span> <span class="toc-text">（1）全局锁</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E8%A1%A8%E7%BA%A7%E9%94%81"><span class="toc-number">1.6.2.0.2.</span> <span class="toc-text">（2）表级锁</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E8%A1%8C%E7%BA%A7%E9%94%81"><span class="toc-number">1.6.2.0.3.</span> <span class="toc-text">（3）行级锁</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%AE%B0%E5%BD%95%E9%94%81"><span class="toc-number">1.6.2.0.3.1.</span> <span class="toc-text">记录锁</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%97%B4%E9%9A%99%E9%94%81"><span class="toc-number">1.6.2.0.3.2.</span> <span class="toc-text">间隙锁</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Next-Key-%E9%94%81%EF%BC%88%E8%AE%B0%E5%BD%95%E9%94%81-%E9%97%B4%E9%9A%99%E9%94%81%EF%BC%89"><span class="toc-number">1.6.2.0.3.3.</span> <span class="toc-text">Next-Key 锁（记录锁+间隙锁）</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E4%B8%89%EF%BC%89%E7%B4%A2%E5%BC%95"><span class="toc-number">1.6.3.</span> <span class="toc-text">（三）索引</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95"><span class="toc-number">1.6.3.1.</span> <span class="toc-text">1、为什么使用索引</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E9%9C%80%E8%A6%81%E5%BB%BA%E7%AB%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95"><span class="toc-number">1.6.3.1.1.</span> <span class="toc-text">（1）什么时候需要建立数据库索引</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E4%B8%8D%E5%AE%9C"><span class="toc-number">1.6.3.1.2.</span> <span class="toc-text">（2）不宜</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95%E9%87%87%E7%94%A8B-%E6%A0%91"><span class="toc-number">1.6.3.2.</span> <span class="toc-text">2、为什么数据库索引采用B+树</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E4%BD%BF%E7%94%A8%E5%93%88%E5%B8%8C"><span class="toc-number">1.6.3.2.1.</span> <span class="toc-text">（1）为什么不使用哈希</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E4%BD%BF%E7%94%A8B%E6%A0%91"><span class="toc-number">1.6.3.2.2.</span> <span class="toc-text">（2）为什么不使用B树</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E4%BD%BF%E7%94%A8%E7%BA%A2%E9%BB%91%E6%A0%91%EF%BC%88%E8%87%AA%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%89"><span class="toc-number">1.6.3.2.3.</span> <span class="toc-text">（3）为什么不使用红黑树（自平衡二叉树）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%884%EF%BC%89%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E4%BD%BF%E7%94%A8%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-number">1.6.3.2.4.</span> <span class="toc-text">（4）为什么不使用二叉搜索树</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%885%EF%BC%89%E6%80%8E%E4%B9%88%E6%9E%84%E5%BB%BA"><span class="toc-number">1.6.3.2.5.</span> <span class="toc-text">（5）怎么构建</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%886%EF%BC%89%E5%A2%9E%E5%8A%A0B-%E6%A0%91%E7%9A%84%E8%B7%AF%E6%95%B0%E5%8F%AF%E4%BB%A5%E9%99%8D%E4%BD%8E%E6%A0%91%E7%9A%84%E9%AB%98%E5%BA%A6%EF%BC%8C%E9%82%A3%E4%B9%88%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E6%97%A0%E9%99%90%E5%A2%9E%E5%8A%A0%E6%A0%91%E7%9A%84%E8%B7%AF%E6%95%B0"><span class="toc-number">1.6.3.2.6.</span> <span class="toc-text">（6）增加B+树的路数可以降低树的高度，那么是否可以无限增加树的路数</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E7%B4%A2%E5%BC%95%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.6.3.3.</span> <span class="toc-text">3、索引类型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E6%8C%89%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.6.3.3.1.</span> <span class="toc-text">（1）按数据类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E6%8C%89%E7%89%A9%E7%90%86%E5%AD%98%E5%82%A8"><span class="toc-number">1.6.3.3.2.</span> <span class="toc-text">（2）按物理存储</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E5%AD%97%E6%AE%B5%E7%89%B9%E6%80%A7"><span class="toc-number">1.6.3.3.3.</span> <span class="toc-text">（3）字段特性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%884%EF%BC%89%E5%AD%97%E6%AE%B5%E4%B8%AA%E6%95%B0"><span class="toc-number">1.6.3.3.4.</span> <span class="toc-text">（4）字段个数</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81%E7%B4%A2%E5%BC%95%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">1.6.3.4.</span> <span class="toc-text">4、索引使用注意事项</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E9%80%82%E7%94%A8%E7%B4%A2%E5%BC%95"><span class="toc-number">1.6.3.4.1.</span> <span class="toc-text">（1）适用索引</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E4%B8%8D%E9%80%82%E7%94%A8"><span class="toc-number">1.6.3.4.2.</span> <span class="toc-text">（2）不适用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E4%BC%98%E5%8C%96%E7%B4%A2%E5%BC%95"><span class="toc-number">1.6.3.4.3.</span> <span class="toc-text">（3）优化索引</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%AF%8F%E4%B8%80%E5%88%97%E9%83%BD%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95"><span class="toc-number">1.6.3.5.</span> <span class="toc-text">5、为什么不每一列都创建索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6%E3%80%81B-%E6%A0%91%E6%98%AF%E6%80%8E%E4%B9%88%E5%AD%98%E5%82%A8%E7%9A%84"><span class="toc-number">1.6.3.6.</span> <span class="toc-text">6、B+树是怎么存储的</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E4%BB%8E%E6%95%B0%E6%8D%AE%E9%A1%B5%E7%9A%84%E8%A7%92%E5%BA%A6%E7%9C%8BB-%E6%A0%91"><span class="toc-number">1.6.3.6.1.</span> <span class="toc-text">（1）从数据页的角度看B+树</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E6%89%A7%E8%A1%8C"><span class="toc-number">1.7.</span> <span class="toc-text">六、执行</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E4%BA%8C%EF%BC%89MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E6%89%A7%E8%A1%8C%E4%B8%80%E6%9D%A1SQL%E7%9A%84"><span class="toc-number">1.7.1.</span> <span class="toc-text">（二）MySQL是怎样执行一条SQL的</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/my_tech_blog.github.io/2025/11/10/%E6%89%8B%E6%92%95/" title="手撕">手撕</a><time datetime="2025-11-09T16:01:00.000Z" title="发表于 2025-11-10 00:01:00">2025-11-10</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/my_tech_blog.github.io/2025/11/10/%E6%B5%8B%E8%AF%84/" title="测评">测评</a><time datetime="2025-11-09T16:00:00.000Z" title="发表于 2025-11-10 00:00:00">2025-11-10</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/my_tech_blog.github.io/2025/11/09/%E5%9C%BA%E6%99%AF%E9%A2%98_1/" title="场景题（一）">场景题（一）</a><time datetime="2025-11-08T16:07:01.000Z" title="发表于 2025-11-09 00:07:01">2025-11-09</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/my_tech_blog.github.io/2025/11/09/%E9%9D%A2%E7%BB%8F_1/" title="面经（一）：华为">面经（一）：华为</a><time datetime="2025-11-08T16:07:01.000Z" title="发表于 2025-11-09 00:07:01">2025-11-09</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/my_tech_blog.github.io/2025/11/09/Redis_5/" title="Redis(五)：应用四分布式锁">Redis(五)：应用四分布式锁</a><time datetime="2025-11-08T16:06:05.000Z" title="发表于 2025-11-09 00:06:05">2025-11-09</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 By JT</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.2</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/my_tech_blog.github.io/js/utils.js?v=5.5.2"></script><script src="/my_tech_blog.github.io/js/main.js?v=5.5.2"></script><div class="js-pjax"></div><script>
  // 手动替换公告内容
  document.addEventListener('DOMContentLoaded', function() {
    const announcement = document.querySelector('.card-announcement');
    if (announcement) {
      announcement.innerHTML = `
        <div class="card-content">
          <div class="content">
            <strong>🚀 欢迎访问我的技术博客！</strong><br>
            📚 <strong>技术栈涵盖</strong>：<br>
            - C++ <br>
            - 计算机网络<br>
            - 操作系统<br>
            - 数据库<br>
            - Redis<br>
            - 场景题<br>
            - 面经<br>
            💡 <strong>博客特色</strong>：<br>
            • 面试宝典<br>
            ⏰ 更新时间：随我心意~
          </div>
        </div>
      `;
    }
  });
</script>
<script>
  document.addEventListener('DOMContentLoaded', function() {
    // 更强大的统计替换函数
    function replaceStats() {
      // 多种可能的选择器
      const visitorSelectors = [
        '.busuanzi_value_site_uv',
        '#busuanzi_value_site_uv',
        '.site-visitors .length-num',
        '[id*="visitor"]',
        '[class*="visitor"]'
      ];
      
      const viewSelectors = [
        '.busuanzi_value_site_pv', 
        '#busuanzi_value_site_pv',
        '.site-views .length-num',
        '[id*="view"]',
        '[class*="view"]'
      ];
      
      // 查找并替换访客数
      visitorSelectors.forEach(selector => {
        const elements = document.querySelectorAll(selector);
        elements.forEach(el => {
          if (el.textContent === '' || el.textContent.includes('加载') || el.textContent === '0') {
            el.textContent = '6666';
            el.style.opacity = '1';
          }
        });
      });
      
      // 查找并替换浏览量
      viewSelectors.forEach(selector => {
        const elements = document.querySelectorAll(selector);
        elements.forEach(el => {
          if (el.textContent === '' || el.textContent.includes('加载') || el.textContent === '0') {
            el.textContent = '8888';
            el.style.opacity = '1';
          }
        });
      });
      
      // 直接通过文本内容查找
      const infoCard = document.querySelector('.card-widget.card-webinfo');
      if (infoCard) {
        const html = infoCard.innerHTML;
        if (html.includes('本站访客数') && html.includes('加载中')) {
          infoCard.innerHTML = html.replace(/本站访客数[^<]*加载中[^<]*/, '本站访客数 : 6666')
                                   .replace(/本站总浏览量[^<]*加载中[^<]*/, '本站总浏览量 : 8888');
        }
      }
    }
    
    // 立即执行一次
    replaceStats();
    
    // 延迟再次执行确保覆盖
    setTimeout(replaceStats, 500);
    setTimeout(replaceStats, 2000);
    
    // 监听DOM变化
    const observer = new MutationObserver(replaceStats);
    observer.observe(document.body, { childList: true, subtree: true });
  });
</script>
<script async data-pjax src="/my_tech_blog.github.io/"></script></div></body></html>